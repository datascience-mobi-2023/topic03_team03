---
title: "Proteome-wide Screen for RNA-dependent Proteins in HeLa Cells Synchronized
  in Interphase"
author: "Hannah Brehm, Johann Blakytny, Kira Hoffmann, Viktor Bonin"
date: "XX.07.2023"
output:
  pdf_document: default
  word_document: default
subtitle: Data Analysis Project 2023
fontsize: 11pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
load("Environment.RData")
load("Table_HS_Non_RBP.RData")
# Environment clearen und dann Neues hinzufügen, mit allen nötigen Dataframes für die Graphen
```

***
# Abstract


***
\newpage

# 1. Introduction

```{r}
#test chunk
```


# 2. Material and Methods

## 2.1 Referenced Data
The protocol for an R-DeeP-Screen was performed on HeLa cells synchronized in interphase (Caudron-Herger *et al.*, 2020). This resulted in the dataframe *RDeep_HeLa_Interphase* in which the protein amounts per fraction were stored.

## 2.2 Data Cleanup
The original dataset *RDeep_HeLa_Interphase* was split into two separate data frames containing the values for all RNase fractions and Control fractions respectively. These dataframes were named *RNase_RDeep* and *Ctrl_RDeep* respectively. The following steps were performed on those two dataframes.

### 2.2.1 NA Values and Zero Rows
All rows containing only zeros, of which there were five, were deleted from the dataframes. No NA values were found.

### 2.2.2 Pearson Correlation
To test the reproducibility of the dataset the pearson correlation was used. In seven cases one of the three replicates contained only zeros. These values were replaced in *RNase_RDeep* and *Ctrl_RDeep* with NA values as determining the pearson correlation with these replicates would have been impossible. In five rows, two out of the three replicates contained only zeros. These genes were removed completely from the dataframes.
The pearson correlation $r$ was computed via the following formula using the sample size $N$, individual sample points $x_i$ and $y_i$, sample means $\bar{x}$ and $\bar{y}$ and standard deviations $s_x$ and $s_y$: $r = \frac{1}{N-1} \sum_{i = 1}^{N}{\frac{x_i - \bar{x}}{s_x} \frac{y_i - \bar{y}}{s_y}}$

The calculated correlation coefficients were saved in the dataframes *Ctrl_Cor* and *RNase_Cor*. For each gene and condition this resulted in three correlation coefficients with a determined threshold of over or equal to 0.95. The genes for which all three correlation coefficients fell below that threshold were removed from the dataframes *RNase_RDeep* and *Ctrl_RDeep*. This applied to 1335 genes. If two out of three correlation coefficients were under 0.95 the replicate associated with both coefficients was replaced with NA. This was the case for 2594 replicates. Lastly, if one out of three correlation coefficients was below the determined threshold the replicate with the lower value in the other associated correlation coefficient was replaced with NA. This method was performed on 2285 replicates.

### 2.2.3 Mean of Replicates
After testing for reproducibility and deleting unreliable values, the arithmetic mean for all triplicates was calculated. This was conducted on the in 2.2.2 modified dataframes *RNase_RDeep* and *Ctrl_RDeep* creating two new datasets called *Ctrl_Mean* and *RNase_Mean*.

### 2.2.4 Normalization and Standard Error
This step was executed solely for better graphical representation. At first, the rows of the dataframes *RNase_RDeep* and *Ctrl_RDeep* were normalized to a sum of 100. This data was stored in the dataframes *Ctrl_Norm100* and *RNase_Norm100*. Following the Normalization, the standerd deviation was calculated and saved as *Ctrl_Norm100_sd* and *RNase_Norm100_sd*.

## 2.3 Smoothing and Determination of Maxima

### 2.3.1 Smoothing the Data
To determine the global and local maxima of the dataset, the dataframes *Ctrl_Mean* and *RNase_Mean* first had to be smoothed. Otherwise the determination would be influenced by outliers and wrong peaks.  
For this the mean value of each fraction was calculated in a defined neighborhood of one with the following formula for all fractions between 2 and 24: $y = \frac{f(x-1)+f(x)+f(x-1)}{3}$    
*$x$: fraction position ($2  \leq  x  \leq  24$);* $\quad$ *$f(x)$: mass spectrometry value at fraction position $x$;* $\quad$ *$y$: smoothed value for fraction position $x$*  
  
For fraction position 1 and 25 the mean of fraction 1 and 2 and 24 and 25 were calculated: $y = \frac{f(1)+f(2)}{2};\qquad y = \frac{f(24)+f(25)}{2}$  
*$f(1), f(2)$ and $f(24), f(25)$: mass spectrometry value at fraction positions 1, 2 and 24, 25;* $\quad$ *$y$: smoothed value for fraction position 1 and 25*  
  
This was done separately for the *Ctrl_Mean* dataframe and the *RNase_Mean* dataframe and the smoothed data was then stored in following two dataframes: *Ctrl_Mean_Smooth* and *RNase_Mean_Smooth*.

### 2.3.2 Normalization of Smoothed data
For comparison of the different protein amounts, the dataframes *Ctrl_Mean_Smooth* and *RNase_Mean_Smooth* had to be normalized to 100. This means, that the sum of the mass spectrometry data in the different fractions for one protein had to add up to 100: $y = \frac{f(x)}{\sum_{x=1}^{25}f(x)} *100$     
*$x$: fraction position ($1 \leq x \leq 25$);* $\quad$ *$f(x)$: mass spectrometry value at fraction position $x$;* $\quad$ *$y$: normalized value at fraction position $x$*  
  
The normalized and smoothed values were then stored in the dataframes *Ctrl_Mean_Smooth_Norm100* and *RNase_Mean_Smooth_Norm100*.  

### 2.3.3 Determination of Maxima
If a protein is an RNA-dependent protein, the maximum amount of protein is in a significantly different fraction in the RNase sample compared to the Control sample. To determine for which proteins this is the case, the global and local maxima of the mass spectrometry data was determined.  
  
#### 2.3.3.1 Global Maxima \
The global maximum for the dataframes *Ctrl_Mean_Smooth_Norm100* and *RNase_Mean_Smooth_Norm100* were determined by identifying the fraction of the largest mass spectrometry value in each dataframe. For proteins that had 2 or 3 fractions with the same mass spectrometry value, the mean fraction position was calculated.  
The global maxima were stored in the dataframes *Ctrl_Mean_Gbl_Max* and *RNase_Mean_Gbl_Max*.

#### 2.3.3.2 Local Maximum \
The local maxima for the dataframes *Ctrl_Mean_Smooth_Norm100* and *RNase_Mean_Smooth_Norm100* were determined by comparing the protein amount of each fraction position x to the protein amount in the fractions in a neighborhood of $n = 2$. $\qquad [(x-2)][(x-1)][x][(x+1)][(x+2)]\qquad x: fraction position (3\leq x\leq 23)\qquad$ If the protein amount in that fraction is greater or equal to its neighborhood it was defined as a local maximum. For the edge cases $x=2;\quad x=24$ and $x=1;\quad x=25$ the protein amounts in these fractions had to be greater or equal to the protein amounts in the fractions $x=1;\quad x=3;\quad x=4$ and $x=22;\quad x=23;\quad x=25$ and $x=2;\quad x=3$ and $x=23;\quad x=24$. For proteins that had 2 or 3 fractions with the same mass spectrometry value, the mean fraction position was calculated. To distinguish the local from the global peaks the global peaks were subtracted from the local peaks.  
The local maxima were stored in the dataframes *Ctrl_Mean_Loc_Max* and *RNase_Mean_Loc_Max*.


## 2.4 Gaussian Fitting
A Gaussian curve was fitted to the global peak and local peak with the highest protein amount of each gene in the control and RNase samples. A Gaussian curve can be describe using the height $h$, standard deviation $\sigma$ and mean $\mu$ as: $f(x) = \frac {h} {\sqrt{2\pi} \cdot \sigma } \cdot e^{-\frac {1} {2} (\frac {x - \mu} {\sigma})^{2}}$. These parameters were first estimated and then optimized. $\mu$ was estimated as the fraction position of the global and largest local peak, $\sigma$ and $h$ were estimated as follows: $\sigma =\frac{HWHM}{\sqrt{2 \cdot ln(2)}};\qquad h = \frac{MPA}{sd \cdot \sqrt{2\pi}}\qquad$ *HWHM: half width at half maximum; MPA: maximum protein amount*. These estimated values were optimized by minimizing the sum of squares of the differences between protein amount values of the Gaussian curve $G$ and the smoothed and normalized protein distribution $p$ ($min(\sum(G-p)^2))$. This was used to calculate the protein amount under the Gaussian curve and the overlap of the Gaussian curves for the control and RNase samples. 

## 2.5 Selection Criteria for Identification of RNA-Dependent Proteins
To determine the optimal selection criteria for an RNA-dependent protein multiple parameters were compiled and applied to a principle component analysis.

### 2.5.1 Defining Selection Criteria
Following parameters were compiled to determine the optimal selection criteria for defining RNA-dependent proteins.

The *absolute peak shift and the percentage of the peak shift* 
between the Ctrl and RNase global peaks, 
between the global and main local peak of Ctrl,
and between the global and main local peak of RNase,   

the *absolute change and percentage of change* 
in the *standard deviation* between Ctrl and RNase, 
in the *global peak height* between Ctrl and RNase, 
and between the the *protein amount* under the gaussian curves of the Ctrl and RNase peaks,  

the *absolute protein amount and the percentage of protein amount*
that is lost under the global peak of Ctrl after RNase treatment,
and that is gained under the globak peak of RNase after RNase treatment,  

the *absolute differences and the percentage of the differences in the protein amounts*
of the Ctrl and RNase samples under the main local Ctrl peak,  

the *percentage of overlap*
between the gaussian curves of the Ctrl and RNase,
between the gaussian curves of the main local peak and global peak of Ctrl,
between the gaussian curves of the main local peak and global peak of RNase,
between the gaussian curves of the main local peaks of Ctrl and RNase.  

A *shift* is a character variable that states whether a protein is *left*, *right*, *non* shifting or *precipitated* and is defined as following:
$\Delta\mu = \mu(Ctrl)-\mu(RNase)> +1$: right shift; $\Delta\mu = \mu(Ctrl)-\mu(RNase)< -1$: left shift; $-1 \leq\Delta\mu = \mu(Ctrl)-\mu(RNase)\leq +1$: no shift;$\mu(Ctrl)>24 \lor \mu(RNase)>24$: precipitated  

All the parameters were stored in the dataframe *Sel_Crit*.

  
### 2.5.2 Principal Componant Analysis
Applying a principle component analysis to the percentage values of the selection criteria the optimal parameters for an RNA-dependent protein were examined by reducing the dimensions of the dataframe *Sel_Crit*. Only the variables calculated in percent were used for the PCA for better comparison and the variables regarding main local peaks only serve at determining partially shifting proteins and were therefore not included in the principle component analysis. The selection criteria that separate the points the most in the plot of the first two principal components were chosen for further analysis.   

### 2.5.3 Application of selection criteria  

Based on the PCA four parameters were defined as most important for separating shifting and non shifting proteins. Based on observations and experience we set the following thresholds for an RNA-dependent protein (RDP):

  1. Global peak shift of more than **1 fraction**
  2. Protein loss under Ctrl global peak of more than **20 %** after RNase treatment
  3. Protein gain under RNase global peak of more than **20 %** after RNase treatment
  4. Overlap of the Gaussian curves of less than **75 %**
  
Furthermore, *partially* RNA-dependent proteins were defined as proteins that satisfy the first and fourth criteria and either the second or third criteria for RNA dependence. More *partially* RNA-dependent proteins were identified using the following criteria: 

  1. Fraction shift between global and main local peak positions of more than **1 fraction**
  2. Overlap between the gaussian curves of global and main local peaks of less than **75 %**
  3. Overlap between the gaussian curves of the local peaks of less than **75 %**
  4. Protein gain under main local peak in relation to protein distribution of other sample under the same peak of more than **20 %**
  5. Protein amount at main local peak of more than **8**
  6. Previous categorization as **"non RDP"**


## 2.6 Further Analysis
### 2.6.1 *k*-means Clustering
*k*-means clustering was applied to the principal component analysis to compare the resulting clusters with the identified RNA-dependent proteins. An elbow plot was used to identify the optimal number of clusters.  

### 2.6.2 Linear Regression    
Linear regression was applied to the loss of protein amount under the Gaussian curve of the global peak for the control sample and the gain of protein amount under the Gaussian curve of the global peak for the RNase sample. This aims at identifying proteins with a partial shift.

### 2.6.3 Comparison with the RBP2GO Database    
To evaluate the accuracy of this method, the identified RDPs were compared with the existing RDPs in the RBP2Go Database.

#### 2.6.3.1 Direct comparison  
In the direct comparison the categories RDP dependent yes or no were plotted in a Biplot.

#### 2.6.3.2 Comparison with RDP2Go-score  
For more accurate results the in this method identified RDPs were compared to the RDP2Go score.

#### 2.6.3.3 Cluster comparison with T-test  
 By calculating the **mean RBP2GO-score** for each cluster of the k means clustering,the RNA-dependence of a cluster was estimated. Using a two-sided t-Test, the significance of the differences between the mean values were calculated.The H0 and H1 hypotheses were defined as following: H0: The mean values are not significantly different from each other, H1: The mean values are significantly different from each other. 

#### 2.6.3.4 Venn Diagram and Bar Plot  
For better visualization of the results a Venn Diagram and Bar plot were created.

# 3. Results
## 3.1 Results of Data Cleanup
Using the data cleanup steps described in the methods, the original dataset *RDeep_HeLa_Interphase* was reduced from 7086 proteins to 5990 Proteins.As described in the Plots of CTCF_HUMAN, the smoothing and normalization steps applied to the dataset were successful.

```{r smoothed and normalized, echo=FALSE, out.width = "33%"}

# hier muss ich es noch irgendwie hinbekommen, eine Bildcaption für beide Bilder nebeneinander zu erzeugen...


### not smoothed and normalized
Gene_Plotter("CTCF_HUMAN", Gauss =F, conf =F, Type= "Raw")

### smoothed
Gene_Plotter("CTCF_HUMAN", Gauss=F, conf = F, Type="Smooth")

### smoothed and normalized
Gene_Plotter("CTCF_HUMAN", Gauss=F, conf=F, Type="Smooth and Norm")
```

## 3.2 Shifting behavior

In *Fig.* the shifting behavior is represented by plotting the global peak positions of the Control and RNase samples. Non-shifting proteins are lying an a line through the origin with a slope of 1, meaning the global peak position of the control and RNase samples are the same. Left-shifting proteins lie under this line, meaning the global peak of the Control sample is in a higher fraction position than the global peak of the RNase sample. Right-shifting proteins lie above this line, meaning the global peak of the RNase sample is in a larger fraction position than the global peak of the control sample. Precipitated proteins are proteins with a global position in the the 25th fraction. Most proteins (around 5153) are non-shifting. The largest group of shifting proteins are left-shifting (782 proteins)


```{r shifting behavior, echo=FALSE, out.width="33%"}

# peak positions und Einfärben nach "left", "right", "precipitated" und "no" shifting

col = rep(NA, nrow(Ctrl_RDeep))
col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"

plot(Ctrl_Gauss_Fit[, 1], RNase_Gauss_Fit[, 1], pch = 16, col = col, main = "Shifting Behavior", xlab = "Ctrl Gbl Peak Position", ylab = "RNase Gbl Peak Position")
legend("topleft", legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))



```

## 3.3 Results of PCA
In *Fig.* the PCA was applied to all selection criteria and the first and second principle component were plotted against each other. The different shifting behaviors of the proteins are shown by using different colors. Left shifting proteins (blue) spread along the following four selection criteria: delta_Glb_mu_%, Ctrl_Gbl_prt_porp_% and RNase_Gbl_prt_prop_% and negative Gbl_overlap_%. Therefore, they are defined as optimal selection criteria. To illustrate this, *Fig.* shows the first and second principle component plotted against each other of an analysis of the optimal selection criteria. This shows clearly, that  shifting proteins spread in the direction of delta_Glb_mu_%, Ctrl_Gbl_prt_porp_% and RNase_Gbl_prt_prop_%, whereas nonshifting proteins spread in the direction of the delta_Glb_mu_%. Since delta_Gbl_mu_% is the longest vector, it has the most influence on the shifting behavior.

```{r Principal components, echo=FALSE, out.width="50%"}

# PCA applied to all precentage selection criteria
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

library(ggplot2)
library(factoextra)

fviz_pca_biplot(pca, axes = c(1,2) , label = "var", col.var = "black", repel = T, col.ind = Sel_Crit[,25], pointshape =16, pointsize =1.5, palette = c("blue", "gray", "orange", "red"))

# PCA applied to following 4 selection criteria: delta_Gbl_mu_%**, **Ctrl_Gbl_prt_prop_%**, **RNase_Gbl_prt_prop_%** and **Gbl_overlap_%
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])
library(ggplot2)
library(factoextra)

fviz_pca_biplot(pca, axes = c(1,2) , label = "var", col.var = "black", repel = T, col.ind = Sel_Crit[,25], pointshape=16, pointsize=1.5, palette = c("blue", "gray", "orange", "red"))

```


## 3.4 Linear Regression

r^2 Wert: 0.6809688

```{r linear regression, echo=F, out.width="50%"}
# linear regression
col = rep(NA, nrow(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), ]))
col[which(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 26] == "yes")] = "blue"
col[which(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 26] == "partial")] = "orange"
col[which(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 26] == "no")] = "grey"

plot(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 9], Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 11], col = col, pch = 16, xlab = "Ctrl_Gbl_prt_prop", ylab = "RNase_Gbl_prt_prop")

fit <- lm(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 9] ~ Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 11])

curve(fit$coefficients[2]*x + fit$coefficients[1], lwd = 3, col = "blue", add = T)

```


## 3.5 Comparison with the RBP2GO Database

```{r comparision with RBP2Go Database, echo =F, out.width="50%"}

#n für die 4 ausgewählten Selektionskriterien
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

col = rep(NA, nrow(Sel_Crit))
col[which(Sel_Crit[, 26] == "yes")] = "blue"
col[which(Sel_Crit[, 26] == "partial")] = "orange"
col[which(Sel_Crit[, 26] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Our RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("RDP (", length(which(Sel_Crit[, 26] == "yes")), ")", sep =""), paste("partial RDP (", length(which(Sel_Crit[, 26] == "partial")), ")", sep =""), paste("non RDP (", length(which(Sel_Crit[, 26] == "no")), ")", sep ="")), pch = 16, col = c("blue","orange", "grey"))

col = rep(NA, nrow(Sel_Crit))
col[which(rownames(Sel_Crit) %in% rownames(Table_HS_RBP))] = "blue"
col[which(rownames(Sel_Crit) %in% rownames(Table_HS_Non_RBP))] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RBP2GO RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("RDP (", length(which(rownames(Sel_Crit) %in% rownames(Table_HS_RBP))), ")", sep =""), paste("non RDP (", length(which(rownames(Sel_Crit) %in% rownames(Table_HS_Non_RBP))), ")", sep ="")), pch = 16, col = c("blue", "grey"))

rm(pca, col)

```


## 3.6 Comparison with RBP2GO score - kmeans clustering

```{r Vergleich unserer Werte mit dem RBP2Go score, echo = F, out.width="50%"}
#Vergleich unserer Werte mit dem RBP2Go score
library(scales)

# ---> Gleiche Berechnungen für die 4 ausgewählten Selektionskriterien
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = alpha("blue", Sel_Crit[, 27]/100), main = "RBP2GO_Score", xlab = "PC1", ylab = "PC2")

rm(pca)


# Vergleich mit kmeans Clustering

# Diagramm
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

kmeans = kmeans(pca$x, 2, iter.max = 10, nstart = 1)

col = rep(NA, nrow(Sel_Crit))
col[which(kmeans$cluster == 1)] = "blue"
col[which(kmeans$cluster == 2)] = "red"

par(mar=c(4, 4, 4, 11), xpd=F)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "k-Means Clustering (n = 2)", xlab = "PC1", ylab = "PC2")
par(xpd=T)
legend("topright", 
       inset = c(-0.49,0), 
       legend = c(paste("Cluster 1 (", length(which(kmeans$cluster == 1)), ")", sep = ""), paste("(mu = ", round(mean(Sel_Crit[which(kmeans$cluster == 1), 27], na.rm = T), 2),",", " sd = ", round(sd(Sel_Crit[which(kmeans$cluster == 1), 27], na.rm = T)/sqrt(length(which(kmeans$cluster == 1))), 2), ")", sep = ""), paste("Cluster 2 (", length(which(kmeans$cluster == 2)), ")", sep = ""), paste("(mu = ", round(mean(Sel_Crit[which(kmeans$cluster == 2), 27], na.rm = T), 2),",", " sd = ", round(sd(Sel_Crit[which(kmeans$cluster == 2), 27], na.rm = T)/sqrt(length(which(kmeans$cluster == 2))), 2), ")", sep = ""), "", paste("p(1&2) = ", signif(t.test(Sel_Crit[which(kmeans$cluster == 1), 27], Sel_Crit[which(kmeans$cluster == 2), 27], alternative = "two.sided")$p.value, 3), sep = "")), 
       pch = 16, 
       col = c("blue", NA, "red", NA, NA, NA))

rm(pca, kmeans, col)

```


## 3.7 Bar plot

```{r Bar plot RBPs, echo=F, out.width="50%"}

# bar plot
par(mar=c(1, 3, 1, 7.5))
barplot(matrix(c(
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]))),
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_RBP))),
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_RBP))),
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]))),
  rep(NA, 4)),
  nrow = 4),
  axes = F,
  col = c("red", "orange", "yellow", "green"), 
  legend.text = c(paste("Non RDPs (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]))), ")", sep = ""), 
                  paste("RDPs (only RBP2GO) (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_RBP))), ")", sep = ""), 
                  paste("RDPS (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_RBP))), ")", sep = ""), 
                  paste("New RDPs (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]))), ")", sep = "")),
  )

```


## 3.8 Bar plot with weird analysis?

```{r}
#load("Environment_with_RDP.RData")

#col = rep(NA, nrow(Ctrl_RDeep))
#col[which(Sel_Crit_PCA[, 8] == "left")] = "blue"
#col[which(Sel_Crit_PCA[, 8] == "right")] = "red"
#col[which(Sel_Crit_PCA[, 8] == "precipitated")] = "orange"
#col[which(Sel_Crit_PCA[, 8] == "no")] = "grey"

#plot(Ctrl_Gauss_Fit[, 1], RNase_Gauss_Fit[, 1], pch = 16, col = col, main = "Shifting Behavior", xlab = "Ctrl Gbl Peak Position", ylab = "RNase Gbl Peak Position")
#legend("topleft", legend = c("left", "right", "precipitated", "no"), pch = 16, col = c("blue", "red", "orange", "grey"))
#rm(col)
```



# 4. Discussion

# 5. References
Caudron-Herger, M., Wassmer, E., Nasa, I., Schultz, A.-S., Seiler, J., Kettenbach, A.N., and Diederichs, S. (2020). Identification, quantification and bioinformatic analysis of RNA-dependent proteins by RNase treatment and density gradient ultracentrifugation using R-DeeP. Nature Protocols *15*, 1338-1370.

# 6. Appendix

shifting behavior PCA

```{r Appendix PCA, echo=FALSE}
# shifiting behavior PCA all sel. criteria
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# Plot, der die Datenpunkte je nach Kategorisierung in "left", "right" und "no" shift einfärbt 
col = rep(NA, nrow(Sel_Crit))

col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"


plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Shifting Behavior with all Selection Criteria", xlab = "PC1", ylab = "PC2")
legend("bottomright", legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))


# shifitng behavior 4 sel. criteria

pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

#  Plot, der die Datenpunkte je nach Kategorisierung in "left", "right" und "no" shift einfärbt 
col = rep(NA, nrow(Sel_Crit))
col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Shifting Behavior with Optimal Selection Criteria", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))
```


Point Density
```{r Appendix Point Density, echo=FALSE, out.width="50%"}

# shifiting behavior PCA all sel. criteria
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

#  Plot, der die Dichte der Punkteverteilung im Plot durch Farben anzeigt ("rot" = sehr dicht beieinander; "blau" = nicht dicht beieinander)

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = densCols(pca$x[, 1], pca$x[, 2], colramp = colorRampPalette(c("blue", "cyan", "green", "yellow", "orange", "red"))), main = "Point Density", xlab = "PC1", ylab = "PC2")
abline(h = 0, lty =3, col = "grey")
abline(v = 0, lty = 3, col = "grey")

# shifitng behavior 4 sel. criteria
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

#  Plot, der die Dichte der Punkteverteilung im Plot durch Farben anzeigt ("rot" = sehr dicht beieinander; "blau" = nicht dicht beieinander)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = densCols(pca$x[, 1], pca$x[, 2], colramp = colorRampPalette(c("blue", "cyan", "green", "yellow", "orange", "red"))), main = "Point Density", xlab = "PC1", ylab = "PC2")
abline(h = 0, lty =3, col = "grey")
abline(v = 0, lty = 3, col = "grey")
```

Elbow Plot
```{r Appendix Elbow Plot, echo=FALSE, out.width="50%"}
# Vergleich mit kmeans clustering
# Elbow plot
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])
plot(1:5, c(kmeans(pca$x[,1:2], 1, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 2, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 3, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 4, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 5, iter.max = 10, nstart = 1)$tot.withinss), type = "b", pch = 19, main = "Elbow Method", xlab = "Number of cluster", ylab = "Total within-cluster sum of squares")
```


