---
title: "Proteome-wide Screen for RNA-dependent Proteins in HeLa Cells Synchronized
  in Interphase"
author: "Hannah Brehm, Johann Blakytny, Kira Hoffmann, Viktor Bonin"
date: "17.07.2023"
output:
  pdf_document: default
  word_document: default
mainfont: Inter
header-includes:
- \usepackage[default]{inter}
- \usepackage[T1]{fontenc}
subtitle: Data Analysis Project 2023
geometry: "left=1cm,right=1cm,top=1cm,bottom=2cm"
fontsize: 11pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, dev="cairo_pdf")
load("Environment.RData")
load("Table_HS_Non_RBP.RData")
# Environment clearen und dann Neues hinzufügen, mit allen nötigen Dataframes für die Graphen
```

***
# Abstract

***
\newpage

\newpage

# 1. Introduction
RNA and its interacting proteins are relevant for essential cellular activity. Especially in posttranscriptional processes, RNA-binding proteins (RBPs) mediate the regulation of posttranscriptional modification, transport through the cytoplasm, translation, and stability of the RNA template. Different RNA-binding motifs have been characterized so far allowing the linkage of proteins to ribonucleic acid (Burd and Dreyfuss, 1994). The structure of most RNA-binding domains is highly conserved; nevertheless, many RBPs bind with high specificity and affinity to distinct RNAs (Lunde *et al.*, 2007). As RBPs are crucial for certain housekeeping mechanisms, mutations or other alterations in human RBPs can have pathological effects (e.g. alterations in the expression of the *zinc finger protein SNAI1* are associated with cancer metastasis) (Gebauer *et al.*, 2021).

There are multiple classifications for interactions between proteins and RNA. RBPs can be characterized in a binary system of being “specific” or “nonspecific” where specific RBPs interact with defined RNA motifs and nonspecific RBPs bind to RNA with an absence of definite motifs (Jankowsky and Harris, 2015). Further differentiation can lead to RBP classes defined by specific RNA-binding domains such as zinc-finger domains or RNA recognition motifs. Additionally, the targets of RBPs can be considered for creating subgroups. Thus, for instance mRNA‑binding or tRNA‑binding RBPs are classified (Gerstberger *et al.*, 2014).

Furthermore, RBPs can be classified as a subcategory of RNA-interacting proteins themselves. The concept of RNA-dependency combines RBPs with proteins which are interacting indirectly with RNA. The latter can also be called RBP-interacting proteins. Thus, RNA-dependent proteins (RDPs) allow for a broader comprehension of the RNA interactome (Caudron-Herger *et al.*, 2020).

Various methods have been applied to identify RNA recognition elements so far, for example crosslinking and immunoprecipitation followed by sequencing (CLIP-seq) (Gerstberger *et al.*, 2014; 2013). This enables identification of RNAs bound to proteins. Detecting the proteins interacting with RNA requires other methods such as comprehensive identification of RBPs by mass spectrometry (CHIRP-MS) (Licatalosi *et al.*, 2020). Introducing the method R-DeeP, Caudron-Herger *et al.* promise a “proteome-wide, unbiased, and enrichment-free screen” that is solely based on disrupting the RNA-protein and RNA-protein-protein interaction (Caudron-Herger *et al.*, 2020; 2019). Through R-DeeP, we aim to identify more human RBPs and RBP-interacting proteins in this project.

# 2. Material and Methods

## 2.1 Referenced Data
The protocol for an R-DeeP-Screen was performed on HeLa cells synchronized in interphase (Caudron-Herger *et al.*, 2020) and the results (protein amount per fraction) were stored in the dataframe *RDeep_HeLa_Interphase*.

## 2.2 Data Cleanup
The original dataset *RDeep_HeLa_Interphase* was split into two separate data frames containing the values for all RNase fractions and Control fractions respectively. These dataframes were named *RNase_RDeep* and *Ctrl_RDeep* respectively. The following steps were performed on both dataframes.

### 2.2.1 NA Values and Zero Rows
All rows containing only zeros, of which there were five, were deleted from the dataframes. No NA values were found.

### 2.2.2 Pearson Correlation
To test the reproducibility of the dataframe the pearson correlation was used. In seven cases one of the three replicates contained only zeros. These values were replaced in with NA values as determining the pearson correlation with these replicates would have been impossible. In five rows, two out of the three replicates contained only zeros. These genes were removed completely from the dataframes.

The pearson correlation $r$ was computed via the following formula using the sample size $N$, individual sample points $x_i$ and $y_i$, sample means $\bar{x}$ and $\bar{y}$ and standard deviations $s_x$ and $s_y$: \[r = \frac{1}{N-1} \sum_{i = 1}^{N}{\frac{x_i - \bar{x}}{s_x} \frac{y_i - \bar{y}}{s_y}}\]

For each gene and condition this resulted in three correlation coefficients with a determined threshold of over or equal to 0.95. The genes for which all three correlation coefficients fell below that threshold were removed from both dataframes. This applied to 1335 genes. If two out of three correlation coefficients were under 0.95 the replicate associated with both coefficients was replaced with NA. This was the case for 2594 replicates. Lastly, if one out of three correlation coefficients was below the determined threshold the replicate with the lower value in the other associated correlation coefficient was replaced with NA. This method was performed on 2285 replicates.

### 2.2.3 Mean of Replicates
After testing for reproducibility and deleting unreliable values, the arithmetic mean was calculated for all triplicates and used for further analysis.


## 2.3 Smoothing and Determination of Maxima

### 2.3.1 Smoothing the Data
To determine the global and local maxima of the dataset, the dataframes *Ctrl_Mean* and *RNase_Mean* were smoothed separately. Otherwise, the determination would be influenced by outliers and wrong peaks.  

Smoothing was achieved by changing the value of each fraction to the respective mean value of its defined neighborhood of 3 with the following formula (applies to all fractions between 2 and 24): \[y = \frac{f(x-1)+f(x)+f(x-1)}{3}\]    
*$x$: fraction position ($2  \leq  x  \leq  24$);* $\quad$ *$f(x)$: mass spectrometry value at fraction position $x$;* $\quad$ *$y$: smoothed value for fraction position $x$*  
  
For fraction position 1 and 25, the mean of fraction 1 and 2 and 24 and 25 respectively were used instead.

### 2.3.2 Normalization of Smoothed data
In order to be able to compare the different protein amounts, the smoothed dataframes were normalized to 100. This means that the sum of the mass spectrometry data in the different fractions for one protein adds up to 100: \[y = \frac{f(x)}{\sum_{x=1}^{25}f(x)} *100\]     
*$x$: fraction position ($1 \leq x \leq 25$);* $\quad$ *$f(x)$: mass spectrometry value at fraction position $x$;* $\quad$ *$y$: normalized value at fraction position $x$* The same procedure was then applied to the standard deviation.

### 2.3.3 Determination of Maxima
If a protein is an RNA-dependent protein, the maximum amount of protein should be situated in a different fraction in the RNase sample compared to the Control sample. To determine for which proteins this is the case, the global and local maxima of the mass spectrometry data was determined.  
  
#### 2.3.3.1 Global Maxima
The global maximum for the smoothed and normalized dataframes were determined by identifying the fraction of the largest mass spectrometry value in each dataframe. For proteins that had 2 or 3 fractions with the same value, the mean fraction position was calculated.  
  
#### 2.3.3.2 Local Maxima
The local maxima for the smoothed and normalized dataframes were determined by comparing the protein amount of each fraction position x to the protein amount in the fractions in a neighborhood of $n = 2$. If the protein amount in that fraction is greater or equal to its neighborhood, it was defined as a local maximum. For the fraction positions 2 and 24, the protein amounts had to be greater than or equal to the protein amounts in the fractions 1, 3 and 4 and fractions 22, 23, 25 respectively, and for the fraction positions 1 and 25, they had to be greater than or equal to fractions 2 and 3 and fractions 23 and 24 respectively. For proteins that had 2 or 3 fractions with the same mass spectrometry value, the mean fraction position was calculated. To distinguish local from global peaks, all global peaks were subtracted from the local peaks dataframe.  

## 2.4 Gaussian Fitting
A Gaussian curve was fitted to the global peak and the local peak with the highest protein amount of each gene in the Control and RNase samples. A Gaussian curve can be described using the height $h$, standard deviation $\sigma$ and mean $\mu$ as: \[f(x) = \frac {h} {\sqrt{2\pi} \cdot \sigma } \cdot e^{-\frac {1} {2} (\frac {x - \mu} {\sigma})^{2}}\]. These parameters were first estimated and then optimized. $\mu$ was estimated as the fraction position of the global and largest local peak, $\sigma$ and $h$ were estimated as follows: \[\sigma =\frac{HWHM}{\sqrt{2 \cdot ln(2)}};\qquad h = \frac{MPA}{sd \cdot \sqrt{2\pi}}\qquad\] *HWHM: half width at half maximum; MPA: maximum protein amount*. These estimated values were optimized by minimizing the sum of squares of the differences between protein amount values of the Gaussian curve $G$ and the smoothed and normalized protein distribution $p$ ($min(\sum(G-p)^2))$. This was used to calculate the protein amount under the Gaussian curve and the overlap of the Gaussian curves between the control and the RNase samples. 

## 2.5 Selection Criteria for Identification of RNA-Dependent Proteins
To determine the optimal selection criteria for an RNA-dependent protein, multiple parameters were compiled and applied to a principle component analysis. The best parameters were subsequently used to select between RDPs, non-RDPs and partial RDPs. 

### 2.5.1 Defining Selection Criteria
Following parameters were compiled to determine the optimal selection criteria for defining RNA-dependent proteins:

The *absolute peak shift and the percentage of the peak shift* 
between the Ctrl and RNase global peaks, 
between the global and main local peak of Ctrl,
and between the global and main local peak of RNase,   

the *absolute change and percentage of change* 
in the *standard deviation* between Ctrl and RNase, 
in the *global peak height* between Ctrl and RNase, 
and between the the *protein amount* under the gaussian curves of the Ctrl and RNase peaks,  

the *absolute protein amount and the percentage of protein amount*
that is lost under the global peak of Ctrl after RNase treatment,
and that is gained under the globak peak of RNase after RNase treatment,  

the *absolute differences and the percentage of the differences in the protein amounts*
of the Ctrl and RNase samples under the main local Ctrl peak,  

the *percentage of overlap*
between the gaussian curves of the Ctrl and RNase,
between the gaussian curves of the main local peak and global peak of Ctrl,
between the gaussian curves of the main local peak and global peak of RNase,
between the gaussian curves of the main local peaks of Ctrl and RNase.  

A *shift* is a character variable that states whether a protein is *left*, *right*, *non* shifting or *precipitated* and is defined as following:
$\Delta\mu = \mu(Ctrl)-\mu(RNase)> +1$: right shift; $\Delta\mu = \mu(Ctrl)-\mu(RNase)< -1$: left shift; $-1 \leq\Delta\mu = \mu(Ctrl)-\mu(RNase)\leq +1$: no shift;$\mu(Ctrl)>24 \lor \mu(RNase)>24$: precipitated  
  
### 2.5.2 Principal Componant Analysis
By reducing the dimensions and applying a principle component analysis to the percentage values of all selection criteria, the optimal parameters to select for RNA-dependent proteins were examined. Only the variables calculated in percentages were used for the PCA for better comparison and the variables regarding main local peaks only serve at determining partially shifting proteins and were therefore not included in the principle component analysis. The selection criteria that separate the points the most in the plot of the first two principal components were chosen for further analysis.  

### 2.5.3 Application of Selection Criteria  
Based on the PCA, four parameters were defined as most important for separating shifting from non-shifting proteins. Following thresholds for the four parameters were furthermore set for the classification of an RNA-dependent protein (RDP):

  1. Global peak shift of more than **1 fraction**
  2. Protein loss under Ctrl global peak of more than **20 %** after RNase treatment
  3. Protein gain under RNase global peak of more than **20 %** after RNase treatment
  4. Overlap of the Gaussian curves of less than **75 %**
  
Furthermore, *partially* RNA-dependent proteins were defined as proteins that satisfy the first and fourth criterion and either the second or third criterion for RNA dependence. More *partially* RNA-dependent proteins were identified using the following criteria: 

  1. Fraction shift between global and main local peak positions of more than **1 fraction**
  2. Overlap between the gaussian curves of global and main local peaks of less than **75 %**
  3. Overlap between the gaussian curves of the local peaks of less than **75 %**
  4. Protein gain under main local peak in relation to protein distribution of other sample under the same peak of more than **20 %**
  5. Protein amount at main local peak of more than **8**
  6. Previous categorization as **"non RDP"**


## 2.6 Further Analysis

### 2.6.1 Comparison with the RBP2GO Database    
To evaluate the accuracy of the performed analysis, the identified RDPs were compared with their respective RDP-categorization in the RBP2GO database. 


#### 2.6.2.1 Direct Comparison  
To further examine the relation between our RDP identification method and the RBP2GO classification, we plotted both RBP2Go-RDPs and -non-RDPs in the biplot of the first two principal components used in the described analysis.

#### 2.6.2.2 Comparison with RDP2GO-score  
The RDPs identified in the performed analysis were then further compared to their respective RDP2GO score.


#### 2.6.2.3 Cluster Comparison with t-Test  
By calculating the **mean RBP2GO-score** for each cluster identified by applying the optimal selection criteria, the RNA-dependence of a cluster (non-/partial/RDP) was estimated. Using a two-sided Welch t-test, the significance of the differences between the mean RBP2GO-score values were calculated. The H0 and H1 hypotheses were defined as following: H0: The mean values are not significantly different from each other, H1: The mean values are significantly different from each other. The false positive rate was set at $p=0,05$. 

### 2.6.2.4 Barplot with all identified RDPs
Finally, a barplot was created to compare the overlap between all identified RDPs via the performed analysis and all RDPs classified as such in the RBP2GO database.

### 2.6.3 Linear Regression    
In order to apply the obtained data on RDPs to biological questions, a linear regression was performed to evaluate how well of a predictor **binding affinity** is to **binding specificity**. Binding affinity is defined as the difference in protein amount between the control and RNase samples at the fraction position of the control global peak and binding specificity is defined as the reciprocal value of the full width at half maximum of the Gaussian curve fitted to the control global peak.


# 3. Results

## 3.1 Results of Data Cleanup, Localization of Maxima and Gaussian Fitting
After performing all data cleanup steps, the original dataset *RDeep_HeLa_Interphase* was reduced from 7086 proteins to 5990 Proteins. Local and global maxima were determined and the Gaussian curve fitted to the peaks. As can be observed in the plots of "CTCF_HUMAN" below, the smoothing and normalization steps as well as the Gaussian Fitting applied to the dataset were successful.

```{r smoothed and normalized, echo=FALSE, out.width = "33%"}

# hier muss ich es noch irgendwie hinbekommen, eine Bildcaption für beide Bilder nebeneinander zu erzeugen...


### not smoothed and normalized
Gene_Plotter("CTCF_HUMAN", Gauss =F, conf =F, Type= "Raw", grid=F, Gbl.Max=F, Loc.Max=F, Legend=F)

### smoothed
Gene_Plotter("CTCF_HUMAN", Gauss=F, conf = F, Type="Smooth", grid=F, Gbl.Max=F, Loc.Max=F, Legend=F)

### smoothed and normalized
Gene_Plotter("CTCF_HUMAN", Gauss=F, conf=F, Type="Smooth and Norm", grid=F, Gbl.Max=F, Loc.Max=F, Legend=T, Leg.Pos = c(0.05, 0))

```
\footnotesize  
**Figure 1: Data Cleanup.** The protein distributions for the gene *CTCF_HUMAN* were smoothed and then normalized.\normalsize 
  

```{r maxima and Gaussian fit, echo=FALSE, out.width = "65%"}
### Gaussian fitted
Gene_Plotter("CTCF_HUMAN", grid =F, Leg.Pos = c(0.05, 0))

```
<br>  
\footnotesize
**Figure 2: Local and global Maxima and Gaussian Fitting.** Local and global maxima of the protein *CTCF_HUMAN* together with fitted Gaussian curves.
\normalsize 

## 3.2 Shifting behavior
In *Fig.*, the shifting behavior is represented by plotting the global peak positions of the Control against those of the RNase samples. Non-shifting proteins lie an a straight line through the origin with a slope of 1, signifying equal positions of both global peaks. Left-shifting proteins lie below this line, right-shifting proteins lie above. Precipitated proteins lie close to the right as well as to the top edge. Most proteins are non-shifting (5153 proteins). The largest group of shifting proteins are left-shifting (782 proteins).

```{r shifting behavior, echo=FALSE, out.width = "65%"}

# peak positions und Einfärben nach "left", "right", "precipitated" und "no" shifting

col = rep(NA, nrow(Ctrl_RDeep))
col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"
par(mar = c(4,5,5,9.5), xpd = T)
plot(Ctrl_Gauss_Fit[, 1], RNase_Gauss_Fit[, 1], pch = 16, col = col, main = "Shifting Behavior", xlab = "Ctrl Gbl Peak Position", ylab = "RNase Gbl Peak Position")
legend("topright", inset = c(-0.47, 0), legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))

```
<br>  
\footnotesize  
**Figure 3: Shifting Behavior.** All analyzed proteins were classified into left, right and no shifting and precipitated using the criteria mentioned above. They were plotted using the global peak positions of the control and RNase samples.\normalsize  

## 3.3 Results of PCA
In *Fig.* the PCA was applied to all selection criteria and the first and second principle component were plotted against each other. The different shifting behaviors of the proteins are shown by using different colors. Left shifting proteins (blue), the largest shifting group, spread along the following four selection criteria: delta_Glb_mu_%, Ctrl_Gbl_prt_porp_% and RNase_Gbl_prt_prop_% and negative Gbl_overlap_%. Therefore, they were defined as the optimal selection criteria. To illustrate this, *Fig.* shows the first and second principle component plotted against each other when PCA is performed solely of the optimal selection criteria. This shows that shifting proteins spread in the direction of delta_Glb_mu_%, Ctrl_Gbl_prt_porp_% and RNase_Gbl_prt_prop_%, whereas non-shifting proteins spread in the direction of the delta_Glb_mu_%. Since delta_Gbl_mu_% is the longest vector, it has the largest influence on the shifting behavior.

```{r Principal components, echo=FALSE, out.width="50%"}

# PCA applied to all precentage selection criteria
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

library(ggplot2)
library(factoextra)

fviz_pca_biplot(pca, axes = c(1,2) , label = "var", col.var = "black", repel = T, col.ind = Sel_Crit[,25], pointshape =16, pointsize =1.5, palette = c("blue", "gray", "orange", "red"))

# PCA applied to following 4 selection criteria: delta_Gbl_mu_%**, **Ctrl_Gbl_prt_prop_%**, **RNase_Gbl_prt_prop_%** and **Gbl_overlap_%
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])
library(ggplot2)
library(factoextra)

fviz_pca_biplot(pca, axes = c(1,2) , label = "var", col.var = "black", repel = T, col.ind = Sel_Crit[,25], pointshape=16, pointsize=1.5, palette = c("blue", "gray", "orange", "red"))

```
\footnotesize  
**Figure 4: PCA Biplots.** Sample Text.\normalsize 

## 3.4 Application of Selection Criteria and Determination of RDPs
All proteins are plotted in a biplot of the first and second principle components and colored depending on the classification based on the optimal selection criteria *(Fig. 5 left plot)* Two main clusters are formed, one containing RDPs (blue) and one containing non-RDPs and partial RDPs (gray and orange). As a result of the optimal selection criteria 539 proteins are classified as RDPs (blue), 274 are classified as partial RDPs (orange) and 5177 are classified as non-RDPs (gray).



```{r, echo=F}
#Include locals too & show how including these righteously expands the number of RBPs
#Example: HNRH3_HUMAN, Heterogeneous nuclear ribonucleoprotein H3, RBP2GO score of 84,8, partial shifter
#and SRSF9_HUMAN, Serine/arginine-rich splicing factor 9, RBP2Go score 71.0
```

## 3.5 Comparison with the RBP2GO Database
To determine the effectiveness of our method, the proteins classified as RDPs in our analysis were compared to the proteins classified as RDPs in the RDP2GO database. 

Firstly, both RBP2GO-RDPs and -non-RDPs were plotted in the biplot of the first two principal components used in our analysis. As depicted in *Fig.*, the RBP2GO-classified RDPs distribute homogeneously across the two clusters with no clear observable trend. 

```{r comparison with RBP2GO Database, echo =F, out.width="50%"}

#n für die 4 ausgewählten Selektionskriterien
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

col = rep(NA, nrow(Sel_Crit))
col[which(Sel_Crit[, 26] == "yes")] = "blue"
col[which(Sel_Crit[, 26] == "partial")] = "orange"
col[which(Sel_Crit[, 26] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Our RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("RDP (", length(which(Sel_Crit[, 26] == "yes")), ")", sep =""), paste("partial RDP (", length(which(Sel_Crit[, 26] == "partial")), ")", sep =""), paste("non RDP (", length(which(Sel_Crit[, 26] == "no")), ")", sep ="")), pch = 16, col = c("blue","orange", "grey"))

col = rep(NA, nrow(Sel_Crit))
col[which(rownames(Sel_Crit) %in% rownames(Table_HS_RBP))] = "blue"
col[which(rownames(Sel_Crit) %in% rownames(Table_HS_Non_RBP))] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RBP2GO RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("RDP (", length(which(rownames(Sel_Crit) %in% rownames(Table_HS_RBP))), ")", sep =""), paste("non RDP (", length(which(rownames(Sel_Crit) %in% rownames(Table_HS_Non_RBP))), ")", sep ="")), pch = 16, col = c("blue", "grey"))

rm(pca, col)

```
\footnotesize  
**Figure 5: Identification of RDPs and Comparison to RBP2GO.** Sample Text.\normalsize

## 3.6 Cluster Comparison with RBP2GO Score and T-test
To determine the significance of our clusters, the average RBP2GO score of these clusters was compared with a T-test. The average RBP2GO score of our RDPs is $21.5$ with a standard deviation of $19.9$, the average score of our partial RDPs is $13.6$ with a standard deviation of $15.6$ and the average score of our non-RDPs is $6.6$ with a standard deviation of $9.1$. For the comparison of the different clusters following p-values are calculated: RDP and non-RDP cluster:  p-value of $8.5*10^{-54}$, RDP and partial RDP cluster: p-value of $8.2*10^{-10}$, partial RDP and non RDP: p-value of $2.0*10^{-12}$. All clusters have significantly different p-values since each p-value is distinctly smaller than the False Positive Rate of $p=0.05$. 

=>Was ist mit den Proteinen mit hohem RBP2GO? Sind die wenigstens alle "richtig" klassifiziert?

## 3.7 Bar Plot
Comparing the RDPs identified via our presented analysis with the RDPs classified as such in the RBP2GO database, 631 proteins were identified as RDPs in both analyses, 2946 proteins were listed as RDPs in the database but were not identified as RDPs in our performed analysis, and 182 proteins which we determined as RDPs are not classified as such on the RBP2GO database (see *Fig.*).
```{r Bar plot RBPs, echo=F, out.width="50%"}
# ---> Barplot 1: Vergleich unserer RDPs mit RBPs von der RBP2GO Datenbank
par(mar=c(1, 3, 3, 8))
barplot(
  matrix(
  c(
    length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_Non_RBP))) +
    length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]))), 
    # RED: which protein are identified as non RDPs in our analysis and in RBP2GO? + which proteins from our dataset are not included in RBP2GO?
  
    length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_RBP))), 
    # ORANGE: which of our non RDPs are in the RBP dataset from RBP2GO?
  
    length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_RBP))),
    # YELLOW: which of our RDPs or partial RDPs are also listed in the RBP2GO databank?
  
    length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_Non_RBP))) + 
    length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]))), 
    # GREEN: which of our RDPs are not listed in the RBP2GO Databank?
  
    rep(NA, 4)),
  nrow = 4),
  axes = F,
  col = c("red", "orange", "yellow", "green"), 
  main = "Comparison with RBP2GO"
)
legend("topright", 
       fill = c("green", "yellow", "orange", "red"),
       inset = c(0.01, 0),
       legend = c( 
        paste("New RDPs (", 
              length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_Non_RBP))) + 
              length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]))), 
              ")", sep = ""),
        
        paste("RDPs (", 
              length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_RBP))), 
              ")", sep = ""), 
        
        paste("RBP2GO-RDPs (", 
              length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_RBP))), 
              ")", sep = ""),
        
        paste("Non RDPs (", 
              length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_Non_RBP))) + 
              length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]))), 
              ")", sep = ""))
)
```
<br>  
\footnotesize  
**Figure 6: Bar Plot.** Sample Text.\normalsize

## 3.8 Linear Regression
Performing a linear regression to test whether or not binding affinity is a good predictor of binding specificity returns a very low coefficient of determination for all analyzed proteins (R² = 0.03) and a rather low coefficient of determination for only the RDPs (R² = 0.29). It is noticeable that the calculated correlation between binding affinity and specificity is positive in both cases, meaning that on average the reciprocal value of the full width at half maximum decreases with an increasing difference between the protein amount of control and RNase samples at the global
control peak position.

```{r Linear Regression, echo=F, out.width="50%"}
RNase_h = sapply(seq(1, nrow(Sel_Crit), 1), function(n) {RNase_Mean_Smooth_Norm100[n, unlist(round(Ctrl_Mean_Gbl_Max))[n]]})

affinity = unlist(Ctrl_Gauss_Fit[, 3]) / (sqrt(2 * pi) * unlist(Ctrl_Gauss_Fit[, 2]))  - RNase_h
specifity = (2 * sqrt(2 * log(2)) * Ctrl_Gauss_Fit[, 2])^(-1)

fit <- lm(specifity ~ affinity)

col = rep(NA, length(Sel_Crit[, 26]))
col[which(Sel_Crit[, 26] == "yes")] = "blue"
col[which(Sel_Crit[, 26] == "partial")] = "orange"
col[which(Sel_Crit[, 26] == "no")] = "grey"
par(mar = c(5, 4, 4, 10.5), xpd = F)
plot(affinity, specifity, col = col, pch = 16, ylab = "Binding Specificity [1/FWHM]", xlab = "Binding Affinity [Normalized Protein Amount]")
curve(fit$coefficients[1] + fit$coefficients[2]*x, add = T, lwd = 3, col = "red")
par(xpd = T)
legend("topright", inset = c(-0.55, 0), legend = c("RDP", "partial RDP", "non RDP", "Regression line", paste("y = ", round(fit$coefficients[2], 3), "x + ", round(fit$coefficients[1], 2), sep = ""), paste("R² = ", round(summary(fit)$r.squared, 2), sep = "")), pch = c(16, 16, 16, NA, NA, NA), col = c("blue", "orange", "grey", "red", NA, NA), lwd = c(NA, NA, NA, 3, NA, NA))

RNase_h = sapply(which(Sel_Crit[, 26] == "yes"), function(n) {RNase_Mean_Smooth_Norm100[n, unlist(round(Ctrl_Mean_Gbl_Max))[n]]})

affinity = Ctrl_Gauss_Fit[which(Sel_Crit[, 26] == "yes"), 3] / (sqrt(2 * pi) * Ctrl_Gauss_Fit[which(Sel_Crit[, 26] == "yes"), 2])  - RNase_h
specifity = (2 * sqrt(2 * log(2)) * Ctrl_Gauss_Fit[which(Sel_Crit[, 26] == "yes"), 2])^(-1)

fit <- lm(specifity ~ affinity)

col = rep(NA, length(which(Sel_Crit[, 26] == "yes")))
col[which(Sel_Crit[which(Sel_Crit[, 26] == "yes"), 26] == "yes")] = "blue"
col[which(Sel_Crit[which(Sel_Crit[, 26] == "yes"), 26] == "partial")] = "orange"
col[which(Sel_Crit[which(Sel_Crit[, 26] == "yes"), 26] == "no")] = "grey"
par(mar = c(5, 4, 4, 10.5), xpd = F)
plot(affinity, specifity, col = col, pch = 16, ylab = "Binding Specificity [1/FWHM]", xlab = "Binding Affinity [Normalized Protein Amount]")
curve(fit$coefficients[1] + fit$coefficients[2]*x, add = T, lwd = 3, col = "red")
par(xpd = T)
legend("topright", inset = c(-0.515, 0), legend = c("RDP", "Regression line", paste("y = ", round(fit$coefficients[2], 2), "x + ", round(fit$coefficients[1], 2), sep = ""), paste("R² = ", round(summary(fit)$r.squared, 2), sep = "")), pch = c(16, NA, NA, NA), col = c("blue", "red", NA, NA), lwd = c(NA, 3, NA, NA))

rm(affinity, RNase_h, fit, col, specifity)
```
\footnotesize  
**Figure 7: Linear Regression.** Sample Text.\normalsize


# 4. Discussion
In conclusion, the protein distributions provided by Caudron-Herger *et al.* for HeLa cells synchronized in interphase were cleaned and normalized. Next, the arithmetic mean for each fraction was calculated (see Fig. X). The averaged protein distributions were smoothed using a three fraction sliding window and normalized (see Fig. X).  
Smoothing was performed to help with global and local peak determination, because the averaged protein distributions were sometimes too jagged for unambiguous peak determination.  
However, this approach has three problems: First, single fraction peaks result, upon smoothing, in multiple peaks in neighboring fractions. This problem was fixed by calculating the mean fraction position for multiple peaks.  
Second, smoothing sometimes caused the fraction position of peaks to change. But this did not have an influence on analysis, because the change in fraction position between raw and smoothed data was very slight (no more than one fraction position).  
Third, smoothing changed the protein amount which sometimes led to global peaks in the raw data becoming local peaks in the smoothed data and *vice versa*. This problem was partly fixed by defining additional selection criteria for partial RDPs using the main local peaks. 
  
Next, the shifting behavior of the proteins was analyzed. There were 782 left-shifting, 41 right-shifting, 5153 non-shifting and 14 precipitated proteins.  
  
PCA helped with determining the optimal selection criteria for an RDP, namely the fraction shift between global peaks, the overlap of the Gaussian curves fitted to the global peaks and the protein amount gained or lost under the global peaks (see Fig. X). Two rough clusters emerged from plotting the first two principal components. Most of the non-shifting proteins were in the left cluster and most of the left-shifting proteins were in the right cluster.  
  
Application of the selection criteria resulted in 539 RDPs, 274 partial RDPs and 5177 non RDPs (see Fig. X). 
These results compare well with the genes’ identified shifting behavior (823 are categorized as either right- or left-shifting compared to 813 identified RDPs and partial RDPs). Note that this does not mean that the individual genes are classified in the same way (compare Fig. (Biplot rocket) with Fig. (“Our RDPs and non RDPs” rocket)). 

The identified RDPs are only partly comparable to the RBP2GO databank (see Fig. “Our RDPs and non RDPs” and “RBP2GO RDPs and non RDPs”).  
The mean for the RBP2GO scores for the identified RDPs was 21.5, compared to 13.6 for partial RDPs and 6.6 for non RDPs. The differences in the mean values between RDPs, partial RDPs and non RDPs are all highly significant based on p-values calculated using a two-sided Welch two-sample t-test. It is noticeable that the p-value of the t-test for the difference between the mean values of the RBP2GO score of RDPs and non RDPs is by most the smallest ($p(RDPs, \ non \ RDPs) = 8.5 \cdot 10^{-54}$ compared to ($p(RDPs, \ partial \ RDPs) = 8.2 \cdot 10^{-10}$ and ($p(non \ RDPs, \ partial \ RDPs) = 2.0 \cdot 10^{-12}$). But these findings are of limited use because the RBP2GO score was calculated very differently from the analysis presented here.  
This is also illustrated by the finding that multivariant linear regression applied to the four optimal selection criteria was not able to accurately predict the RBP2GO score (based on an $R^{2}$ value of 0.17). So, if there is a relation between these selection criteria and the RBP2GO score it is not linear.   

The identification of RDPs was also compared directly to the RBP2GO databank: 2231 genes (37 % of all analyzed genes) which are categorized as non RDPs are also listed as non RBPs in the RBP2GO databank. In addition, 631 (11 %) RDPs are included as RBPs in RBP2GO. Yet, nearly half of the analyzed genes (2946 (49 %)) are categorized as non RDPs, even though RBP2GO lists them as RBPs. Moreover, 182 (3 %) RDPs are listed as non RBPs in the RBP2GO databank.   

The differences between these results and the RBP2GO databank are possible the result of different human cell lineages used, different stages of the cell cycle analyzed and different experimental methods. Notably, the analysis presented here is only for HeLa cells synchronized in interphase, so poor comparability with the RBP2GO databank, which draws its data from many orthogonal experiments, should be expected.   
The results of this analysis show that, besides the experimental methods used, bioinformatic analysis also plays a major role in determining the RNA-dependency of proteins. Multiple independent analysis of the same data could make results more reliable and more comparable with different studies.  
The analysis of RNA-dependency in numerous different ways will undoubtedly have important implications in the diagnosis and therapy of many human diseases.
\newpage

# 5. References
Burd, C.G., and Dreyfuss, G. (1994). Conserved Structures and Diversity of Functions of RNA-Binding Proteins. Science *265*, 615-621.

Caudron-Herger, M., Rusin, S.F., Adamo, M.E., Seiler, J., Schmid, V.K., Barreau, E., Kettenbach, A.N., and Diederichs, S. (2019). R-DeeP: Proteome-wide and Quantitative Identification of RNA-Dependent Proteins by Density Gradient Ultracentrifugation. Molecular Cell *75*, 184-199.e110.

Caudron-Herger, M., Wassmer, E., Nasa, I., Schultz, A.-S., Seiler, J., Kettenbach, A.N., and Diederichs, S. (2020). Identification, quantification and bioinformatic analysis of RNA-dependent proteins by RNase treatment and density gradient ultracentrifugation using R-DeeP. Nature Protocols *15*, 1338-1370.

Gebauer, F., Schwarzl, T., Valcárcel, J., and Hentze, M.W. (2021). RNA-binding proteins in human genetic disease. Nature Reviews Genetics *22*, 185-198.

Gerstberger, S., Hafner, M., and Tuschl, T. (2013). Learning the language of post-transcriptional gene regulation. Genome Biology *14*, 130.

Gerstberger, S., Hafner, M., and Tuschl, T. (2014). A census of human RNA-binding proteins. Nature Reviews Genetics *15*, 829-845.

Jankowsky, E., and Harris, M.E. (2015). Specificity and nonspecificity in RNA–protein interactions. Nature Reviews Molecular Cell Biology *16*, 533-544.

Licatalosi, D.D., Ye, X., and Jankowsky, E. (2020). Approaches for measuring the dynamics of RNA–protein interactions. WIREs RNA *11*, e1565.

Lunde, B.M., Moore, C., and Varani, G. (2007). RNA-binding proteins: modular design for efficient function. Nature Reviews Molecular Cell Biology *8*, 479-490.
\newpage

# 6. Appendix

shifting behavior PCA

```{r Appendix Shifting Behavior, echo=FALSE}
# shifiting behavior PCA all sel. criteria
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# Plot, der die Datenpunkte je nach Kategorisierung in "left", "right" und "no" shift einfärbt 
col = rep(NA, nrow(Sel_Crit))

col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"


plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Shifting Behavior with all Selection Criteria", xlab = "PC1", ylab = "PC2")
legend("bottomright", legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))


# shifitng behavior 4 sel. criteria

pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

#  Plot, der die Datenpunkte je nach Kategorisierung in "left", "right" und "no" shift einfärbt 
col = rep(NA, nrow(Sel_Crit))
col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Shifting Behavior with Optimal Selection Criteria", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))
```


Point Density
```{r Appendix Point Density, echo=FALSE, out.width="50%"}

# shifiting behavior PCA all sel. criteria
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

#  Plot, der die Dichte der Punkteverteilung im Plot durch Farben anzeigt ("rot" = sehr dicht beieinander; "blau" = nicht dicht beieinander)

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = densCols(pca$x[, 1], pca$x[, 2], colramp = colorRampPalette(c("blue", "cyan", "green", "yellow", "orange", "red"))), main = "Point Density", xlab = "PC1", ylab = "PC2")
abline(h = 0, lty =3, col = "grey")
abline(v = 0, lty = 3, col = "grey")

# shifitng behavior 4 sel. criteria
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

#  Plot, der die Dichte der Punkteverteilung im Plot durch Farben anzeigt ("rot" = sehr dicht beieinander; "blau" = nicht dicht beieinander)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = densCols(pca$x[, 1], pca$x[, 2], colramp = colorRampPalette(c("blue", "cyan", "green", "yellow", "orange", "red"))), main = "Point Density", xlab = "PC1", ylab = "PC2")
abline(h = 0, lty =3, col = "grey")
abline(v = 0, lty = 3, col = "grey")
```


```{r Exemplary Graphs, echo=FALSE, out.width="50%"}
#Non RDP:
Gene_Plotter("PZP_HUMAN", cus.main = "PZP_HUMAN (non RDP)")

# RDP:
Gene_Plotter("HNRPL_HUMAN", cus.main = "HNRPL_HUMAN (RDP)")

# partial RDP: 
# categorized based on local peaks
Gene_Plotter("OLA1_HUMAN", cus.main = "OLA1_HUMAN (partial RDP)")
# categrozied based on 2. | 3.
Gene_Plotter("RTCA_HUMAN", cus.main = "RTCA_HUMAN (partial RDP)")

#Sel_Crit[which(max(Sel_Crit[, 27], na.rm = T) == Sel_Crit[, 27]), 25:27]
#Sel_Crit[which(min(Sel_Crit[, 27], na.rm = T) == Sel_Crit[, 27]), 25:27]
```