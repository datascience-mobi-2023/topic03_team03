---
title: "Proteome-wide Screen for RNA-dependent Proteins in HeLa Cells Synchronized
  in Interphase"
header-includes:
   - \usepackage[default]{inter}
   - \usepackage[T1]{fontenc}
mainfont: Inter
author: "Hannah Brehm, Johann Blakytny, Kira Hoffmann, Viktor Bonin"
date: "XX.07.2023"
output:
  pdf_document: default
  word_document: default
subtitle: Data Analysis Project 2023
fontsize: 11pt
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, dev="cairo_pdf")
load("Environment.RData")
load("Table_HS_Non_RBP.RData")
# Environment clearen und dann Neues hinzufügen, mit allen nötigen Dataframes für die Graphen
```

***
# Abstract


***
\newpage

# 1. Introduction

```{r}
#test chunk
```


# 2. Material and Methods

## 2.1 Referenced Data
The protocol for an R-DeeP-Screen was performed on HeLa cells synchronized in interphase (Caudron-Herger *et al.*, 2020). This resulted in the dataframe *RDeep_HeLa_Interphase* in which the protein amounts per fraction were stored.

## 2.2 Data Cleanup
The original dataset *RDeep_HeLa_Interphase* was split into two separate data frames containing the values for all RNase fractions and Control fractions respectively. These dataframes were named *RNase_RDeep* and *Ctrl_RDeep* respectively. The following steps were performed on those two dataframes.

### 2.2.1 NA Values and Zero Rows
All rows containing only zeros, of which there were five, were deleted from the dataframes. No NA values were found.

### 2.2.2 Pearson Correlation
To test the reproducibility of the dataframe the pearson correlation was used. In seven cases one of the three replicates contained only zeros. These values were replaced in with NA values as determining the pearson correlation with these replicates would have been impossible. In five rows, two out of the three replicates contained only zeros. These genes were removed completely from the dataframes.
The pearson correlation $r$ was computed via the following formula using the sample size $N$, individual sample points $x_i$ and $y_i$, sample means $\bar{x}$ and $\bar{y}$ and standard deviations $s_x$ and $s_y$: $r = \frac{1}{N-1} \sum_{i = 1}^{N}{\frac{x_i - \bar{x}}{s_x} \frac{y_i - \bar{y}}{s_y}}$

For each gene and condition this resulted in three correlation coefficients with a determined threshold of over or equal to 0.95. The genes for which all three correlation coefficients fell below that threshold were removed from both dataframes. This applied to 1335 genes. If two out of three correlation coefficients were under 0.95 the replicate associated with both coefficients was replaced with NA. This was the case for 2594 replicates. Lastly, if one out of three correlation coefficients was below the determined threshold the replicate with the lower value in the other associated correlation coefficient was replaced with NA. This method was performed on 2285 replicates.

### 2.2.3 Mean of Replicates
After testing for reproducibility and deleting unreliable values, the arithmetic mean for all triplicates was calculated.


## 2.3 Smoothing and Determination of Maxima

### 2.3.1 Smoothing the Data
To determine the global and local maxima of the dataset, the dataframes *Ctrl_Mean* and *RNase_Mean* were smoothed seperatly.Otherwise the determination would be influenced by outliers and wrong peaks.  
For this the mean value of each fraction was calculated in a defined neighborhood of one with the following formula for all fractions between 2 and 24: $y = \frac{f(x-1)+f(x)+f(x-1)}{3}$    
*$x$: fraction position ($2  \leq  x  \leq  24$);* $\quad$ *$f(x)$: mass spectrometry value at fraction position $x$;* $\quad$ *$y$: smoothed value for fraction position $x$*  
  
For fraction position 1 and 25 the mean of fraction 1 and 2 as well as 24 and 25 were calculated.

### 2.3.2 Normalization of Smoothed data
For comparison of the different protein amounts, the smoothed dataframes had to be normalized to 100. This means, that the sum of the mass spectrometry data in the different fractions for one protein had to add up to 100: $y = \frac{f(x)}{\sum_{x=1}^{25}f(x)} *100$     
*$x$: fraction position ($1 \leq x \leq 25$);* $\quad$ *$f(x)$: mass spectrometry value at fraction position $x$;* $\quad$ *$y$: normalized value at fraction position $x$* In the Following the standerd deviation was calculated.
  

### 2.3.3 Determination of Maxima
If a protein is an RNA-dependent protein, the maximum amount of protein is in a different fraction in the RNase sample compared to the Control sample. To determine for which proteins this is the case, the global and local maxima of the mass spectrometry data was determined.  
  
#### 2.3.3.1 Global Maxima \
The global maximum for the smoothed and normalized dataframes were determined by identifying the fraction of the largest mass spectrometry value in each dataframe. For proteins that had 2 or 3 fractions with the same mass spectrometry value, the mean fraction position was calculated.  

#### 2.3.3.2 Local Maximum \
The local maxima for the smoothed and normalized dataframes were determined by comparing the protein amount of each fraction position x to the protein amount in the fractions in a neighborhood of $n = 2$. If the protein amount in that fraction is greater or equal to its neighborhood it was defined as a local maximum. For the edge cases fraction positions 2 and 25 as well as 1 and 25 the protein amounts had to be greater or equal to the protein amounts in the fractions 1,3 and 4 and fractions 22, 23,25 as well as fractions 2 and 3 and fractions 23 and 24. For proteins that had 2 or 3 fractions with the same mass spectrometry value, the mean fraction position was calculated. To distinguish the local from the global peaks the global peaks were subtracted from the local peaks.  


## 2.4 Gaussian Fitting
A Gaussian curve was fitted to the global peak and local peak with the highest protein amount of each gene in the control and RNase samples. A Gaussian curve can be describe using the height $h$, standard deviation $\sigma$ and mean $\mu$ as: $f(x) = \frac {h} {\sqrt{2\pi} \cdot \sigma } \cdot e^{-\frac {1} {2} (\frac {x - \mu} {\sigma})^{2}}$. These parameters were first estimated and then optimized. $\mu$ was estimated as the fraction position of the global and largest local peak, $\sigma$ and $h$ were estimated as follows: $\sigma =\frac{HWHM}{\sqrt{2 \cdot ln(2)}};\qquad h = \frac{MPA}{sd \cdot \sqrt{2\pi}}\qquad$ *HWHM: half width at half maximum; MPA: maximum protein amount*. These estimated values were optimized by minimizing the sum of squares of the differences between protein amount values of the Gaussian curve $G$ and the smoothed and normalized protein distribution $p$ ($min(\sum(G-p)^2))$. This was used to calculate the protein amount under the Gaussian curve and the overlap of the Gaussian curves for the control and RNase samples. 

## 2.5 Selection Criteria for Identification of RNA-Dependent Proteins
To determine the optimal selection criteria for an RNA-dependent protein multiple parameters were compiled and applied to a principle component analysis.

### 2.5.1 Defining Selection Criteria
Following parameters were compiled to determine the optimal selection criteria for defining RNA-dependent proteins.

The *absolute peak shift and the percentage of the peak shift* 
between the Ctrl and RNase global peaks, 
between the global and main local peak of Ctrl,
and between the global and main local peak of RNase,   

the *absolute change and percentage of change* 
in the *standard deviation* between Ctrl and RNase, 
in the *global peak height* between Ctrl and RNase, 
and between the the *protein amount* under the gaussian curves of the Ctrl and RNase peaks,  

the *absolute protein amount and the percentage of protein amount*
that is lost under the global peak of Ctrl after RNase treatment,
and that is gained under the globak peak of RNase after RNase treatment,  

the *absolute differences and the percentage of the differences in the protein amounts*
of the Ctrl and RNase samples under the main local Ctrl peak,  

the *percentage of overlap*
between the gaussian curves of the Ctrl and RNase,
between the gaussian curves of the main local peak and global peak of Ctrl,
between the gaussian curves of the main local peak and global peak of RNase,
between the gaussian curves of the main local peaks of Ctrl and RNase.  

A *shift* is a character variable that states whether a protein is *left*, *right*, *non* shifting or *precipitated* and is defined as following:
$\Delta\mu = \mu(Ctrl)-\mu(RNase)> +1$: right shift; $\Delta\mu = \mu(Ctrl)-\mu(RNase)< -1$: left shift; $-1 \leq\Delta\mu = \mu(Ctrl)-\mu(RNase)\leq +1$: no shift;$\mu(Ctrl)>24 \lor \mu(RNase)>24$: precipitated  

  
### 2.5.2 Principal Componant Analysis
Applying a principle component analysis to the percentage values of the selection criteria the optimal parameters for an RNA-dependent protein were examined by reducing the dimensions of the dataframe *Sel_Crit*. Only the variables calculated in percent were used for the PCA for better comparison and the variables regarding main local peaks only serve at determining partially shifting proteins and were therefore not included in the principle component analysis. The selection criteria that separate the points the most in the plot of the first two principal components were chosen for further analysis.   

### 2.5.3 Application of selection criteria  

Based on the PCA four parameters were defined as most important for separating shifting and non shifting proteins. Based on observations and experience we set the following thresholds for an RNA-dependent protein (RDP):

  1. Global peak shift of more than **1 fraction**
  2. Protein loss under Ctrl global peak of more than **20 %** after RNase treatment
  3. Protein gain under RNase global peak of more than **20 %** after RNase treatment
  4. Overlap of the Gaussian curves of less than **75 %**
  
Furthermore, *partially* RNA-dependent proteins were defined as proteins that satisfy the first and fourth criteria and either the second or third criteria for RNA dependence. More *partially* RNA-dependent proteins were identified using the following criteria: 

  1. Fraction shift between global and main local peak positions of more than **1 fraction**
  2. Overlap between the gaussian curves of global and main local peaks of less than **75 %**
  3. Overlap between the gaussian curves of the local peaks of less than **75 %**
  4. Protein gain under main local peak in relation to protein distribution of other sample under the same peak of more than **20 %**
  5. Protein amount at main local peak of more than **8**
  6. Previous categorization as **"non RDP"**


## 2.6 Further Analysis

### 2.6.1 Comparison with the RBP2GO Database    
To evaluate the accuracy of this method, the identified RDPs were compared with the existing RDPs in the RBP2Go Database and a barplot was created. 

#### 2.6.2.1 Direct comparison  
In the direct comparison the categories RDP dependent yes or no were plotted in a biplot.

#### 2.6.2.2 Comparison with RDP2Go-score  
For more accurate results the in this method identified RDPs were compared to the RDP2Go score.

#### 2.6.2.3 Cluster comparison with T-test  
By calculating the **mean RBP2GO-score** for each cluster identified by applying the optimal selection criteria, the RNA-dependence of a cluster was estimated. Using a two-sided t-Test, the significance of the differences between the mean values were calculated.The H0 and H1 hypotheses were defined as following: H0: The mean values are not significantly different from each other, H1: The mean values are significantly different from each other. 

### 2.6.3 Linear Regression    
Linear regression was applied to the loss of protein amount under the Gaussian curve of the global peak for the control sample and the gain of protein amount under the Gaussian curve of the global peak for the RNase sample. This aims at identifying proteins with a partial shift.


# 3. Results
## 3.1 Results of Data Cleanup and Gaussian Fitting
After performing all data cleanup steps, the original dataset *RDeep_HeLa_Interphase* was reduced from 7086 proteins to 5990 Proteins. As can be exemplarily observed in the plots of "CTCF_HUMAN" below, the smoothing steps, normalization steps and the Gaussian Fitting applied to the dataset were successful.

```{r smoothed and normalized, echo=FALSE, out.width = "33%"}

# hier muss ich es noch irgendwie hinbekommen, eine Bildcaption für beide Bilder nebeneinander zu erzeugen...


### not smoothed and normalized
Gene_Plotter("CTCF_HUMAN", Gauss =F, conf =F, Type= "Raw")

### smoothed
Gene_Plotter("CTCF_HUMAN", Gauss=F, conf = F, Type="Smooth")

### smoothed and normalized
Gene_Plotter("CTCF_HUMAN", Gauss=F, conf=F, Type="Smooth and Norm")

### Gaussian fitted
Gene_Plotter("CTCF_HUMAN")
```

## 3.2 Shifting behavior

In *Fig.*, the shifting behavior is represented by plotting the global peak positions of the Control against those of the RNase samples. Non-shifting proteins lie an a straight line through the origin with a slope of 1, signifying equal positions of both global peaks. Left-shifting proteins lie below this line, meaning the global peak of the Control sample is in a higher fraction position than the global peak of the RNase sample. Right-shifting proteins lie above this line, indicating a lower fraction position of the global peak of the Control sample in comparison to the RNase sample. Precipitated proteins are proteins with a global position in the 24th or the 25th fraction. Most proteins are non-shifting (5153 proteins). The largest group of shifting proteins are left-shifting (782 proteins).


```{r shifting behavior, echo=FALSE, out.width="33%"}

# peak positions und Einfärben nach "left", "right", "precipitated" und "no" shifting

col = rep(NA, nrow(Ctrl_RDeep))
col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"

plot(Ctrl_Gauss_Fit[, 1], RNase_Gauss_Fit[, 1], pch = 16, col = col, main = "Shifting Behavior", xlab = "Ctrl Gbl Peak Position", ylab = "RNase Gbl Peak Position")
legend("topleft", legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))

```

## 3.3 Results of PCA
In *Fig.* the PCA was applied to all selection criteria and the first and second principle component were plotted against each other. The different shifting behaviors of the proteins are shown by using different colors. Left shifting proteins (blue) spread along the following four selection criteria: delta_Glb_mu_%, Ctrl_Gbl_prt_porp_% and RNase_Gbl_prt_prop_% and negative Gbl_overlap_%. Therefore, they are defined as optimal selection criteria. To illustrate this, *Fig.* shows the first and second principle component plotted against each other of an analysis of the optimal selection criteria. This shows that shifting proteins spread in the direction of delta_Glb_mu_%, Ctrl_Gbl_prt_porp_% and RNase_Gbl_prt_prop_%, whereas nonshifting proteins spread in the direction of the delta_Glb_mu_%. Since delta_Gbl_mu_% is the longest vector, it has the most influence on the shifting behavior.

```{r Principal components, echo=FALSE, out.width="50%"}

# PCA applied to all precentage selection criteria
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

library(ggplot2)
library(factoextra)

fviz_pca_biplot(pca, axes = c(1,2) , label = "var", col.var = "black", repel = T, col.ind = Sel_Crit[,25], pointshape =16, pointsize =1.5, palette = c("blue", "gray", "orange", "red"))

# PCA applied to following 4 selection criteria: delta_Gbl_mu_%**, **Ctrl_Gbl_prt_prop_%**, **RNase_Gbl_prt_prop_%** and **Gbl_overlap_%
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])
library(ggplot2)
library(factoextra)

fviz_pca_biplot(pca, axes = c(1,2) , label = "var", col.var = "black", repel = T, col.ind = Sel_Crit[,25], pointshape=16, pointsize=1.5, palette = c("blue", "gray", "orange", "red"))

```
## 3.4 Application of selection criteria 

Global % local!!!

(ggf. k means clustering um zu zeigen dass unsere thresholds gut gewählt sind)

## 3.5 Comparison with the RBP2GO Database

Comparing the RDPs identified via our presented analysis with the RDPs classified as such in the RBP2GO database, 631 proteins were identified as RDPs in both analyses, 2946 proteins were listed as RDPs in the database but were not identified as RDPs in our performed analysis, and 182 proteins which we determined as RDPs are not classified as such on the RBP2Go database (see *Fig.*).

```{r Bar plot RBPs, echo=F, out.width="50%"}

# bar plot
par(mar=c(1, 3, 1, 7.5))
barplot(matrix(c(
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]))),
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_RBP))),
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_RBP))),
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]))),
  rep(NA, 4)),
  nrow = 4),
  axes = F,
  col = c("red", "orange", "yellow", "green"), 
  legend.text = c(paste("Non RDPs (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]))), ")", sep = ""), 
                  paste("RDPs (only RBP2GO) (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_RBP))), ")", sep = ""), 
                  paste("RDPs (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_RBP))), ")", sep = ""), 
                  paste("New RDPs (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]))), ")", sep = "")),
  )

```

Next, an analysis was performed on the spread of the proteins classified as RDPs on RBP2GO when plotted on the same PCs as in our analysis. As depicted in *Fig.*, the RBP2GO-classified RDPs distribute homogeneously across the two clusters with no clear observable trend. 

```{r comparison with RBP2Go Database, echo =F, out.width="50%"}

#n für die 4 ausgewählten Selektionskriterien
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

col = rep(NA, nrow(Sel_Crit))
col[which(Sel_Crit[, 26] == "yes")] = "blue"
col[which(Sel_Crit[, 26] == "partial")] = "orange"
col[which(Sel_Crit[, 26] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Our RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("RDP (", length(which(Sel_Crit[, 26] == "yes")), ")", sep =""), paste("partial RDP (", length(which(Sel_Crit[, 26] == "partial")), ")", sep =""), paste("non RDP (", length(which(Sel_Crit[, 26] == "no")), ")", sep ="")), pch = 16, col = c("blue","orange", "grey"))

col = rep(NA, nrow(Sel_Crit))
col[which(rownames(Sel_Crit) %in% rownames(Table_HS_RBP))] = "blue"
col[which(rownames(Sel_Crit) %in% rownames(Table_HS_Non_RBP))] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RBP2GO RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("RDP (", length(which(rownames(Sel_Crit) %in% rownames(Table_HS_RBP))), ")", sep =""), paste("non RDP (", length(which(rownames(Sel_Crit) %in% rownames(Table_HS_Non_RBP))), ")", sep ="")), pch = 16, col = c("blue", "grey"))

rm(pca, col)

```
## 3.6 Cluster Comparison with RBP2GO score and T-test

=>Was ist mit den Proteinen mit hohem RBP2GO? Sind die wenigstens alle "richtig" klassifiziert?

```{r Vergleich unserer Werte mit dem RBP2Go score, echo = F, out.width="50%"}
#Vergleich unserer Werte mit dem RBP2Go score
library(scales)

# ---> Gleiche Berechnungen für die 4 ausgewählten Selektionskriterien
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = alpha("blue", Sel_Crit[, 27]/100), main = "RBP2GO_Score", xlab = "PC1", ylab = "PC2")

rm(pca)


```


## 3.7 Linear Regression

r^2 Wert: 

```{r linear regression, echo=F, out.width="50%"}
# linear regression


```


# 4. Discussion

In conclusion, the protein distributions provided by Caudron-Herger *et al.* for HeLa cells synchronized in interphase were cleaned and normalized. Next, the arithmetic mean for each fraction was calculated (see Fig. X). The averaged protein distributions were smoothed using a three fraction sliding window and normalized (see Fig. X).  
Smoothing was performed to help with global and local peak determination, because the averaged protein distributions were sometimes too jagged for unambiguous peak determination.  
However, this approach has three problems: First, single fraction peaks result, upon smoothing, in multiple peaks in neighboring fractions. This problem was fixed by calculating the mean fraction position for multiple peaks.  
Second, smoothing sometimes caused the fraction position of peaks to change. But this did not have an influence on analysis, because the change in fraction position between raw and smoothed data was very slight (no more than one fraction position).  
Third, smoothing changed the protein amount which sometimes led to global peaks in the raw data becoming local peaks in the smoothed data and *vice versa*. This problem was partly fixed by defining additional selection criteria for partial RDPs using the main local peaks. 
  
Next, the shifting behavior of the proteins was analyzed. There were 782 left-shifting, 41 right-shifting, 5153 non-shifting and 14 precipitated proteins.  
  
PCA helped with determining the optimal selection criteria for an RDP, namely the fraction shift between global peaks, the overlap of the Gaussian curves fitted to the global peaks and the protein amount gained or lost under the global peaks (see Fig. X). Two rough clusters emerged from plotting the first two principal components. Most of the non-shifting proteins were in the left cluster and most of the left-shifting proteins were in the right cluster.  
  
Application of the selection criteria resulted in 539 RDPs, 274 partial RDPs and 5177 non RDPs (see Fig. X). 
These results compare well with the genes’ identified shifting behavior (823 are categorized as either right- or left-shifting compared to 813 identified RDPs and partial RDPs). Note that this does not mean that the individual genes are classified in the same way (compare Fig. (Biplot rocket) with Fig. (“Our RDPs and non RDPs” rocket)). 

The identified RDPs are only partly comparable to the RBP2GO databank (see Fig. “Our RDPs and non RDPs” and “RBP2GO RDPs and non RDPs”).  
The mean for the RBP2GO scores for the identified RDPs was 21.5, compared to 13.6 for partial RDPs and 6.6 for non RDPs. The differences in the mean values between RDPs, partial RDPs and non RDPs are all highly significant based on p-values calculated using a two-sided Welch two-sample t-test. It is noticeable that the p-value of the t-test for the difference between the mean values of the RBP2GO score of RDPs and non RDPs is by most the smallest ($p(RDPs, \ non \ RDPs) = 8.5 \cdot 10^{-54}$ compared to ($p(RDPs, \ partial \ RDPs) = 8.2 \cdot 10^{-10}$ and ($p(non \ RDPs, \ partial \ RDPs) = 2.0 \cdot 10^{-12}$). But these findings are of limited use because the RBP2GO score was calculated very differently from the analysis presented here.  
This is also illustrated by the finding that multivariant linear regression applied to the four optimal selection criteria was not able to accurately predict the RBP2GO score (based on an $R^{2}$ value of 0.17). So, if there is a relation between these selection criteria and the RBP2GO score it is not linear.   

The identification of RDPs was also compared directly to the RBP2GO databank: 2231 genes (37 % of all analyzed genes) which are categorized as non RDPs are also listed as non RBPs in the RBP2GO databank. In addition, 631 (11 %) RDPs are included as RBPs in RBP2GO. Yet, nearly half of the analyzed genes (2946 (49 %)) are categorized as non RDPs, even though RBP2GO lists them as RBPs. Moreover, 182 (3 %) RDPs are listed as non RBPs in the RBP2GO databank.   

The differences between these results and the RBP2GO databank are possible the result of different human cell lineages used, different stages of the cell cycle analyzed and different experimental methods. Notably, the analysis presented here is only for HeLa cells synchronized in interphase, so poor comparability with the RBP2GO databank, which draws its data from many orthogonal experiments, should be expected.   
The results of this analysis show that, besides the experimental methods used, bioinformatic analysis also plays a major role in determining the RNA-dependency of proteins. Multiple independent analysis of the same data could make results more reliable and more comparable with different studies.  
The analysis of RNA-dependency in numerous different ways will undoubtably have important implications in the diagnosis and therapy of many human diseases.

# 5. Appendix

shifting behavior PCA

```{r}
# shifiting behavior PCA all sel. criteria
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# Plot, der die Datenpunkte je nach Kategorisierung in "left", "right" und "no" shift einfärbt 
col = rep(NA, nrow(Sel_Crit))

col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"


plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Shifting Behavior with all Selection Criteria", xlab = "PC1", ylab = "PC2")
legend("bottomright", legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))


# shifitng behavior 4 sel. criteria

pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

#  Plot, der die Datenpunkte je nach Kategorisierung in "left", "right" und "no" shift einfärbt 
col = rep(NA, nrow(Sel_Crit))
col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Shifting Behavior with Optimal Selection Criteria", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))
```


Point Density
```{r Appendix Point Density, echo=FALSE, out.width="50%"}

# shifiting behavior PCA all sel. criteria
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

#  Plot, der die Dichte der Punkteverteilung im Plot durch Farben anzeigt ("rot" = sehr dicht beieinander; "blau" = nicht dicht beieinander)

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = densCols(pca$x[, 1], pca$x[, 2], colramp = colorRampPalette(c("blue", "cyan", "green", "yellow", "orange", "red"))), main = "Point Density", xlab = "PC1", ylab = "PC2")
abline(h = 0, lty =3, col = "grey")
abline(v = 0, lty = 3, col = "grey")

# shifitng behavior 4 sel. criteria
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

#  Plot, der die Dichte der Punkteverteilung im Plot durch Farben anzeigt ("rot" = sehr dicht beieinander; "blau" = nicht dicht beieinander)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = densCols(pca$x[, 1], pca$x[, 2], colramp = colorRampPalette(c("blue", "cyan", "green", "yellow", "orange", "red"))), main = "Point Density", xlab = "PC1", ylab = "PC2")
abline(h = 0, lty =3, col = "grey")
abline(v = 0, lty = 3, col = "grey")
```

Elbow Plot
```{r Appendix Elbow Plot, echo=FALSE, out.width="50%"}
# Vergleich mit kmeans clustering
# Elbow plot
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])
plot(1:5, c(kmeans(pca$x[,1:2], 1, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 2, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 3, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 4, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 5, iter.max = 10, nstart = 1)$tot.withinss), type = "b", pch = 19, main = "Elbow Method", xlab = "Number of cluster", ylab = "Total within-cluster sum of squares")
```

# Comparison with RBP2GO score - kmeans clustering

```{r Vergleich unserer Werte mit dem RBP2Go scores, echo = F, out.width="50%"}
#Vergleich unserer Werte mit dem RBP2Go score
library(scales)

# ---> Gleiche Berechnungen für die 4 ausgewählten Selektionskriterien
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = alpha("blue", Sel_Crit[, 27]/100), main = "RBP2GO_Score", xlab = "PC1", ylab = "PC2")

rm(pca)


## 3.8 Bar plot with weird analysis?

#load("Environment_with_RDP.RData")

#col = rep(NA, nrow(Ctrl_RDeep))
#col[which(Sel_Crit_PCA[, 8] == "left")] = "blue"
#col[which(Sel_Crit_PCA[, 8] == "right")] = "red"
#col[which(Sel_Crit_PCA[, 8] == "precipitated")] = "orange"
#col[which(Sel_Crit_PCA[, 8] == "no")] = "grey"

#plot(Ctrl_Gauss_Fit[, 1], RNase_Gauss_Fit[, 1], pch = 16, col = col, main = "Shifting Behavior", xlab = "Ctrl Gbl Peak Position", ylab = "RNase Gbl Peak Position")
#legend("topleft", legend = c("left", "right", "precipitated", "no"), pch = 16, col = c("blue", "red", "orange", "grey"))
#rm(col)
```

## 3.5 Comparison to k means clustering 

Inkl. overlap of k means with our own selection criteria (Änderungen: 5.3.3, 5.3.4)

```{r comparison to k means clustering, echo =F, out.width="50%"}
# Vergleich mit kmeans Clustering

# Diagramm
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

kmeans = kmeans(pca$x, 2, iter.max = 10, nstart = 1)

col = rep(NA, nrow(Sel_Crit))
col[which(kmeans$cluster == 1)] = "blue"
col[which(kmeans$cluster == 2)] = "red"

par(mar=c(4, 4, 4, 11), xpd=F)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "k-Means Clustering (n = 2)", xlab = "PC1", ylab = "PC2")
par(xpd=T)
legend("topright", 
       inset = c(-0.49,0), 
       legend = c(paste("Cluster 1 (", length(which(kmeans$cluster == 1)), ")", sep = ""), paste("(mu = ", round(mean(Sel_Crit[which(kmeans$cluster == 1), 27], na.rm = T), 2),",", " sd = ", round(sd(Sel_Crit[which(kmeans$cluster == 1), 27], na.rm = T)/sqrt(length(which(kmeans$cluster == 1))), 2), ")", sep = ""), paste("Cluster 2 (", length(which(kmeans$cluster == 2)), ")", sep = ""), paste("(mu = ", round(mean(Sel_Crit[which(kmeans$cluster == 2), 27], na.rm = T), 2),",", " sd = ", round(sd(Sel_Crit[which(kmeans$cluster == 2), 27], na.rm = T)/sqrt(length(which(kmeans$cluster == 2))), 2), ")", sep = "")), pch = 16, col = c("blue", NA, "red", NA, NA, NA))

rm(pca, kmeans, col)

#, "", paste("p(1&2) = ", signif(t.test(Sel_Crit[which(kmeans$cluster == 1), 27], Sel_Crit[which(kmeans$cluster == 2), 27], alternative = "two.sided")$p.value, 3), sep = "")
```