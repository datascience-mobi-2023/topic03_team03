---
title: "Topic 3: Proteome-wide Screen for RNA-dependent Proteins; Subtopic 3: HeLa synchronized in Interphase"
author: "Hannah, Johann, Kira, Viktor"
date: "2023-04-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Topic 3: Proteome-wide Screen for RNA-dependent Proteins

### Subtopic 3: HeLa Cells Synchronized in Interphase

First, we will load the dataset containing the mass spectrometry data from HeLa cells synchronized in interphase:

```{r setup, include=FALSE}
RDeeP_HeLa_Interphase = read.csv("https://www.dropbox.com/s/nm9bgsyg7cv6wu1/RDeeP_HeLa_Interphase.csv?dl=1", header=TRUE, row.names=1, sep = ";")
head(RDeeP_HeLa_Interphase)
```

#### 1. Data Cleanup and Normalization

Are there any missing values in the dataset?

```{r cleanup, echo=FALSE}
sum(which(is.null(RDeeP_HeLa_Interphase)))
```

Are there any rows that only contain zeros?

```{r cleanup, echo=FALSE}
which(rowSums(RDeeP_HeLa_Interphase)==0)
```


##### 1.1 Split Dataset into Control and RNase

We can also split the dataset into two separate datasets that contain the Control and RNase values:

```{r cleanup, include=FALSE}
Ctrl_RDeep = as.data.frame(
                             # Diese Matrix speichern wir noch als Dataframe
  matrix(
  # Aus dem großen Vektor, den wir mit "unlist" erstellt haben (mit 531450 Einträgen), machen wir eine Matrix mit      7086 Zeilen und 75 Spalten
    
    unlist(
    # Da die untere Schleife einen Dataframe erstellt mit 75 Spalten und drei Zeilen (jede Zelle enthält einen           Vektor, der einer Spalte im originalen Dataframe entspricht), müssen wir aus diesem Dataframe einen einzigen         großen Vektor mit allen Proteineinträgen generieren (das macht der Befehl "unlist")
      
      sapply(seq(0,144,6), function(n) {RDeeP_HeLa_Interphase[,c(1,2,3)+c(n,n,n)]})), 
      # Schleife, die alle Spalten der Control Samples aus dem Dataframe "RDeep_HeLa_Interphase" in Dreier-Grüppchen       (jeweils die drei Replikate pro Fraktion) nacheinander auswählt
    
    nrow=7086, ncol=75))

# Hier werden dem neu erstellten Control Dataframe die Zeilen und Spaltennamen des originalen Dataframes zugeordnet (nutzt die gleiche Schleife zum Auswählen der Control Spalten wie oben)
colnames(Ctrl_RDeep) = as.vector(unlist(sapply(seq(0,144,6), function(n) {colnames(RDeeP_HeLa_Interphase[,c(1,2,3)+c(n,n,n)])})))

rownames(Ctrl_RDeep) = rownames(RDeeP_HeLa_Interphase)

# Analoges Vorgehen für RNase wie Control, nur, dass sich die Startposition zum Auswählen verändert
RNase_RDeep = as.data.frame(matrix(unlist(sapply(seq(0,144,6), function(n) {RDeeP_HeLa_Interphase[,c(4,5,6)+c(n,n,n)]})), nrow=7086, ncol=75))

colnames(RNase_RDeep) = as.vector(unlist(sapply(seq(0,144,6), function(n) {colnames(RDeeP_HeLa_Interphase[,c(4,5,6)+c(n,n,n)])})))

rownames(RNase_RDeep) = rownames(RDeeP_HeLa_Interphase)
```


##### 1.2 NA Values and Zero Rows

```{r cleanup, include=FALSE}
## Überprüfen welche Reihen in den Datasets nur Nullen enthalten

which(rowSums(Ctrl_RDeep)==0)
which(rowSums(RNase_RDeep)==0)

## Löschen der Nullreihen im Controldataset

Ctrl_RDeep <- Ctrl_RDeep[!(rownames(Ctrl_RDeep)%in% c("FHOD3_HUMAN","P210L_HUMAN","PKD1_HUMAN","TGM7_HUMAN","KIF1A_HUMAN")),]

##Löschen der Nullreihen im RNase-Dataset

RNase_RDeep <- RNase_RDeep[!(rownames(RNase_RDeep) %in% c("FHOD3_HUMAN","P210L_HUMAN","PKD1_HUMAN","TGM7_HUMAN", "KIF1A_HUMAN")),]
```


##### 1.3 Pearson Correlation (Reproducibility)

We will now test the reproducibility of the dataset: to do this we will calculate the pearson correlation between the 3 replicates. For each gene and condition this results in 3 correlation coefficients (cor(Rep1, Rep2), cor(Rep2, Rep3), cor(Rep1, Rep3)). The threshold for reproducibility is a correlation coefficient over or equal to 0.95.

If one replicate only consists of zeros, the correlation can not be calculated (sd = 0; 1/sd = NaN). Because these replicates contain very little information, we will replace these replicates with the value NA in our dataframes **Ctrl_RDeep** and **RNase_RDeep** (this applies to 7 replicates).
If two replicates of one gene and condition only contain only zeros, we will remove the entire gene from the dataframes (no proficient analysis with only one replicate for a condition) (this applies to 5 genes).

If all three correlation coefficients for a gene and condition are under 0.95, the entire gene will be removed from the dataframes(this applies to 1335 genes).
If two correlation coefficients are under 0.95, the associated replicate will be replaced with NA values (e.g. if cor(Rep1, Rep2) and cor(Rep2, Rep3) are under 0.95, Rep2 will be replaced) (this applies to 2594 replicates).
If only one correlation coefficient is under 0.95, the replicate is replaced for which the remaining correlation is lower (e.g. if cor(Rep1, Rep2) is under 0.95 and cor(Rep2, Rep3) is bigger than cor(Rep1, Rep3) (both are over 0.95) Rep1 is replaced) (this applies to 2285 replicates). 

```{r cleanup, include=FALSE}
# ---> Die einzelnen Replikate für jedes Gen in der Ctrl-condition werden separat ausgewählt und abgespeichert
Rep1_Ctrl = Ctrl_RDeep[, c(sapply(seq(0,72,3), function(k) {1 + k}))]
Rep2_Ctrl = Ctrl_RDeep[, c(sapply(seq(0,72,3), function(k) {2 + k}))]
Rep3_Ctrl = Ctrl_RDeep[, c(sapply(seq(0,72,3), function(k) {3 + k}))]

# ---> es wird die paarweise Korrelation zwischen den einzelnen Replikaten für jedes Gen berechnet und in einem neuen Dataframe (Ctrl_Cor) abgespeichert 
Ctrl_Cor = as.data.frame(cbind(
      sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {cor(unlist(Rep1_Ctrl[k,]), unlist(Rep2_Ctrl[k,]), method = "pearson")}),
      sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {cor(unlist(Rep2_Ctrl[k,]), unlist(Rep3_Ctrl[k,]), method = "pearson")}),
      sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {cor(unlist(Rep1_Ctrl[k,]), unlist(Rep3_Ctrl[k,]), method = "pearson")})
      ))

# --> Benennung der Reihen und Spalten von "Ctrl_Cor"
rownames(Ctrl_Cor) = rownames(Ctrl_RDeep)
colnames(Ctrl_Cor) = c("cor(Rep1, Rep2)", "cor(Rep2, Rep3)", "cor(Rep1, Rep3)")


# ---> gleiche Berechnungen für die RNase-condition
Rep1_RNase = RNase_RDeep[, c(sapply(seq(0,72,3), function(k) {1 + k}))]
Rep2_RNase = RNase_RDeep[, c(sapply(seq(0,72,3), function(k) {2 + k}))]
Rep3_RNase = RNase_RDeep[, c(sapply(seq(0,72,3), function(k) {3 + k}))]

RNase_Cor = as.data.frame(cbind(
      sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {cor(unlist(Rep1_RNase[k,]), unlist(Rep2_RNase[k,]), method = "pearson")}),
      sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {cor(unlist(Rep2_RNase[k,]), unlist(Rep3_RNase[k,]), method = "pearson")}),
      sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {cor(unlist(Rep1_RNase[k,]), unlist(Rep3_RNase[k,]), method = "pearson")})
      ))

rownames(RNase_Cor) = rownames(RNase_RDeep)
colnames(RNase_Cor) = c("cor(Rep1, Rep2)", "cor(Rep2, Rep3)", "cor(Rep1, Rep3)")


#### Sometimes NA values are produced -> we will test which replicates only contain zeros

#which(rowSums(Rep1_Ctrl)  == 0)
#which(rowSums(Rep2_Ctrl)  == 0)
#which(rowSums(Rep3_Ctrl)  == 0)

#which(rowSums(Rep1_RNase)  == 0)
#which(rowSums(Rep2_RNase)  == 0)
#which(rowSums(Rep3_RNase)  == 0)

### if two replicates of one condition contain only 0 we will remove the entire gene from both conditions (no sufficient data for analysis); the other replicates will be replaced with the value "NA"

# -> Removal of rows 639 (BHMT2_HUMAN) (Rep2_Ctrl & Rep3_Ctrl), 3297 (MAP9_HUMAN) (Rep1_Ctrl & Rep2_Ctrl) 1771 (ECT2_HUMAN) (Rep2_RNase & Rep3_RNase), 2359 (GP161_HUMAN) (Rep2_RNase & Rep3_RNase) and 4209 (PATZ1_HUMAN) (Rep1_RNase & Rep2_RNase)

Ctrl_RDeep <- Ctrl_RDeep[!(rownames(Ctrl_RDeep) %in% c("BHMT2_HUMAN", "MAP9_HUMAN", "ECT2_HUMAN", "GP161_HUMAN", "PATZ1_HUMAN")),]

RNase_RDeep <- RNase_RDeep[!(rownames(RNase_RDeep) %in% c("BHMT2_HUMAN", "MAP9_HUMAN", "ECT2_HUMAN", "GP161_HUMAN", "PATZ1_HUMAN")),]

# ---> Wenn gesamte Gene gelöscht werden, müssen diese jeweils auch aus den Ctrl_Cor und RNase_Cor Datensätzen entfernt werden, da ansonsten später falsche Replikate überschrieben werden würden
Ctrl_Cor <- Ctrl_Cor[!(rownames(Ctrl_Cor) %in% c("BHMT2_HUMAN", "MAP9_HUMAN", "ECT2_HUMAN", "GP161_HUMAN", "PATZ1_HUMAN")),]

RNase_Cor <- RNase_Cor[!(rownames(RNase_Cor) %in% c("BHMT2_HUMAN", "MAP9_HUMAN", "ECT2_HUMAN", "GP161_HUMAN", "PATZ1_HUMAN")),]

# -> Replacement of:
      # Rep1_Ctrl: 664 (BMX_HUMAN), 1470 (DCAF7_HUMAN), 6487 (TSC2_HUMAN)
      # Rep2_RNase: 904 (CCDC9_HUMAN), 1305 (CQ051_HUMAN)
      # Rep3_RNase: 2523 (HEM0_HUMAN), 6491 (TSN3_HUMAN)

Ctrl_RDeep[which(rownames(Ctrl_RDeep) == "BMX_HUMAN"), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Ctrl_RDeep[which(rownames(Ctrl_RDeep) == "DCAF7_HUMAN"), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Ctrl_RDeep[which(rownames(Ctrl_RDeep) == "TSC2_HUMAN"), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

RNase_RDeep[which(rownames(Ctrl_RDeep) == "CCDC9_HUMAN"), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

RNase_RDeep[which(rownames(Ctrl_RDeep) == "CQ051_HUMAN"), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

RNase_RDeep[which(rownames(Ctrl_RDeep) == "HEM0_HUMAN"), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

RNase_RDeep[which(rownames(Ctrl_RDeep) == "TSN3_HUMAN"), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA


# ---> zur vereinfachten Berechnung erstellen wir zwei Matrices, die genau so groß sind wie die Datenframes "Ctrl_Cor" und "RNase_Cor", aber bei jeder Korrelation über oder gleich 0.95 eine "1" enthalten und bei jeder Korrelation unter 0.95 eine "0" enthalten.
Ctrl_Cor_Rep = rep(1, nrow(Ctrl_Cor)*3)
Ctrl_Cor_Rep[which(Ctrl_Cor < 0.95)] = 0
Ctrl_Cor_Rep = matrix(Ctrl_Cor_Rep, ncol = 3)

RNase_Cor_Rep = rep(1, nrow(RNase_Cor)*3)
RNase_Cor_Rep[which(RNase_Cor < 0.95)] = 0
RNase_Cor_Rep = matrix(RNase_Cor_Rep, ncol = 3)

# ---> wir wollen zuerst alle Gene löschen, die in einer condition für alle drei Korrelationen unter 0.95 liegen (werden aber auch separat in den Dataframes "Ctrl_Weird" und "RNase_Weird" abgespeichert)
# ---> Note: only the second row has < 0.95 both in RNase and Control for all 3 replicates (therefore the [-1])
Gene.Pos = c(which(rowSums(Ctrl_Cor_Rep) == 0)[-1], which(rowSums(RNase_Cor_Rep) == 0))

Ctrl_Weird <- Ctrl_RDeep[which(rowSums(Ctrl_Cor_Rep) == 0), ]

RNase_Weird <- RNase_RDeep[which(rowSums(RNase_Cor_Rep) == 0), ]

Ctrl_RDeep <- Ctrl_RDeep[- Gene.Pos,]

RNase_RDeep <- RNase_RDeep[- Gene.Pos,]

# ---> wie oben auch, müssen die Gene auch aus den "Ctrl_Cor" und "RNase_Cor" Dataframes gelöscht werden, zudem aus den "Ctrl_Cor_Rep" und "RNase_Cor_Rep" Dataframes
Ctrl_Cor <- Ctrl_Cor[- Gene.Pos,]

RNase_Cor <- RNase_Cor[- Gene.Pos,]

Ctrl_Cor_Rep <- Ctrl_Cor_Rep[- Gene.Pos,]

RNase_Cor_Rep <- RNase_Cor_Rep[- Gene.Pos,]


# ---> wir ersetzen nun die Replikate mit NA values, für die gilt, dass ihre beiden Korrelationen unter 0.95 liegen
Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == Ctrl_Cor_Rep[, 3] & rowSums(Ctrl_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == Ctrl_Cor_Rep[, 2] & rowSums(Ctrl_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 2] == Ctrl_Cor_Rep[, 3] & rowSums(Ctrl_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA


RNase_RDeep[which(RNase_Cor_Rep[, 1] == RNase_Cor_Rep[, 3] & rowSums(RNase_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

RNase_RDeep[which(RNase_Cor_Rep[, 1] == RNase_Cor_Rep[, 2] & rowSums(RNase_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

RNase_RDeep[which(RNase_Cor_Rep[, 2] == RNase_Cor_Rep[, 3] & rowSums(RNase_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA


# ---> Zum Schluss ersetzen wir jeweils das Replikat mit NA-values, wenn eine der Korrelationen unter 0.95 liegt und die andere Korrelation kleiner ist als die dritte Korrelation (wenn bspw. cor(Rep1, Rep2) unter 0.95 liegt und cor(Rep2,Rep3) größer als cor(Rep1, Rep3) ist, dann wird Rep1 ersetzt)

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 2] > Ctrl_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 2] < Ctrl_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


Ctrl_RDeep[which(Ctrl_Cor_Rep[, 2] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 1] > Ctrl_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 2] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 1] < Ctrl_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


Ctrl_RDeep[which(Ctrl_Cor_Rep[, 3] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 1] > Ctrl_Cor[, 2]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 3] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 1] < Ctrl_Cor[, 2]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA



RNase_RDeep[which(RNase_Cor_Rep[, 1] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 2] > RNase_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

RNase_RDeep[which(RNase_Cor_Rep[, 1] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 2] < RNase_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


RNase_RDeep[which(RNase_Cor_Rep[, 2] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 1] > RNase_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

RNase_RDeep[which(RNase_Cor_Rep[, 2] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 1] < RNase_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


RNase_RDeep[which(RNase_Cor_Rep[, 3] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 1] > RNase_Cor[, 2]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

RNase_RDeep[which(RNase_Cor_Rep[, 3] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 1] < RNase_Cor[, 2]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA


# ---> Entfernung der erzeugten Variablen
rm(Rep1_Ctrl, Rep2_Ctrl, Rep3_Ctrl, Rep1_RNase, Rep2_RNase, Rep3_RNase, Ctrl_Cor_Rep, RNase_Cor_Rep, Gene.Pos)
```


##### 1.4 Mean of Replicates

```{r cleanup, include=FALSE}
Ctrl_Mean = as.data.frame(
            # Abspeichern als Dataframe
  
  sapply(seq(0,72,3), function(i) {
  # Äußere Schleife, die zum Auswählen der drei Replikate pro Fraktion da ist (Startvektor c(1,2,3) wird jeweils um c(3,3,3) erhöht) 
    
    apply(Ctrl_RDeep[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x, na.rm = T)})
    # Innere Schleife, die nachdem die drei Replikate für eine Fraktion ausgewählt wurden, über alle Zeilen dieser       Replikate den Mittelwert berechnet
    
    }))

# Erstellen neuer Spaltennamen für den Ctrl_Mean Dataframe. Der Befehl "paste" erlaubt es, sowohl Text als auch Befehle als ein String zu haben (sep="", bedeutet, dass die Elemente durch kein Leerzeichen voneinander getrennt werden sollen)
colnames(Ctrl_Mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")

# Analoges Vorgehen für den RNase Dataframe
RNase_Mean = as.data.frame(
  sapply(seq(0,72,3), function(i) {
    apply(RNase_RDeep[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x, na.rm = T)})
    }))

colnames(RNase_Mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")
```


##### 1.5 Normalize Rows to 100

This will be done for the Control and RNase Datasets separately:

```{r cleanup, include=FALSE}
Ctrl_Norm100 = as.data.frame(sapply(Ctrl_RDeep, function(i){(i/apply(Ctrl_RDeep,1,sum))*100}))

RNase_Norm100 = as.data.frame(sapply(RNase_RDeep, function(i){(i/apply(RNase_RDeep,1,sum))*100}))
```


##### 1.6 Data Exploration, First Graphical Representations

###### 1.6.1 Without Normalization
```{r cleanup, echo=FALSE}
plot(1:25, Ctrl_Mean[which(rownames(Ctrl_RDeep)==c("CTCF_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CTCF_HUMAN")
lines(1:25, RNase_Mean[which(rownames(RNase_RDeep)==c("CTCF_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```
```{r cleanup, echo=FALSE}
plot(1:25, Ctrl_Mean[which(rownames(Ctrl_RDeep)==c("CY24A_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CY24A_HUMAN")
lines(1:25, RNase_Mean[which(rownames(RNase_RDeep)==c("CY24A_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```

###### 1.6.2 With Normailzation 
```{r cleanup, include=FALSE}
Ctrl_Mean_Norm100 = as.data.frame(sapply(Ctrl_Mean, function(i){(i/apply(Ctrl_Mean,1,sum))*100}))

RNase_Mean_Norm100 = as.data.frame(sapply(RNase_Mean, function(i){(i/apply(RNase_Mean,1,sum))*100}))
```

```{r cleanup, echo=FALSE}
plot(1:25, Ctrl_Mean_Norm100[which(rownames(Ctrl_RDeep)==c("CTCF_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CTCF_HUMAN Normalized", ylim=c(0,25))
lines(1:25, RNase_Mean_Norm100[which(rownames(RNase_RDeep)==c("CTCF_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```

```{r cleanup, echo=FALSE}
plot(1:25, Ctrl_Mean_Norm100[which(rownames(Ctrl_RDeep)==c("CY24A_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CY24A_HUMAN Normailzed", ylim=c(0,18))
lines(1:25, RNase_Mean_Norm100[which(rownames(RNase_RDeep)==c("CY24A_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```


#### 2. Smoothing and Determination of Maxima

##### 2.1 Smoothing the Data

We will smooth out the Data by calculating the mean value for each fraction within a defined neighborhood (n = 1):

```{r smoothing, include=FALSE}
# n = 1 (left and right neighbor)
Ctrl_Mean_Smooth = 
  # 5: Abspeichern der Matrix als Data.Frame
  as.data.frame(
# 4: Spaltenweises Verbinden der zwei Vektoren und der Matrix | Output: Matrix mit 25 Spalten und 7081 Zeilen 
cbind(
  
  # 2: Mittelwert-Berechnung für die Fraktion 1 (Mittelwert aus der Fraktion 1 und 2) | Output: Vektor mit 7081        Einträgen
  (Ctrl_Mean[,1]+Ctrl_Mean[,2])/2,
      
      # 1: Schleife, die jeweils ein Fenster aus 3 Fraktionen auswählt (startet bei 1,2,3 und endet bei 23,24,25) und       dann mit einer zweiten Schleife den Mittelwert dieser 3 Fraktione über alle Reihen berechnet | Output: Matrix        mit 23 Spalten und 7081 Zeilen, die die Mittelwerte für die Fraktionen 2 bis 24 enthält
      sapply(seq(0,22,1), function(i) {apply(Ctrl_Mean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})}), 
  
  # 3: Mittelwert-Berechnung für die Fraktion 25 (Mittelwert aus der Fraktion 24 und 25) | Output: Vektor mit 7081     Einträgen
  (Ctrl_Mean[,24]+Ctrl_Mean[,25])/2)
)

colnames(Ctrl_Mean_Smooth) = colnames(Ctrl_Mean)


# Gleicher Code für RNase
RNase_Mean_Smooth = 
  as.data.frame(
cbind((RNase_Mean[,1]+RNase_Mean[,2])/2,
      sapply(seq(0,22,1), function(i) {apply(RNase_Mean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})}), 
      (RNase_Mean[,24]+RNase_Mean[,25])/2)
)

colnames(RNase_Mean_Smooth) = colnames(RNase_Mean)
```

We will now normalize this data in a way, that the sum of each row will equal 100:
```{r smoothing, include=FALSE}
Ctrl_Mean_Smooth_Norm100 = as.data.frame(sapply(Ctrl_Mean_Smooth, function(i){(i/apply(Ctrl_Mean_Smooth,1,sum))*100}))

RNase_Mean_Smooth_Norm100 = as.data.frame(sapply(RNase_Mean_Smooth, function(i){(i/apply(RNase_Mean_Smooth,1,sum))*100}))
```

Now let us explore how this Smoothing and Normalization effects the data distribution:
```{r smoothing, echo=FALSE}
plot(1:25, Ctrl_Mean [which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CTCF_HUMAN", ylim=c(0,2200000))
lines(1:25, RNase_Mean[which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CTCF_HUMAN (Smoothed)", ylim=c(0,2200000))
lines(1:25, RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CTCF_HUMAN (Smoothed and Normalized)", ylim=c(0,22))
lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```

```{r smoothing, echo=FALSE}
plot(1:25, Ctrl_Mean [which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CY24A_HUMAN", ylim=c(0,950000))
lines(1:25, RNase_Mean[which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CY24A_HUMAN (Smoothed)", ylim=c(0,950000))
lines(1:25, RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CY24A_HUMAN (Smoothed and Normalized)", ylim=c(0,22))
lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```
```{r smoothing, echo=FALSE}
plot(1:25, Ctrl_Mean [which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="ABCA1_HUMAN", ylim=c(0,220000))
lines(1:25, RNase_Mean[which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="ABCA1_HUMAN (Smoothed)", ylim=c(0,220000))
lines(1:25, RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="ABCA1_HUMAN (Smoothed and Normalized)", ylim=c(0,38))
lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```


##### 2.2 Determination of Global and Local Maxima

###### 2.2.1 Global Maxima

Let us first start with the global maxima: we want a code that tells us the global maximum fraction position for each gene and condition (Control and RNase).
We can calculate the global maxima by asking the question: "Which Protein Fractions contains the maximum protein amount?"
```{r global max, include=FALSE}
Ctrl_Mean_Gbl_Max = 
  
  # 2: Abspeichern als Matrix (besser für weiter Berechnungen (siehe unten))
  as.matrix(
    
    # 1: Schleife, die für jedes Gen des Datensatzes "Ctrl_Mean_Smooth_Norm100" bestimmt, welche Fraktion den           größten Protein-Anteil enthält | Output: Liste mit allen Fraktionen mit größtem Protein-Anteil pro Gen             (Problem: manchmal mehrere Einträge für ein Gen (siehe Plot von Gen ABCA1_HUMAN oben))
    sapply(seq(1, nrow(Ctrl_RDeep), 1), function(i) {which(Ctrl_Mean_Smooth_Norm100[i,] == max(Ctrl_Mean_Smooth_Norm100[i,]))}))


## If 2 fraction positions contain the maximum protein amount, we determine the mean of these 2 fraction positions

# 2: Wir rufen die Fraction Positions für die Zeilen ab, die genau zwei globale Maxima enthalten | Output: Liste mit den globalen Maxima für alle Gene
Ctrl_Mean_Gbl_Max[
  
  # 1: Für jedes Gen wird geschaut, wie viele Einträge es für die globalen Maxima gibt und verglichen, ob es genau 2   Einträge gibt. "which()" gibt dann die Gene aus, für die diese Bedingung TRUE ist. | Output: vektor aller Zeilen,    für die Bedingung stimmt.
  which(
    sapply(seq(1,nrow(Ctrl_RDeep),1),function(i) {
      length(which(Ctrl_Mean_Smooth_Norm100[i,] == max(Ctrl_Mean_Smooth_Norm100[i,])))}) == 2), 
     
     # 3: Wir ersetzen jede Zeile, die 2 Einträge besitzt, mit dem Mittelwert aus diesen 2 Einträgen
  1] = 
  apply(matrix(unlist(Ctrl_Mean_Gbl_Max[which(sapply(seq(1,nrow(Ctrl_RDeep),1),function(i) {length(which(Ctrl_Mean_Smooth_Norm100[i,] == max(Ctrl_Mean_Smooth_Norm100[i,]) ))}) == 2),1]), ncol=2, byrow=T), 1, function(x) {mean(x)})

## If 3 fraction positions contain the maximum protein amount, we determine the mean of these 3 fraction positions
Ctrl_Mean_Gbl_Max[which(sapply(seq(1,nrow(Ctrl_RDeep),1),function(i) {length(which(Ctrl_Mean_Smooth_Norm100[i,] == max(Ctrl_Mean_Smooth_Norm100[i,]) ))}) == 3),1] = apply(matrix(unlist(Ctrl_Mean_Gbl_Max[which(sapply(seq(1,nrow(Ctrl_RDeep),1),function(i) {length(which(Ctrl_Mean_Smooth_Norm100[i,] == max(Ctrl_Mean_Smooth_Norm100[i,]) ))}) == 3),1]), ncol=3, byrow=T), 1, function(x) {mean(x)})

Ctrl_Mean_Gbl_Max = as.data.frame(unlist(Ctrl_Mean_Gbl_Max))

colnames(Ctrl_Mean_Gbl_Max) = c("Ctrl_Gbl_Max")
rownames(Ctrl_Mean_Gbl_Max) = rownames(Ctrl_Mean_Smooth_Norm100)


RNase_Mean_Gbl_Max = as.matrix(sapply(seq(1,nrow(RNase_RDeep),1),function(i) {which(RNase_Mean_Smooth_Norm100[i,] == max(RNase_Mean_Smooth_Norm100[i,]))}))

RNase_Mean_Gbl_Max[which(sapply(seq(1,nrow(RNase_RDeep),1),function(i) {length(which(RNase_Mean_Smooth_Norm100[i,] == max(RNase_Mean_Smooth_Norm100[i,]) ))}) == 2),1] = apply(matrix(unlist(RNase_Mean_Gbl_Max[which(sapply(seq(1,nrow(RNase_RDeep),1),function(i) {length(which(RNase_Mean_Smooth_Norm100[i,] == max(RNase_Mean_Smooth_Norm100[i,]) ))}) == 2),1]), ncol=2, byrow=T), 1, function(x) {mean(x)})

RNase_Mean_Gbl_Max[which(sapply(seq(1,nrow(RNase_RDeep),1),function(i) {length(which(RNase_Mean_Smooth_Norm100[i,] == max(RNase_Mean_Smooth_Norm100[i,]) ))}) == 3),1] = apply(matrix(unlist(RNase_Mean_Gbl_Max[which(sapply(seq(1,nrow(RNase_RDeep),1),function(i) {length(which(RNase_Mean_Smooth_Norm100[i,] == max(RNase_Mean_Smooth_Norm100[i,]) ))}) == 3),1]), ncol=3, byrow=T), 1, function(x) {mean(x)})

RNase_Mean_Gbl_Max = as.data.frame(unlist(RNase_Mean_Gbl_Max))

colnames(RNase_Mean_Gbl_Max) = c("RNase_Gbl_Max")
rownames(RNase_Mean_Gbl_Max) = rownames(RNase_Mean_Smooth_Norm100)

Mean_Gbl_Max = cbind(Ctrl_Mean_Gbl_Max, RNase_Mean_Gbl_Max)

# length(which(unlist(Mean_Gbl_Max[,1]) == unlist(Mean_Gbl_Max[,2])))
# length(which(abs(unlist(Mean_Gbl_Max[,1])-unlist(Mean_Gbl_Max[,2])) >= 2))
```


Let us see if it worked!
```{r global max, echo=FALSE}
gene.name=c("CTCF_HUMAN")

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main=paste(paste(gene.name, "(Smoothed and Normalized)")), ylim=c(0,25))

abline(v=Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name),],lwd=3,col="green",lty=2)

lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),], type="l",lwd=3,col="red")

abline(v=RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name),],lwd=3,col="red",lty=3)

grid()

legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
rm(gene.name)
```


```{r global max, echo=FALSE}
gene.name=c("CY24A_HUMAN")

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main=paste(paste(gene.name, "(Smoothed and Normalized)")), ylim=c(0,20))

abline(v=Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name),],lwd=3,col="green",lty=2)

lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),], type="l",lwd=3,col="red")

abline(v=RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name),],lwd=3,col="red",lty=3)

grid()

legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
rm(gene.name)
```

But Smoothing sometimes changes the position of the maxima:
```{r global max, echo=FALSE}
gene.name="XXLT1_HUMAN"

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),],type="l",lwd=3,col="green",xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(paste(gene.name, "(Smoothed and Normalized)")), ylim=c(0,max(max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),]), max(RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),]))+3))

abline(v=Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name),],lwd=3,col="green",lty=3)

lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),], type="l",lwd=3,col="red")

abline(v=RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name),],lwd=3,col="red",lty=3)

grid()

legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)


plot(1:25, Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name),],type="l",lwd=3,col="green",xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(paste(gene.name, "(Normalized)")), ylim=c(0,max(max(Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name),]), max(RNase_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name),]))+3))

abline(v=Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name),],lwd=3,col="green",lty=3)

lines(1:25, RNase_Mean_Norm100[which(rownames(RNase_Mean)==gene.name),], type="l",lwd=3,col="red")

abline(v=RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name),],lwd=3,col="red",lty=3)

grid()

legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

rm(gene.name)
```

###### 2.2.2 Local Maxima

We will now calculate the fraction positions of all local maxima for every gene and condition. But what defines a local maximum? 
We will look at the protein amount for a neighborhood of n = 2 for each fraction positions (for local maxima at the edges we will use slightly different criteria):

X X [X] X X 

We will then compare the protein amount in that fraction position to the protein amount for the 4 fraction positions around that fraction position and ask the question: Is the protein amount in that fraction greater or equal to its neighborhood? If TRUE then we define that fraction position as a local maximum.
```{r local max, include=FALSE}
# ---> Erstellen eines Data.Frames mit 25 Spalten und so vielen Zeilen, wie es Gene gibt (nur NA-values)
Ctrl_Mean_Loc_Max = as.data.frame(matrix(NA, nrow = nrow(Ctrl_RDeep), ncol = 25))

# ---> Bestimmung der Fraction Positions für alle lokalen Maxima (in den Control Samples), indem jeweils in einem 5 Fraktion-Window berechnet wird, welche Position den größten Protein Anteil beinhaltet und ob diese Position der mittleren Position entspricht
Fra.Pos = sapply(seq(0,20,1), function(i) {which(seq(2*nrow(Ctrl_RDeep)+1,3*nrow(Ctrl_RDeep),1) %in% which(apply(Ctrl_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) == Ctrl_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)] & apply(Ctrl_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) != 0))})

# ---> Einspeichern der lokalen Maxima im Data.Frame "Ctrl_Mean_Loc_Max" (erstellt in erster Zeile des Chunks), indem pro Gen der NA-value jeder Fraktion, die ein lokales Maximum ist, durch den Wert der Fraktion ersetzt wird (also, wenn in Gen 1 Fraktion 5 ein lokales Maximum ist, wird der Wert für Fraktion 5 in Gen 1 (NA) mit "5" ersetzt) 
Ctrl_Mean_Loc_Max[, 3:23] = sapply(seq(1,21,1), function(n) {
  replace(
        Ctrl_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        n+2)})

# ---> Benennung der Zeilen (Gennamen) und Spalten (Fraktionen)
rownames(Ctrl_Mean_Loc_Max) = rownames(Ctrl_Mean)
colnames(Ctrl_Mean_Loc_Max) = colnames(Ctrl_Mean)


# ---> Gleicher Code für die RNase Samples
RNase_Mean_Loc_Max = as.data.frame(matrix(NA, nrow = nrow(RNase_RDeep), ncol = 25))

Fra.Pos = sapply(seq(0,20,1), function(i) {which(seq(2*nrow(RNase_RDeep)+1,3*nrow(RNase_RDeep),1) %in% which(apply(RNase_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) == RNase_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)] & apply(RNase_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) != 0))})

RNase_Mean_Loc_Max[, 3:23] = sapply(seq(1,21,1), function(n) {
  replace(
        RNase_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        n+2)})

rownames(RNase_Mean_Loc_Max) = rownames(RNase_Mean)
colnames(RNase_Mean_Loc_Max) = colnames(RNase_Mean)


## Edge Cases:

# ---> Da wir eine Maske mit n = 2 anwenden, können wir mit dieser Methode nur die Fraktionen 3 bis 23 auf lokale Maxima überprüfen. Damit Fraktion 1 bzw. 25 ein lokales Maximum sind, müssen sie größer sein, als die Fraktionen 2 und 3 bzw. 24 und 23. Damit Fraktion 2 bzw. 24 ein lokales Maximum sind, müssen sie größer sein, als die Fraktionen 1, 3 und 4 bzw. 25, 23 und 22.  

# Fraction 1
Ctrl_Mean_Loc_Max[which(Ctrl_Mean_Smooth_Norm100[,1] >= Ctrl_Mean_Smooth_Norm100[,2] & Ctrl_Mean_Smooth_Norm100[,1] >= Ctrl_Mean_Smooth_Norm100[,3] & Ctrl_Mean_Smooth_Norm100[,1] != 0),1] = 1

RNase_Mean_Loc_Max[which(RNase_Mean_Smooth_Norm100[,1] >= RNase_Mean_Smooth_Norm100[,2] & RNase_Mean_Smooth_Norm100[,1] >= RNase_Mean_Smooth_Norm100[,3] & RNase_Mean_Smooth_Norm100[,1] != 0),1] = 1

# Fraction 2
Ctrl_Mean_Loc_Max[which(Ctrl_Mean_Smooth_Norm100[,2] >= Ctrl_Mean_Smooth_Norm100[,3] & Ctrl_Mean_Smooth_Norm100[,2] >= Ctrl_Mean_Smooth_Norm100[,4] & Ctrl_Mean_Smooth_Norm100[,2] >= Ctrl_Mean_Smooth_Norm100[,1] & Ctrl_Mean_Smooth_Norm100[,1] != 0), 2] = 2

RNase_Mean_Loc_Max[which(RNase_Mean_Smooth_Norm100[,2] >= RNase_Mean_Smooth_Norm100[,3] & RNase_Mean_Smooth_Norm100[,2] >= RNase_Mean_Smooth_Norm100[,4] & RNase_Mean_Smooth_Norm100[,2] >= RNase_Mean_Smooth_Norm100[,1] & RNase_Mean_Smooth_Norm100[,1] != 0), 2] = 2

# Fraction 25
Ctrl_Mean_Loc_Max[which(Ctrl_Mean_Smooth_Norm100[,25] >= Ctrl_Mean_Smooth_Norm100[,24] & Ctrl_Mean_Smooth_Norm100[,25] >= Ctrl_Mean_Smooth_Norm100[,23] & Ctrl_Mean_Smooth_Norm100[,25] != 0), 25] = 25

RNase_Mean_Loc_Max[which(RNase_Mean_Smooth_Norm100[,25] >= RNase_Mean_Smooth_Norm100[,24] & RNase_Mean_Smooth_Norm100[,25] >= RNase_Mean_Smooth_Norm100[,23] & RNase_Mean_Smooth_Norm100[,25] != 0), 25] = 25

# Fraction 24
Ctrl_Mean_Loc_Max[which(Ctrl_Mean_Smooth_Norm100[,24] >= Ctrl_Mean_Smooth_Norm100[,23] & Ctrl_Mean_Smooth_Norm100[,24] >= Ctrl_Mean_Smooth_Norm100[,22] & Ctrl_Mean_Smooth_Norm100[,24] >= Ctrl_Mean_Smooth_Norm100[,25] & Ctrl_Mean_Smooth_Norm100[,24] != 0), 24] = 24

RNase_Mean_Loc_Max[which(RNase_Mean_Smooth_Norm100[,24] >= RNase_Mean_Smooth_Norm100[,23] & RNase_Mean_Smooth_Norm100[,24] >= RNase_Mean_Smooth_Norm100[,22] & RNase_Mean_Smooth_Norm100[,24] >= RNase_Mean_Smooth_Norm100[,25] & RNase_Mean_Smooth_Norm100[,24] != 0), 24] = 24


## Removal of Global Maxima in Local Maxima Datasets (also removes all double and triple global maxima!!!)

# ---> Die Methode, die wir zum Finden der lokalen Maxima bisher angewendet haben, gibt uns als Output natürlich auch die Positionen der globalen Maxima. Diese wollen wir nun mit der Hilfe einer Maske (Ctrl_Mask bzw. RNase_Mask) entfernen: diese hat die gleiche Größe, wie der Data.frame Ctrl_Mean_Loc_Max bzw. RNase_Mean_Loc_Max (# Gene x 25) enthält aber nur den Wert "1", außer an den Stellen, an denen es globale Maxima gibt (dort ist der Wert NA vermerkt). Multiplizieren wir nun die Maske mit dem Data.frame, werden alle globalen Peaks gelöscht (durch NA ersetzt), während die lokalen Peaks erhalten bleiben (NA * any value = NA, 1 * any value = any value). 

Crtl_Mask = matrix(1, nrow = nrow(Ctrl_RDeep)*25, ncol = 1)

Crtl_Mask[which(apply(Ctrl_Mean_Smooth_Norm100, 1, function(x) {max(x)}) == Ctrl_Mean_Smooth_Norm100)] = NA

Crtl_Mask = as.data.frame(matrix(unlist(Crtl_Mask), nrow=nrow(Ctrl_RDeep), ncol=25))

Ctrl_Mean_Loc_Max = Ctrl_Mean_Loc_Max * Crtl_Mask

rm(Crtl_Mask)


RNase_Mask = matrix(1, nrow = nrow(RNase_RDeep)*25, ncol = 1)

RNase_Mask[which(apply(RNase_Mean_Smooth_Norm100, 1, function(x) {max(x)}) == RNase_Mean_Smooth_Norm100)] = NA

RNase_Mask = as.data.frame(matrix(unlist(RNase_Mask), nrow=nrow(RNase_RDeep), ncol=25))

RNase_Mean_Loc_Max = RNase_Mean_Loc_Max * RNase_Mask

rm(RNase_Mask)


### Combine double and triple peaks into single peaks

# ---> Wie bei der Bestimmung der globalen Peaks auch, gibt es auch bei den lokalen Peaks manchmal Fälle, in denen 2 oder 3 peaks direkt nebeneinander vorkommen. Diese wollen wir nun jeweils durch den Mittelwert der Positionen der peaks ersetzen (bei einem double peak wird der Mittelwert in die linke der beiden Fraktionen notiert und der rechte peak durch NA ersetzt; und bei einem triple peak werden die Fraction-positions links und rechts von mittleren peak durch NA ersetzt).

## Double peaks
Fra.Pos = sapply(seq(0,21,1), function(i) {which(!(is.na(Ctrl_Mean_Loc_Max[,c(2)+c(i)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(3)+c(i)])) & is.na(Ctrl_Mean_Loc_Max[,c(1)+c(i)]) & is.na(Ctrl_Mean_Loc_Max[,c(4)+c(i)]))})

Ctrl_Mean_Loc_Max[, 2:23] = sapply(seq(1,22,1), function(n) {
  replace(
        Ctrl_Mean_Loc_Max[, n+1], 
        Fra.Pos[[n]], 
        n+1.5)})

Ctrl_Mean_Loc_Max[, 3:24] = sapply(seq(1,22,1), function(n) {
  replace(
        Ctrl_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        NA)})


## Edge Cases (not necessary in this case)

# ---> Bei den double peaks müssten wir noch Fraktion 1 & 2 und 24 & 25 gesondert betrachen, da wir diese vorher nicht überprüfen können (der Code überprüft jeweils, ob in der aktuell ausgewählten Position und der Position rechts davon ein Wert vorhanden ist; um die Erkennung von triple peaks zu vermeiden, muss aber auch überprüft werden, ob in der Fraktion links und zweifach rechts von der aktuellen Position keine Werte (also NA-values) vorhanden sind). Diese Edge cases treten aber nicht auf und somit ist der Code redundant.

# Fra.Pos = which(!(is.na(Ctrl_Mean_Loc_Max[,c(1)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(2)])) & !(!(is.na(Ctrl_Mean_Loc_Max[,c(1)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(2)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(3)]))))

# Ctrl_Mean_Loc_Max[Fra.Pos[[1]],1]=1.5
# Ctrl_Mean_Loc_Max[Fra.Pos[[1]],2]=NA

# Fra.Pos = which(!(is.na(Ctrl_Mean_Loc_Max[,c(24)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(25)])) & !(!(is.na(Ctrl_Mean_Loc_Max[,c(23)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(24)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(25)]))))

# Ctrl_Mean_Loc_Max[Fra.Pos[[1]],24]=24.5
# Ctrl_Mean_Loc_Max[Fra.Pos[[1]],25]=NA


Fra.Pos = sapply(seq(0,21,1), function(i) {which(!(is.na(RNase_Mean_Loc_Max[,c(2)+c(i)])) & !(is.na(RNase_Mean_Loc_Max[,c(3)+c(i)])) & is.na(RNase_Mean_Loc_Max[,c(1)+c(i)]) & is.na(RNase_Mean_Loc_Max[,c(4)+c(i)]))})

RNase_Mean_Loc_Max[, 2:23] = sapply(seq(1,22,1), function(n) {
  replace(
        RNase_Mean_Loc_Max[, n+1], 
        Fra.Pos[[n]], 
        n+1.5)})

RNase_Mean_Loc_Max[, 3:24] = sapply(seq(1,22,1), function(n) {
  replace(
        RNase_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        NA)})

# Edge Cases (not necessary in this case)

# Fra.Pos = which(!(is.na(RNase_Mean_Loc_Max[,c(1)])) & !(is.na(RNase_Mean_Loc_Max[,c(2)])) & !(!(is.na(RNase_Mean_Loc_Max[,c(1)])) & !(is.na(RNase_Mean_Loc_Max[,c(2)])) & !(is.na(RNase_Mean_Loc_Max[,c(3)]))))

# RNase_Mean_Loc_Max[Fra.Pos[[1]],1]=1.5
# RNase_Mean_Loc_Max[Fra.Pos[[1]],2]=NA

# Fra.Pos = which(!(is.na(RNase_Mean_Loc_Max[,c(24)])) & !(is.na(RNase_Mean_Loc_Max[,c(25)])) & !(!(is.na(RNase_Mean_Loc_Max[,c(23)])) & !(is.na(RNase_Mean_Loc_Max[,c(24)])) & !(is.na(RNase_Mean_Loc_Max[,c(25)]))))

# RNase_Mean_Loc_Max[Fra.Pos[[1]],24]=24.5
# RNase_Mean_Loc_Max[Fra.Pos[[1]],25]=NA



# Triple peaks
Fra.Pos = sapply(seq(0,22,1), function(i) {which(!(is.na(Ctrl_Mean_Loc_Max[,c(1)+c(i)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(2)+c(i)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(3)+c(i)])))})

Ctrl_Mean_Loc_Max[, 1:23] = sapply(seq(1,23,1), function(n) {
  replace(
        Ctrl_Mean_Loc_Max[, n], 
        Fra.Pos[[n]], 
        NA)})

Ctrl_Mean_Loc_Max[, 3:25] = sapply(seq(1,23,1), function(n) {
  replace(
        Ctrl_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        NA)})


Fra.Pos = sapply(seq(0,22,1), function(i) {which(!(is.na(RNase_Mean_Loc_Max[,c(1)+c(i)])) & !(is.na(RNase_Mean_Loc_Max[,c(2)+c(i)])) & !(is.na(RNase_Mean_Loc_Max[,c(3)+c(i)])))})

RNase_Mean_Loc_Max[, 1:23] = sapply(seq(1,23,1), function(n) {
  replace(
        RNase_Mean_Loc_Max[, n], 
        Fra.Pos[[n]], 
        NA)})

RNase_Mean_Loc_Max[, 3:25] = sapply(seq(1,23,1), function(n) {
  replace(
        RNase_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        NA)})


rm(Fra.Pos)
```


#### 3. Gaussian Fitting

##### 3.1 Introduction

A Normal Distribution can be described as:

f(x) = h/(sd * sqrt(2 * pi)) * exp^(-1/2 * ((x - mu)/sd)^2)

with **h** the **height**, **sd** the **standard deviation** and **mu** the **mean** of the distribution.

To fit a Gaussian curve to each global peak per gene and condition, we want to find the optimal values for these 3 parameters for each global peak per gene and condition. 
We define an optimal value as a value that minimizes the sum of squares of the differences between the Gaussian curve and the smoothed and normalized protein distribution.

But first we will approximate each parameter with the following values:

  * mu <- Fraction Position of Global Peak 
  * sd <- Half width at half maximum (HWHM)/sqrt(2 * ln(2)) (note: FWHM = 2 * sqrt(2 * ln(2))) * sd)
  * h <- Maximum Protein Amount * (sd * sqrt(2 * pi))

Now we can define 3 separate functions (`mu_finder`, `sd_finder`, `h_finder`) that calculate the sum of squares for each parameter and use the `optimise` function to tweak each parameter so that the sum of squares is minimized. Note that the order in which we will optimize these parameters matters, because depending on which parameters where optimized first the optimized values can differ. Based on experimentation we decided to first optimize **mu**, then **sd** and lastly **h**. 

Furthermore, we restrict the optimization to a specified interval around the first approximations of the parameters. This is needed because we just want to fit the Gaussian curve to the local region around each global peak. Because the protein distribution is mostly not normally distributed, too much freedom in the optimization process could lead to skewed results. 
We define these intervals as:

  * mu: [mu - 0.5, mu + 0.5]
  * sd: [sd - 0.2 * sd, sd + 0.2 * sd]
  * h:  [h - 5, h + 5]
  
Lastly, we calculate the protein amount under each gaussian curve (**prt_amount**) in the interval [0, 25]. 


##### 3.2 Proof-of-Concept

To test if this method works, we will try to fit Gaussian curves to the global peaks of the Control and RNase distributions of the *CTCF_HUMAN* gene:

```{r gauss, echo=FALSE}
# ---> Wir wählen ein beliebiges Gen aus
gene.name=c("CTCF_HUMAN")

# ---> Schätzung der Werte für mu, sd und h anhand der oben beschriebenen Berechnungen
mu_Ctrl <- unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name),])
sd_Ctrl <- min(abs(which(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),] == max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),])) - which(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),] <= max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),])/2)))/sqrt(2*log(2))
h_Ctrl <- max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),])*sqrt(2*pi)*sd_Ctrl


# ---> Aufstellen einer Funktion, die die Summe der quadratischen Differenzen zwischen Gaussian Fit und Protein Verteilung in Abhängigkeit von mu berechnet
mu_finder <- function(mu_Ctrl) {
  sum((sapply(seq(1,25,1), function(n) {h_Ctrl*(1/(sd_Ctrl*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_Ctrl)/sd_Ctrl)^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),]))^2)
}

# --> Optimieren der Funktion im Bezug auf den Parameter mu (innerhalb des oben beschriebenen Intervalls), sodass der Output der Funktion minimal wird (also die Summe der quadratischen Abstände). "$minimum" gibt den optimierten Wert für mu aus und dieser wird genutzt, um den alten Schätzwert zu überschreiben. 
mu_Ctrl <- optimise(mu_finder, interval = c(mu_Ctrl-0.5, mu_Ctrl+0.5))$minimum


# --> selbes Spiel bezogen auf die Parameter sd und h

sd_finder <- function(sd_Ctrl) {
  sum((sapply(seq(1,25,1), function(n) {h_Ctrl*(1/(sd_Ctrl*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_Ctrl)/sd_Ctrl)^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),]))^2)
}

sd_Ctrl <- optimise(sd_finder, interval = c(0.8*sd_Ctrl, 1.2*sd_Ctrl))$minimum


h_finder <- function(h_Ctrl) {
  sum((sapply(seq(1,25,1), function(n) {h_Ctrl*(1/(sd_Ctrl*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_Ctrl)/sd_Ctrl)^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),]))^2)
}

h_Ctrl <- optimise(h_finder, interval = c(h_Ctrl-5, h_Ctrl+5))$minimum


# ---> Gleiches Spiel für die RNase Samples von dem Gen
mu_RNase <- unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name),])
sd_RNase <- min(abs(which(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),] == max(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),])) - which(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),] <= max(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),])/2)))/sqrt(2*log(2))
h_RNase <- max(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),])*sqrt(2*pi)*sd_RNase


mu_finder <- function(mu_RNase) {
  sum((sapply(seq(1,25,1), function(n) {h_RNase*(1/(sd_RNase*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_RNase)/sd_RNase)^2)}) - unlist(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),]))^2)
}

mu_RNase <- optimise(mu_finder, interval = c(mu_RNase-0.5, mu_RNase+0.5))$minimum


sd_finder <- function(sd_RNase) {
  sum((sapply(seq(1,25,1), function(n) {h_RNase*(1/(sd_RNase*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_RNase)/sd_RNase)^2)}) - unlist(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),]))^2)
}

sd_RNase <- optimise(sd_finder, interval = c(0.8*sd_RNase, 1.2*sd_RNase))$minimum


h_finder <- function(h_RNase) {
  sum((sapply(seq(1,25,1), function(n) {h_RNase*(1/(sd_RNase*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_RNase)/sd_RNase)^2)}) - unlist(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),]))^2)
}

h_RNase <- optimise(h_finder, interval = c(h_RNase-5, h_RNase+5))$minimum

# ---> Plotten der Protein-Verteilungen und gefitteten Gauß-Kurven.
plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main=paste(paste(gene.name, "(Smoothed and Normalized)")), ylim=c(0,27))

lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),], type="l", lwd=3, col = "red")

curve(h_Ctrl*(1/(sd_Ctrl*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-mu_Ctrl)/sd_Ctrl)^2), add = T, lwd = 3, col = scales::alpha("blue", 0.65))

curve(h_RNase*(1/(sd_RNase*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-mu_RNase)/sd_RNase)^2), add = T, lwd = 3, col = scales::alpha("orange", 0.65))

rm(mu_Ctrl, sd_Ctrl, h_Ctrl, mu_RNase, sd_RNase, h_RNase, gene.name, mu_finder, sd_finder, h_finder)
```


##### 3.3 Gaussian Fitting of the Entire Data Set

We will now do the same calculations we did for the *CTCF_HUMAN* gene for each gene in our data set. The results will be stored in the data frames **Ctrl_Gauss_Fit** and **RNase_Gauss_Fit**. 
Note, that we will also calculate the protein amount under each peak (area under the curve of fitted Gaussian curve) by using the `pnorm` function and scaling the results with **h**. 

**Note:** *This chunk can take up to several minutes to run.*

```{r gauss, include=FALSE}
# ---> Erstellen eines Data.Frames (Ctrl_Gauss_Fit) mit 5 Spalten ("mu", "sd", "h", "prt_amount" und "overlap") und so vielen zeilen, wie es Gene gibt. Füllen des Data.Frames mit NA-values. 
Ctrl_Gauss_Fit = as.data.frame(matrix(rep(NA, nrow(Ctrl_RDeep)*5), ncol = 5))
colnames(Ctrl_Gauss_Fit) = c("mu", "sd", "h", "prt_amount", "overlap")
rownames(Ctrl_Gauss_Fit) = rownames(Ctrl_RDeep)


# --> Schätzung der Werte für mu (Ctrl_Gauss_Fit[,1]), sd (Ctrl_Gauss_Fit[,2]) und h (Ctrl_Gauss_Fit[,3]) mit den oben beschriebenen Berechnungen (bei "3.1 Introduction") für alle Gene 
Ctrl_Gauss_Fit[,1] <- unlist(Ctrl_Mean_Gbl_Max)
Ctrl_Gauss_Fit[,2] <- sapply(seq(1, nrow(Ctrl_RDeep),1), function(k) {min(abs(unlist(Ctrl_Mean_Gbl_Max[k,]) - which(Ctrl_Mean_Smooth_Norm100[k,] <= max(Ctrl_Mean_Smooth_Norm100[k,])/2)))/sqrt(2*log(2))})
Ctrl_Gauss_Fit[,3] <- apply(Ctrl_Mean_Smooth_Norm100, 1, function(x) {max(x)})*sqrt(2*pi)*Ctrl_Gauss_Fit[,2]


# ---> Aufstellen und Optimieren der Funktion, die die Summe der quadratischen Abstände in Abhängigkeit von mu berechnet, über alle Gene und Abspeichern des resultierenden Vektors (enthält die jeweils optimierten Werte für mu über alle Gene) als erste Spalte von "Ctrl_Gauss_Fit". 
Ctrl_Gauss_Fit[,1] <- sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {
  
mu_finder <- function(mu = Ctrl_Gauss_Fit[k,1]) {sum((sapply(seq(1,25,1), function(n) {Ctrl_Gauss_Fit[k,3]*(1/(Ctrl_Gauss_Fit[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu)/Ctrl_Gauss_Fit[k,2])^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[k,]))^2)}

optimise(mu_finder, interval = c(Ctrl_Gauss_Fit[k,1]-0.5, Ctrl_Gauss_Fit[k,1]+0.5))$minimum})


# ---> Wieder gleiches Spiel für sd und h

Ctrl_Gauss_Fit[,2] <- sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {

sd_finder <- function(sd = Ctrl_Gauss_Fit[k,2]) {sum((sapply(seq(1,25,1), function(n) {Ctrl_Gauss_Fit[k,3]*(1/(sd*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Ctrl_Gauss_Fit[k,1])/sd)^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[k,]))^2)}

optimise(sd_finder, interval = c(0.8*Ctrl_Gauss_Fit[k,2], 1.2*Ctrl_Gauss_Fit[k,2]))$minimum})


Ctrl_Gauss_Fit[,3] <- sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {

h_finder <- function(h = Ctrl_Gauss_Fit[k,3]) {sum((sapply(seq(1,25,1), function(n) {h*(1/(Ctrl_Gauss_Fit[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Ctrl_Gauss_Fit[k,1])/Ctrl_Gauss_Fit[k,2])^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[k,]))^2)}

optimise(h_finder, interval = c(Ctrl_Gauss_Fit[k,3]-5, Ctrl_Gauss_Fit[k,3]+5))$minimum})


# --> Berechung des Protein-Anteils unterhalb der Gauß-Kurve im Intervall [0, 25] (Berechnung als pnorm(25) - pnorm(0) multipliziert mit h) über alle Gene und Abspeichern des resultierenden Vektors in der Spalte "prt_amount"
Ctrl_Gauss_Fit[,4] <- sapply(seq(1, nrow(Ctrl_RDeep),1), function(k) {Ctrl_Gauss_Fit[k,3] * (pnorm(25, mean = Ctrl_Gauss_Fit[k,1], sd = Ctrl_Gauss_Fit[k,2]) - pnorm(0, mean = Ctrl_Gauss_Fit[k,1], sd = Ctrl_Gauss_Fit[k,2]))})


# ---> Gleiches Spiel für die RNase Samples
RNase_Gauss_Fit = as.data.frame(matrix(rep(NA, nrow(RNase_RDeep)*5), ncol = 5))
colnames(RNase_Gauss_Fit) = c("mu", "sd", "h", "prt_amount", "overlap")
rownames(RNase_Gauss_Fit) = rownames(RNase_RDeep)

RNase_Gauss_Fit[,1] <- unlist(RNase_Mean_Gbl_Max)
RNase_Gauss_Fit[,2] <- sapply(seq(1, nrow(RNase_RDeep),1), function(k) {min(abs(unlist(RNase_Mean_Gbl_Max[k,]) - which(RNase_Mean_Smooth_Norm100[k,] <= max(RNase_Mean_Smooth_Norm100[k,])/2)))/sqrt(2*log(2))})
RNase_Gauss_Fit[,3] <- apply(RNase_Mean_Smooth_Norm100, 1, function(x) {max(x)})*sqrt(2*pi)*RNase_Gauss_Fit[,2]


RNase_Gauss_Fit[,1] <- sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {
  
mu_finder <- function(mu = RNase_Gauss_Fit[k,1]) {sum((sapply(seq(1,25,1), function(n) {RNase_Gauss_Fit[k,3]*(1/(RNase_Gauss_Fit[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu)/RNase_Gauss_Fit[k,2])^2)}) - unlist(RNase_Mean_Smooth_Norm100[k,]))^2)}

optimise(mu_finder, interval = c(RNase_Gauss_Fit[k,1]-0.5, RNase_Gauss_Fit[k,1]+0.5))$minimum})


RNase_Gauss_Fit[,2] <- sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {

sd_finder <- function(sd = RNase_Gauss_Fit[k,2]) {sum((sapply(seq(1,25,1), function(n) {RNase_Gauss_Fit[k,3]*(1/(sd*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-RNase_Gauss_Fit[k,1])/sd)^2)}) - unlist(RNase_Mean_Smooth_Norm100[k,]))^2)}

optimise(sd_finder, interval = c(0.8*RNase_Gauss_Fit[k,2], 1.2*RNase_Gauss_Fit[k,2]))$minimum})


RNase_Gauss_Fit[,3] <- sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {

h_finder <- function(h = RNase_Gauss_Fit[k,3]) {sum((sapply(seq(1,25,1), function(n) {h*(1/(RNase_Gauss_Fit[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-RNase_Gauss_Fit[k,1])/RNase_Gauss_Fit[k,2])^2)}) - unlist(RNase_Mean_Smooth_Norm100[k,]))^2)}

optimise(h_finder, interval = c(RNase_Gauss_Fit[k,3]-5, RNase_Gauss_Fit[k,3]+5))$minimum})


RNase_Gauss_Fit[,4] <- sapply(seq(1, nrow(RNase_RDeep),1), function(k) {RNase_Gauss_Fit[k,3] * (pnorm(25, mean = RNase_Gauss_Fit[k,1], sd = RNase_Gauss_Fit[k,2]) - pnorm(0, mean = RNase_Gauss_Fit[k,1], sd = RNase_Gauss_Fit[k,2]))})
```


##### 3.4 Calculation of Gaussian Overlap

The overlap will be calculated as the amount of shared area between the area under the curves of the fitted gaussian curves of the Control and RNase samples in the interval [0, 25]. The percental amount can be calculated by dividing the absolute overlap by the mean area under the curves ((protein amount under curve Control + protein amount under curve RNase)/2).

Because there are 3 parameters (**mu**, **sd**, **h**) with each 3 states (**<**, **>**, **=**), there are 3^3 = 27 possible cases how the 2 gaussian curves can be arranged in respect to each other. 
These 27 cases can be reduced to 9 cases ("**1**" = "**Ctrl**" and "**2**" = "**RNase**"; "|" meaning "or"):

  1. sd1 = sd2, mu1 = mu2, h1 = h2
  2. sd1 = sd2, mu1 > mu2, h1 = h2 | h1 < h2 | h1 > h2
  3. sd1 = sd2, mu1 < mu2, h1 = h2 | h1 < h2 | h1 > h2
  4. sd1 = sd2, mu1 = mu2, h1 > h2
  5. sd1 = sd2, mu1 = mu2, h1 < h2
  6. sd1 > sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 = h2 | h1 < h2
  7. sd1 > sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 > h2
  8. sd1 < sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 = h2 | h1 > h2
  9. sd1 < sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 < h2
  
These cases differ in their arrangement of the 2 gaussian curves and their number of points of intersection:

  1. endless number of points of intersection 
  2./3. 1 point of intersection
  4./5. 0 points of intersection (x)
  6./8. 2 points of intersection (x1 and x2)
  7./9. either 2 points of intersection or 0 points of intersection
  
Note, that for the cases 6. - 9. it must also be consider whether or not x1 and x2 are inside or outside the interval [0, 25]. 

The resulting overlap will be both stored in the data.frames **Ctrl_Gauss_Fit** and **RNase_Gauss_Fit** as the column **overlap**. 

``` {r overlap, include=FALSE}
# ---> Erstellen eines Vektors der so viele NA-values enthält, wie es Gene gibt
overlap = rep(NA, nrow(Ctrl_RDeep))


################### 1. sd1 = sd2, mu1 = mu2, h1 = h2

# ---> "gX" ist jeweils ein Vektor, der die Reihen (Genpositionen) enthält, für die die Bedingungen (je nach Fall) wahr sind (überprüft im Data.frame "Ctrl_Gauss_Fit")
g1 = which(Ctrl_Gauss_Fit[, 2] == RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 1] == RNase_Gauss_Fit[, 1] & Ctrl_Gauss_Fit[, 3] == RNase_Gauss_Fit[, 3])

# ---> Nachdem die Reihen identifiziert wurden, die sich dem entsprechenden Fall zuordnen lassen, werden diese Positionen im Vektor "overlap" durch die entsprechende berechnete prozentuale Überschneidung der Gaußkurven ersetzt (im 1. Fall sehr einfach, da beide Gaußkurven identisch sind und somit overlap = 1 ist)
overlap[g1] = 1


################### 2. sd1 = sd2, mu1 > mu2, h1 = h2 | h1 < h2 | h1 > h2

# ---> Gleiches, wie bei g1, nur, dass andere Bedingungen (für 2. Fall) angewendet werden
g2 = which(Ctrl_Gauss_Fit[, 2] == RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 1] > RNase_Gauss_Fit[, 1])

# ---> Berechnung der Schnittpunkte der Gaußkurven über alle Gene, auf die der 2. Fall zutrifft (mathematische Formel per Hand aufgestellt)
x = ((Ctrl_Gauss_Fit[g2, 2])^(2) * log(Ctrl_Gauss_Fit[g2, 3]/RNase_Gauss_Fit[g2, 3]))/(RNase_Gauss_Fit[g2, 1] -  Ctrl_Gauss_Fit[g2, 1]) + (RNase_Gauss_Fit[g2, 1] + Ctrl_Gauss_Fit[g2, 1])/2

# ---> Wieder Ersetzen der Positionen im vektor "overlap" durch die prozentualen Werte für die Überschneidung der Gaußkurven (berechnet mithilfe von pnorm())
overlap[g2] = sapply(seq(1,length(g2),1), function(k) {
  (Ctrl_Gauss_Fit[g2[k], 3] * (pnorm(x[k], mean = Ctrl_Gauss_Fit[g2[k], 1], sd = Ctrl_Gauss_Fit[g2[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[g2[k], 1], sd = Ctrl_Gauss_Fit[g2[k], 2])) + RNase_Gauss_Fit[g2[k], 3] * (pnorm(25, mean = RNase_Gauss_Fit[g2[k], 1], sd = RNase_Gauss_Fit[g2[k], 2]) - pnorm(x[k], mean = RNase_Gauss_Fit[g2[k], 1], sd = RNase_Gauss_Fit[g2[k], 2])))/((Ctrl_Gauss_Fit[g2[k], 4] + RNase_Gauss_Fit[g2[k], 4])/2)
})


# ---> Fast identisches Vorgehen für die Fälle 3 bis 9 (ABER: 1. Wenn die eine Gaußkurve komplett in der anderen liegt (Fälle 4 und 5 und potentiell 7 und 9), wird die prozentuale Überschneidung berechnet, indem die Fläche unter der Gaußkurve, die in der anderen Gaußkurve liegt, dividiert wird durch den Mittelwert beider Flächen unter den Gaußkurven & 2. Sobald sich die Standardabweichungen unterscheiden (Fälle 6 bis 9) gibt es jeweils potentiell 2 Schnittpunkte (diese werden mit der abc-Formel berechnet), zudem muss geschaut werden, ob die Schnittpunkte außerhalb des Intervalls [0, 25] liegen (da sich dann wieder die Berechnung der prozentualen Überschneidung verändert))

################### 3. sd1 = sd2, mu1 < mu2, h1 = h2 | h1 < h2 | h1 > h2
g3 = which(Ctrl_Gauss_Fit[, 2] == RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 1] < RNase_Gauss_Fit[, 1])

x = ((Ctrl_Gauss_Fit[g3, 2])^(2) * log(Ctrl_Gauss_Fit[g3, 3]/RNase_Gauss_Fit[g3, 3]))/(RNase_Gauss_Fit[g3, 1] -  Ctrl_Gauss_Fit[g3, 1]) + (RNase_Gauss_Fit[g3, 1] + Ctrl_Gauss_Fit[g3, 1])/2

overlap[g3] = sapply(seq(1,length(g3),1), function(k) {
  (RNase_Gauss_Fit[g3[k], 3] * (pnorm(x[k], mean = RNase_Gauss_Fit[g3[k], 1], sd = RNase_Gauss_Fit[g3[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[g3[k], 1], sd = RNase_Gauss_Fit[g3[k], 2])) + Ctrl_Gauss_Fit[g3[k], 3] * (pnorm(25, mean = Ctrl_Gauss_Fit[g3[k], 1], sd = Ctrl_Gauss_Fit[g3[k], 2]) - pnorm(x[k], mean = Ctrl_Gauss_Fit[g3[k], 1], sd = Ctrl_Gauss_Fit[g3[k], 2])))/((Ctrl_Gauss_Fit[g3[k], 4] + RNase_Gauss_Fit[g3[k], 4])/2)
})


################### 4. sd1 = sd2, mu1 = mu2, h1 > h2
g4 = which(Ctrl_Gauss_Fit[, 2] == RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 1] == RNase_Gauss_Fit[, 1] & Ctrl_Gauss_Fit[, 3] > RNase_Gauss_Fit[, 3])

overlap[g4] = sapply(seq(1, length(g4), 1), function(k) {
  (RNase_Gauss_Fit[g4[k], 4])/((Ctrl_Gauss_Fit[g4[k], 4] + RNase_Gauss_Fit[g4[k], 4])/2)
})


################### 5. sd1 = sd2, mu1 = mu2, h1 < h2
g5 = which(Ctrl_Gauss_Fit[, 2] == RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 1] == RNase_Gauss_Fit[, 1] & Ctrl_Gauss_Fit[, 3] < RNase_Gauss_Fit[, 3])

overlap[g5] = sapply(seq(1, length(g5), 1), function(k) {
  (Ctrl_Gauss_Fit[g5[k], 4])/((Ctrl_Gauss_Fit[g5[k], 4] + RNase_Gauss_Fit[g5[k], 4])/2)
})


################### 6. sd1 > sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 = h2 | h1 < h2
g6 = which(Ctrl_Gauss_Fit[, 2] > RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 3] <= RNase_Gauss_Fit[, 3])

a = (1/(Ctrl_Gauss_Fit[g6,2])^2 - 1/(RNase_Gauss_Fit[g6,2])^2)
b = 2 * ((RNase_Gauss_Fit[g6,1])/(RNase_Gauss_Fit[g6,2])^2 - (Ctrl_Gauss_Fit[g6,1])/(Ctrl_Gauss_Fit[g6,2])^2)
c = (Ctrl_Gauss_Fit[g6,1]/Ctrl_Gauss_Fit[g6,2])^2 - (RNase_Gauss_Fit[g6,1]/RNase_Gauss_Fit[g6,2])^2 - 2 * log((Ctrl_Gauss_Fit[g6,3] * RNase_Gauss_Fit[g6,2])/(RNase_Gauss_Fit[g6,3] * Ctrl_Gauss_Fit[g6,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g6[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) + pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g6[which(x1 > 25)]
u2 = which(x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g6[which(x2 < 0)]
u2 = which(x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})


################### 7. sd1 > sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 > h2
g7 = which(Ctrl_Gauss_Fit[, 2] > RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 3] > RNase_Gauss_Fit[, 3])

a = (1/(Ctrl_Gauss_Fit[g7,2])^2 - 1/(RNase_Gauss_Fit[g7,2])^2)
b = 2 * ((RNase_Gauss_Fit[g7,1])/(RNase_Gauss_Fit[g7,2])^2 - (Ctrl_Gauss_Fit[g7,1])/(Ctrl_Gauss_Fit[g7,2])^2)
c = (Ctrl_Gauss_Fit[g7,1]/Ctrl_Gauss_Fit[g7,2])^2 - (RNase_Gauss_Fit[g7,1]/RNase_Gauss_Fit[g7,2])^2 - 2 * log((Ctrl_Gauss_Fit[g7,3] * RNase_Gauss_Fit[g7,2])/(RNase_Gauss_Fit[g7,3] * Ctrl_Gauss_Fit[g7,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g7[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) + pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g7[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g7[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g7[which(is.nan(x1))]
u2 = which(is.nan(x1))
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 4])/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})


################### 8. sd1 < sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 = h2 | h1 > h2
g8 = which(Ctrl_Gauss_Fit[, 2] < RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 3] >= RNase_Gauss_Fit[, 3])

a = (1/(Ctrl_Gauss_Fit[g8,2])^2 - 1/(RNase_Gauss_Fit[g8,2])^2)
b = 2 * ((RNase_Gauss_Fit[g8,1])/(RNase_Gauss_Fit[g8,2])^2 - (Ctrl_Gauss_Fit[g8,1])/(Ctrl_Gauss_Fit[g8,2])^2)
c = (Ctrl_Gauss_Fit[g8,1]/Ctrl_Gauss_Fit[g8,2])^2 - (RNase_Gauss_Fit[g8,1]/RNase_Gauss_Fit[g8,2])^2 - 2 * log((Ctrl_Gauss_Fit[g8,3] * RNase_Gauss_Fit[g8,2])/(RNase_Gauss_Fit[g8,3] * Ctrl_Gauss_Fit[g8,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g8[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) + pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g8[which(x1 > 25)]
u2 = which(x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g8[which(x2 < 0)]
u2 = which(x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})


################### 9. sd1 < sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 < h2
g9 = which(Ctrl_Gauss_Fit[, 2] < RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 3] < RNase_Gauss_Fit[, 3])

a = (1/(Ctrl_Gauss_Fit[g9,2])^2 - 1/(RNase_Gauss_Fit[g9,2])^2)
b = 2 * ((RNase_Gauss_Fit[g9,1])/(RNase_Gauss_Fit[g9,2])^2 - (Ctrl_Gauss_Fit[g9,1])/(Ctrl_Gauss_Fit[g9,2])^2)
c = (Ctrl_Gauss_Fit[g9,1]/Ctrl_Gauss_Fit[g9,2])^2 - (RNase_Gauss_Fit[g9,1]/RNase_Gauss_Fit[g9,2])^2 - 2 * log((Ctrl_Gauss_Fit[g9,3] * RNase_Gauss_Fit[g9,2])/(RNase_Gauss_Fit[g9,3] * Ctrl_Gauss_Fit[g9,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g9[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) + pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((RNase_Gauss_Fit[u1[k], 4] + Ctrl_Gauss_Fit[u1[k], 4])/2)
})

u1 = g9[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((RNase_Gauss_Fit[u1[k], 4] + Ctrl_Gauss_Fit[u1[k], 4])/2)
})

u1 = g9[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((RNase_Gauss_Fit[u1[k], 4] + Ctrl_Gauss_Fit[u1[k], 4])/2)
})

u1 = g9[which(is.nan(x1))]
u2 = which(is.nan(x1))
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 4])/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

Ctrl_Gauss_Fit[, 5] = overlap 
RNase_Gauss_Fit[, 5] = overlap

rm(g1, g2, g3, g4, g5, g6, g7, g8, g9, u1, u2, a, b, c, x, x1, x2, overlap)
```


#### 4. Selection Criteria and Identification of RNA-Dependent Proteins

##### 4.1 Summary of Collected Data in one Dataframe

We will now summarize all this collected data (global and local peak positions, gaussian fit and overlap) in one dataframe "**Sel_Crit**" (for *Selection Criteria*). 

```{r}
Sel_Crit = cbind(
  Mean_Gbl_Max,
  Ctrl_Gauss_Fit[, 1:4],
  RNase_Gauss_Fit,
  as.matrix(sapply(seq(1, nrow(Ctrl_Mean_Loc_Max), 1), function(k) {unlist(Ctrl_Mean_Loc_Max[k, which(!is.na(Ctrl_Mean_Loc_Max[k,]))], use.names = F)})),
  as.matrix(sapply(seq(1, nrow(RNase_Mean_Loc_Max), 1), function(k) {unlist(RNase_Mean_Loc_Max[k, which(!is.na(RNase_Mean_Loc_Max[k,]))], use.names = F)}))
  )

colnames(Sel_Crit) <- c("Ctrl_Gbl_Max", "RNase_Gbl_Max", "Ctrl_mu", "Ctrl_sd", "Ctrl_h", "Ctrl_prt_amount", "RNase_mu", "RNase_sd", "RNase_h", "RNase_prt_amount", "overlap", "Ctrl_Loc_Max", "RNase_Loc_Max")
```


#### Extra: Automatic Graph Plotter

Our function `Gene_Plotter` generates plots of protein distributions of specified genes. The default function is:

Gene_Plotter(gene.name, col = c("green", "red", "dodgerblue", "orange"), Ctrl = T, RNase = T, Gbl.Max = T, Loc.Max = T, Gauss = T, grid = T, Type = "Smooth and Norm")

In its most basic form you can just type in the gene name of your gene of interest (e.g. *Gene_Plotter("CTCF_HUMAN")*) and get the normalized and smoothed protein distributions for the Control and RNase samples with global and local peaks and gaussian fitting for each global peak as an output.

But you can also specify the arguments to your liking:

  * **gene.name**: either just the name of a gene or a vector with multiple gene names (e.g. c("CTCF_HUMAN", "NAT10_HUMAN", "RL32_HUMAN")) (note: different genes are plotted separately)
  * **col**: vector specifying the colors used in the plot (col = c(**Control, RNase, Gauss Control, Gauss RNase**))
  * **Ctrl**: logical argument (TRUE or FALSE) that specifies whether or not information regarding the **Control sample** is shown
  * **RNase**: logical argument (TRUE or FALSE) that specifies whether or not information regarding the **RNase sample** is shown
  * **Gbl.Max**: logical argument (TRUE or FALSE) that specifies whether or not **global peaks** are shown
  * **Loc.Max**: logical argument (TRUE or FALSE) that specifies whether or not **local peaks** are shown
  * **Gauss**: logical argument (TRUE or FALSE) that specifies whether or not the **fitted gaussian curves** are shown
  * **grid**: logical argument (TRUE or FALSE) that specifies whether or not an **underlying grid** is shown
  * **Type**: specifies the type of data that is plotted; either as a single data type or a vector with multiple data types (available data types: **"Smooth and Norm", "Norm", "Smooth", "Raw", "Compare"**) (note: different data types are plotted separately)
  
```{r gene plotter, include=FALSE}
## To-Do
  # ggplot Unterstützung

Gene_Plotter <- function(gene.name, col = c("green", "red", "dodgerblue", "orange"), Ctrl = T, RNase = T, Gbl.Max = T, Loc.Max = T, Gauss = T, grid = T, Type = "Smooth and Norm" #, "Norm", "Smooth", "Raw", "Compare"
                          ) {
library(scales)
  
genes = sapply(seq(1, length(gene.name), 1), function(j) { 

plots = sapply(seq(1, length(Type), 1), function (k) {
  
###################### Smoothed and Normalized ######################
if(Type[k] == "Smooth and Norm" & (Ctrl == T | RNase == T)) {
par(mar=c(5, 4, 4, 7), xpd=F)
  
plot(1:25, rep(NA, 25),xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(gene.name[j], "(Smoothed and Normalized)"), ylim=c(0, 1.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}
  )))

if(grid == T) {grid()}

if(Gbl.Max == T & Ctrl == T) {
segments(unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         -1, 
         unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], 
         lwd=3,col=col[1],lty=2)}
  
if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
segments(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         -1, 
         unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         unlist(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[1],lty=2)}

if(Ctrl == T) {    
lines(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = col[1])}
  
if(Gbl.Max == T & RNase == T) {
  segments(unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         -1, 
         unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], 
         lwd=3,col=col[2],lty=3)}
  
if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
segments(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         -1, 
         unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         unlist(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[2],lty=3)}

if(RNase == T) {
lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = col[2])}

if(Gbl.Max == T & Ctrl == T) {
points(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]), ], Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[1], cex=1.5)}

if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
points(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[1], cex=1.2)}

if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
points(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[2], cex=1.2)}

if(Gbl.Max == T & RNase == T) {
points(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]), ], RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]),unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[2], cex=1.5)}

if(Gauss == T & Ctrl == T) {
curve(Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 3]*(1/(Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 1])/Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 2])^2), add = T, lwd = 3, col = alpha(col[3], 0.5))}

if(Gauss == T & RNase == T) {
curve(RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 3]*(1/(RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 1])/RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 2])^2), add = T, lwd = 3, col = alpha(col[4], 0.5))}

par(xpd=T)

legend("topright",inset = c(-0.23,0), 
       legend = c(if(Ctrl == T) {"Control"}, if(RNase == T) {"RNase"}, if(Gauss == T & Ctrl == T) {c("Gauss", "Control")}, if(Gauss == T & RNase == T) {c("Gauss", "RNase")}, if(Gbl.Max == T) {"Global"}, if(Loc.Max == T) {"Local"}), 
       pch = c(if(Ctrl == T) {NA}, if(RNase == T) {NA}, if(Gauss == T & Ctrl == T) {c(NA, NA)}, if(Gauss == T & RNase == T) {c(NA, NA)}, if(Gbl.Max == T) {21}, if(Loc.Max == T) {24}), 
       lty = c(if(Ctrl == T) {1}, if(RNase == T) {1}, if(Gauss == T & Ctrl == T) {c(1, NA)}, if(Gauss == T & RNase == T) {c(1, NA)}, if(Gbl.Max == T) {NA}, if(Loc.Max == T) {NA}), 
       col = c(if(Ctrl == T) {col[1]}, if(RNase == T) {col[2]}, if(Gauss == T & Ctrl == T) {c(alpha(col[3], 0.5), NA)}, if(Gauss == T & RNase == T) {c(alpha(col[4], 0.5), NA)}, if(Gbl.Max == T) { "black"}, if(Loc.Max == T) {"black"}), 
       lwd = c(if(Ctrl == T) {3}, if(RNase == T) {3}, if(Gauss == T & Ctrl == T) {c(3, NA)}, if(Gauss == T & RNase == T) {c(3, NA)},  if(Gbl.Max == T) {1.5}, if(Loc.Max == T) {1.5}))
}
#####################################################################

###################### Normalized ######################
if(Type[k] == "Norm" & (Ctrl == T | RNase == T)) {
  
par(mar=c(5, 4, 4, 7), xpd=F)

plot(1:25, rep(NA, 25),xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(gene.name[j], "(Normalized)"), ylim=c(0, 1.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])})))

if(grid == T) {grid()}

if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
segments(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), -4.3, unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 110, col = col[1], lty = 3, lwd = 3)}

if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
segments(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), -3.4, unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 110, col = col[2], lty = 3, lwd = 3)}

if(Gbl.Max == T & Ctrl == T) {
segments(unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), -4, unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 110, col = col[1], lty = 2, lwd = 3)}

if(Ctrl == T) {
lines(1:25, Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = col[1])}

if(Gbl.Max == T & RNase == T) {
segments(unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), -3, unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 110, col = col[2], lty = 2, lwd = 3)}

if(RNase == T) {
lines(1:25, RNase_Mean_Norm100[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = col[2])}

par(xpd=T)

legend("topright",inset = c(-0.25,0), 
       legend = c(if(Ctrl == T) {"Control"}, if(RNase == T) {"RNase"}, if(Gbl.Max == T) {"Global"}, if(Loc.Max == T) {"Local"}), 
       lty = c(if(Ctrl == T) {1}, if(RNase == T) {1}, if(Gbl.Max == T) {2}, if(Loc.Max == T) {3}), 
       col = c(if(Ctrl == T) {col[1]}, if(RNase == T) {col[2]}, if(Gbl.Max == T) {"grey"}, if(Loc.Max == T) {"grey"}), 
       lwd = c(if(Ctrl == T) {3}, if(RNase == T) {3}, if(Gbl.Max == T) {3}, if(Loc.Max == T) {3}))
}
########################################################

###################### Smoothed ######################
if(Type[k] == "Smooth" & (Ctrl == T | RNase == T)) {
  
par(mar=c(5, 4, 4, 7), xpd=F)
  
plot(1:25, rep(NA, 25),xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(gene.name[j], "(Smoothed)"), ylim=c(0, 1.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])})))

if(grid == T) {grid()}

if(Gbl.Max == T & Ctrl == T) {
segments(unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         -0.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}), 
         unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]), unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], 
         lwd=3,col=col[1],lty=2)}
  
if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
segments(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         -0.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}), 
         unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         unlist(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[1],lty=2)}

if(Ctrl == T) {  
lines(1:25, Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = col[1])}

if(Gbl.Max == T & RNase == T) {
  segments(unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         -0.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}), 
         unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         RNase_Mean_Smooth[which(rownames(RNase_Mean)==gene.name[j]), unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], 
         lwd=3,col=col[2],lty=3)}
  
if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
segments(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         -0.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}), 
         unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         unlist(RNase_Mean_Smooth[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[2],lty=3)}

if(RNase == T) {
lines(1:25, RNase_Mean_Smooth[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = col[2])}

if(Gbl.Max == T & Ctrl == T) {
points(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]), ], Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[1], cex=1.5)}

if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
points(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[1], cex=1.2)}

if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
points(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], RNase_Mean_Smooth[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[2], cex=1.2)}

if(Gbl.Max == T & RNase == T) {
points(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]), ], RNase_Mean_Smooth[which(rownames(RNase_Mean)==gene.name[j]),unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[2], cex=1.5)}

par(xpd=T)

legend("topright",inset = c(-0.23,0), 
       legend = c(if(Ctrl == T) {"Control"}, if(RNase == T) {"RNase"}, if(Gbl.Max == T) {"Global"}, if(Loc.Max == T) {"Local"}), 
       pch = c(if(Ctrl == T) {NA}, if(RNase == T) {NA}, if(Gbl.Max == T) {21}, if(Loc.Max == T) {24}), 
       lty = c(if(Ctrl == T) {1}, if(RNase == T) {1}, if(Gbl.Max == T) {NA}, if(Loc.Max == T) {NA}), 
       col = c(if(Ctrl == T) {col[1]}, if(RNase == T) {col[2]}, if(Gbl.Max == T) { "black"}, if(Loc.Max == T) {"black"}), 
       lwd = c(if(Ctrl == T) {3}, if(RNase == T) {3}, if(Gbl.Max == T) {1.5}, if(Loc.Max == T) {1.5}))
}
######################################################

###################### Raw ######################
if(Type[k] == "Raw" & (Ctrl == T | RNase == T)) {
  
par(mar=c(5, 4, 4, 7), xpd=F)
  
plot(1:25, rep(NA, 25),xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(gene.name[j], "(Raw Data)"), ylim=c(0, 1.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])})))

if(grid == T) {grid()}

if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
segments(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), - 0.07 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 1.2 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), col = col[1], lty = 3, lwd = 3)}

if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
segments(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), -0.8 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 1.2 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), col = col[2], lty = 3, lwd = 3)}

if(Gbl.Max == T & Ctrl == T) {
segments(unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), - 0.93 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 1.2 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), col = col[1], lty = 2, lwd = 3)}

if(Ctrl == T) {  
lines(1:25, Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = col[1])}

if(Gbl.Max == T & RNase == T) {
segments(unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), - 0.7 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 1.2 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), col = col[2], lty = 2, lwd = 3)}

if(RNase == T) {
lines(1:25, RNase_Mean[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = col[2])}

par(xpd=T)

legend("topright",inset = c(-0.25,0), 
       legend = c(if(Ctrl == T) {"Control"}, if(RNase == T) {"RNase"}, if(Gbl.Max == T) {"Global"}, if(Loc.Max == T) {"Local"}), 
       lty = c(if(Ctrl == T) {1}, if(RNase == T) {1}, if(Gbl.Max == T) {2}, if(Loc.Max == T) {3}), 
       col = c(if(Ctrl == T) {col[1]}, if(RNase == T) {col[2]}, if(Gbl.Max == T) {"grey"}, if(Loc.Max == T) {"grey"}), 
       lwd = c(if(Ctrl == T) {3}, if(RNase == T) {3}, if(Gbl.Max == T) {3}, if(Loc.Max == T) {3}))
}
#################################################
  
###################### Compare ######################
if(Type[k] == "Compare" & (Ctrl == T | RNase == T)) {
  
par(mar=c(5, 4, 4, 10), xpd=F)
  
plot(1:25, rep(NA, 25),xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(gene.name[j], "(Norm/Smooth v. Norm)"), ylim=c(0, 1.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(Ctrl == T) {max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}
  )))

if(grid == T) {grid()}

if(Gbl.Max == T & Ctrl == T) {
segments(unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         -1, 
         unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], 
         lwd=3,col=col[1],lty=2)}
  
if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
segments(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         -1, 
         unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         unlist(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[1],lty=2)}

if(Ctrl == T) {
lines(1:25, Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = alpha(col[1], 0.35))

lines(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = col[1])}
  
if(Gbl.Max == T & RNase == T) {
  segments(unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         -1, 
         unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], 
         lwd=3,col=col[2],lty=3)}
  
if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
segments(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         -1, 
         unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         unlist(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[2],lty=3)}

if(RNase == T) {
lines(1:25, RNase_Mean_Norm100[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = alpha(col[2], 0.35))

lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = col[2])}

if(Gbl.Max == T & Ctrl == T) {
points(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]), ], Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[1], cex=1.5)}

if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
points(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[1], cex=1.2)}

if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
points(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[2], cex=1.2)}

if(Gbl.Max == T & RNase == T) {
points(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]), ], RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]),unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[2], cex=1.5)}

if(Gauss == T & Ctrl == T) {
curve(Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 3]*(1/(Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 1])/Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 2])^2), add = T, lwd = 3, col = alpha(col[3], 0.5))}

if(Gauss == T & RNase == T) {
curve(RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 3]*(1/(RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 1])/RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 2])^2), add = T, lwd = 3, col = alpha(col[4], 0.5))}

par(xpd=T)

legend("topright",inset = c(-0.39,0), 
       legend = c(if(Ctrl == T) {c("Control", "(Norm/Smooth)")}, if(RNase == T) {c("RNase", "(Norm/Smooth)")}, if(Ctrl == T) {"Control (Norm)"}, if(RNase == T) {"RNase (Norm)"}, if(Gauss == T & Ctrl == T) {"Gauss Ctrl"}, if(Gauss == T & RNase == T) {"Gauss RNase"}, if(Gbl.Max == T) {"Global"}, if(Loc.Max == T) {"Local"}), 
       pch = c(if(Ctrl == T) {c(NA, NA)}, if(RNase == T) {c(NA, NA)}, if(Ctrl == T) {NA}, if(RNase == T) {NA}, if(Gauss == T & Ctrl == T) {NA}, if(Gauss == T & RNase == T) {NA}, if(Gbl.Max == T) {21}, if(Loc.Max == T) {24}),
       lty = c(if(Ctrl == T) {c(1, NA)}, if(RNase == T) {c(1, NA)}, if(Ctrl == T) {1}, if(RNase == T) {1}, if(Gauss == T & Ctrl == T) {1}, if(Gauss == T & RNase == T) {1}, if(Gbl.Max == T) {NA}, if(Loc.Max == T) {NA}), 
       col = c(if(Ctrl == T) {c(col[1], NA)}, if(RNase == T) {c(col[2], NA)}, if(Ctrl == T) {alpha(col[1], 0.3)}, if(RNase == T) {alpha(col[2], 0.3)}, if(Gauss == T & Ctrl == T) {alpha(col[3], 0.5)}, if(Gauss == T & RNase == T) {alpha(col[4], 0.5)}, if(Gbl.Max == T) { "black"}, if(Loc.Max == T) {"black"}), 
       lwd = c(if(Ctrl == T) {c(3,NA)}, if(RNase == T) {c(3,NA)}, if(Ctrl == T) {3}, if(RNase == T) {3}, if(Gauss == T & Ctrl == T) {3}, if(Gauss == T & RNase == T) {3}, if(Gbl.Max == T) {1.5}, if(Loc.Max == T) {1.5}))
}
#####################################################

})
})
}
```

Let us see if it works!
```{r gene plotter}
Gene_Plotter("CTCF_HUMAN")
```
