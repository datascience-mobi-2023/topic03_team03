---
title: "Topic 3: Proteome-wide Screen for RNA-dependent Proteins; Subtopic 3: HeLa synchronized in Interphase"
author: "Hannah, Johann, Kira, Viktor"
date: "2023-04-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Topic 3: Proteome-wide Screen for RNA-dependent Proteins

### Subtopic 3: HeLa Cells Synchronized in Interphase

First, we will load the dataset containing the mass spectrometry data from HeLa cells synchronized in interphase:

```{r setup, include=FALSE}
RDeeP_HeLa_Interphase = read.csv("https://www.dropbox.com/s/nm9bgsyg7cv6wu1/RDeeP_HeLa_Interphase.csv?dl=1", header=TRUE, row.names = 1, sep = ";")

RDeeP_HeLa_Interphase =  RDeeP_HeLa_Interphase[order(rownames(RDeeP_HeLa_Interphase)),]

head(RDeeP_HeLa_Interphase)
```

#### 1. Data Cleanup and Normalization

Are there any missing values in the dataset?

```{r cleanup, echo=FALSE}
sum(which(is.null(RDeeP_HeLa_Interphase)))
```

Are there any rows that only contain zeros?

```{r cleanup, echo=FALSE}
which(rowSums(RDeeP_HeLa_Interphase)==0)
```


##### 1.1 Split Dataset into Control and RNase

We can also split the dataset into two separate datasets that contain the Control and RNase values:

```{r cleanup, include=FALSE}
Ctrl_RDeep = as.data.frame(
                             # Diese Matrix speichern wir noch als Dataframe
  matrix(
  # Aus dem großen Vektor, den wir mit "unlist" erstellt haben (mit 531450 Einträgen), machen wir eine Matrix mit      7086 Zeilen und 75 Spalten
    
    unlist(
    # Da die untere Schleife einen Dataframe erstellt mit 75 Spalten und drei Zeilen (jede Zelle enthält einen           Vektor, der einer Spalte im originalen Dataframe entspricht), müssen wir aus diesem Dataframe einen einzigen         großen Vektor mit allen Proteineinträgen generieren (das macht der Befehl "unlist")
      
      sapply(seq(0,144,6), function(n) {RDeeP_HeLa_Interphase[,c(1,2,3)+c(n,n,n)]})), 
      # Schleife, die alle Spalten der Control Samples aus dem Dataframe "RDeep_HeLa_Interphase" in Dreier-Grüppchen       (jeweils die drei Replikate pro Fraktion) nacheinander auswählt
    
    nrow=7086, ncol=75))

# Hier werden dem neu erstellten Control Dataframe die Zeilen und Spaltennamen des originalen Dataframes zugeordnet (nutzt die gleiche Schleife zum Auswählen der Control Spalten wie oben)
colnames(Ctrl_RDeep) = as.vector(unlist(sapply(seq(0,144,6), function(n) {colnames(RDeeP_HeLa_Interphase[,c(1,2,3)+c(n,n,n)])})))

rownames(Ctrl_RDeep) = rownames(RDeeP_HeLa_Interphase)

# Analoges Vorgehen für RNase wie Control, nur, dass sich die Startposition zum Auswählen verändert
RNase_RDeep = as.data.frame(matrix(unlist(sapply(seq(0,144,6), function(n) {RDeeP_HeLa_Interphase[,c(4,5,6)+c(n,n,n)]})), nrow=7086, ncol=75))

colnames(RNase_RDeep) = as.vector(unlist(sapply(seq(0,144,6), function(n) {colnames(RDeeP_HeLa_Interphase[,c(4,5,6)+c(n,n,n)])})))

rownames(RNase_RDeep) = rownames(RDeeP_HeLa_Interphase)
```


##### 1.2 NA Values and Zero Rows

```{r cleanup, include=FALSE}
## Überprüfen welche Reihen in den Datasets nur Nullen enthalten

which(rowSums(Ctrl_RDeep)==0)
which(rowSums(RNase_RDeep)==0)

## Löschen der Nullreihen im Controldataset

Ctrl_RDeep <- Ctrl_RDeep[!(rownames(Ctrl_RDeep)%in% c("FHOD3_HUMAN","P210L_HUMAN","PKD1_HUMAN","TGM7_HUMAN","KIF1A_HUMAN")),]

##Löschen der Nullreihen im RNase-Dataset

RNase_RDeep <- RNase_RDeep[!(rownames(RNase_RDeep) %in% c("FHOD3_HUMAN","P210L_HUMAN","PKD1_HUMAN","TGM7_HUMAN", "KIF1A_HUMAN")),]
```


##### 1.3 Pearson Correlation (Reproducibility)

We will now test the reproducibility of the dataset: to do this we will calculate the pearson correlation between the 3 replicates. For each gene and condition this results in 3 correlation coefficients (cor(Rep1, Rep2), cor(Rep2, Rep3), cor(Rep1, Rep3)). The threshold for reproducibility is a correlation coefficient over or equal to 0.95.

If one replicate only consists of zeros, the correlation can not be calculated (sd = 0; 1/sd = NaN). Because these replicates contain very little information, we will replace these replicates with the value NA in our dataframes **Ctrl_RDeep** and **RNase_RDeep** (this applies to 7 replicates).
If two replicates of one gene and condition only contain only zeros, we will remove the entire gene from the dataframes (no proficient analysis with only one replicate for a condition) (this applies to 5 genes).

If all three correlation coefficients for a gene and condition are under 0.95, the entire gene will be removed from the dataframes(this applies to 1335 genes).
If two correlation coefficients are under 0.95, the associated replicate will be replaced with NA values (e.g. if cor(Rep1, Rep2) and cor(Rep2, Rep3) are under 0.95, Rep2 will be replaced) (this applies to 2594 replicates).
If only one correlation coefficient is under 0.95, the replicate is replaced for which the remaining correlation is lower (e.g. if cor(Rep1, Rep2) is under 0.95 and cor(Rep2, Rep3) is bigger than cor(Rep1, Rep3) (both are over 0.95) Rep1 is replaced) (this applies to 2285 replicates). 

```{r cleanup, include=FALSE}
# ---> Die einzelnen Replikate für jedes Gen in der Ctrl-condition werden separat ausgewählt und abgespeichert
Rep1_Ctrl = Ctrl_RDeep[, c(sapply(seq(0,72,3), function(k) {1 + k}))]
Rep2_Ctrl = Ctrl_RDeep[, c(sapply(seq(0,72,3), function(k) {2 + k}))]
Rep3_Ctrl = Ctrl_RDeep[, c(sapply(seq(0,72,3), function(k) {3 + k}))]

# ---> es wird die paarweise Korrelation zwischen den einzelnen Replikaten für jedes Gen berechnet und in einem neuen Dataframe (Ctrl_Cor) abgespeichert 
Ctrl_Cor = as.data.frame(cbind(
      sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {cor(unlist(Rep1_Ctrl[k,]), unlist(Rep2_Ctrl[k,]), method = "pearson")}),
      sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {cor(unlist(Rep2_Ctrl[k,]), unlist(Rep3_Ctrl[k,]), method = "pearson")}),
      sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {cor(unlist(Rep1_Ctrl[k,]), unlist(Rep3_Ctrl[k,]), method = "pearson")})
      ))

# --> Benennung der Reihen und Spalten von "Ctrl_Cor"
rownames(Ctrl_Cor) = rownames(Ctrl_RDeep)
colnames(Ctrl_Cor) = c("cor(Rep1, Rep2)", "cor(Rep2, Rep3)", "cor(Rep1, Rep3)")


# ---> gleiche Berechnungen für die RNase-condition
Rep1_RNase = RNase_RDeep[, c(sapply(seq(0,72,3), function(k) {1 + k}))]
Rep2_RNase = RNase_RDeep[, c(sapply(seq(0,72,3), function(k) {2 + k}))]
Rep3_RNase = RNase_RDeep[, c(sapply(seq(0,72,3), function(k) {3 + k}))]

RNase_Cor = as.data.frame(cbind(
      sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {cor(unlist(Rep1_RNase[k,]), unlist(Rep2_RNase[k,]), method = "pearson")}),
      sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {cor(unlist(Rep2_RNase[k,]), unlist(Rep3_RNase[k,]), method = "pearson")}),
      sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {cor(unlist(Rep1_RNase[k,]), unlist(Rep3_RNase[k,]), method = "pearson")})
      ))

rownames(RNase_Cor) = rownames(RNase_RDeep)
colnames(RNase_Cor) = c("cor(Rep1, Rep2)", "cor(Rep2, Rep3)", "cor(Rep1, Rep3)")


#### Sometimes NA values are produced -> we will test which replicates only contain zeros

#which(rowSums(Rep1_Ctrl)  == 0)
#which(rowSums(Rep2_Ctrl)  == 0)
#which(rowSums(Rep3_Ctrl)  == 0)

#which(rowSums(Rep1_RNase)  == 0)
#which(rowSums(Rep2_RNase)  == 0)
#which(rowSums(Rep3_RNase)  == 0)

### if two replicates of one condition contain only 0 we will remove the entire gene from both conditions (no sufficient data for analysis); the other replicates will be replaced with the value "NA"

# -> Removal of rows 639 (BHMT2_HUMAN) (Rep2_Ctrl & Rep3_Ctrl), 3297 (MAP9_HUMAN) (Rep1_Ctrl & Rep2_Ctrl) 1771 (ECT2_HUMAN) (Rep2_RNase & Rep3_RNase), 2359 (GP161_HUMAN) (Rep2_RNase & Rep3_RNase) and 4209 (PATZ1_HUMAN) (Rep1_RNase & Rep2_RNase)

Ctrl_RDeep <- Ctrl_RDeep[!(rownames(Ctrl_RDeep) %in% c("BHMT2_HUMAN", "MAP9_HUMAN", "ECT2_HUMAN", "GP161_HUMAN", "PATZ1_HUMAN")),]

RNase_RDeep <- RNase_RDeep[!(rownames(RNase_RDeep) %in% c("BHMT2_HUMAN", "MAP9_HUMAN", "ECT2_HUMAN", "GP161_HUMAN", "PATZ1_HUMAN")),]

# ---> Wenn gesamte Gene gelöscht werden, müssen diese jeweils auch aus den Ctrl_Cor und RNase_Cor Datensätzen entfernt werden, da ansonsten später falsche Replikate überschrieben werden würden
Ctrl_Cor <- Ctrl_Cor[!(rownames(Ctrl_Cor) %in% c("BHMT2_HUMAN", "MAP9_HUMAN", "ECT2_HUMAN", "GP161_HUMAN", "PATZ1_HUMAN")),]

RNase_Cor <- RNase_Cor[!(rownames(RNase_Cor) %in% c("BHMT2_HUMAN", "MAP9_HUMAN", "ECT2_HUMAN", "GP161_HUMAN", "PATZ1_HUMAN")),]

# -> Replacement of:
      # Rep1_Ctrl: 664 (BMX_HUMAN), 1470 (DCAF7_HUMAN), 6487 (TSC2_HUMAN)
      # Rep2_RNase: 904 (CCDC9_HUMAN), 1305 (CQ051_HUMAN)
      # Rep3_RNase: 2523 (HEM0_HUMAN), 6491 (TSN3_HUMAN)

Ctrl_RDeep[which(rownames(Ctrl_RDeep) == "BMX_HUMAN"), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Ctrl_RDeep[which(rownames(Ctrl_RDeep) == "DCAF7_HUMAN"), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Ctrl_RDeep[which(rownames(Ctrl_RDeep) == "TSC2_HUMAN"), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

RNase_RDeep[which(rownames(Ctrl_RDeep) == "CCDC9_HUMAN"), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

RNase_RDeep[which(rownames(Ctrl_RDeep) == "CQ051_HUMAN"), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

RNase_RDeep[which(rownames(Ctrl_RDeep) == "HEM0_HUMAN"), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

RNase_RDeep[which(rownames(Ctrl_RDeep) == "TSN3_HUMAN"), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA


# ---> zur vereinfachten Berechnung erstellen wir zwei Matrices, die genau so groß sind wie die Datenframes "Ctrl_Cor" und "RNase_Cor", aber bei jeder Korrelation über oder gleich 0.95 eine "1" enthalten und bei jeder Korrelation unter 0.95 eine "0" enthalten.
Ctrl_Cor_Rep = rep(1, nrow(Ctrl_Cor)*3)
Ctrl_Cor_Rep[which(Ctrl_Cor < 0.95)] = 0
Ctrl_Cor_Rep = matrix(Ctrl_Cor_Rep, ncol = 3)

RNase_Cor_Rep = rep(1, nrow(RNase_Cor)*3)
RNase_Cor_Rep[which(RNase_Cor < 0.95)] = 0
RNase_Cor_Rep = matrix(RNase_Cor_Rep, ncol = 3)

# ---> wir wollen zuerst alle Gene löschen, die in einer condition für alle drei Korrelationen unter 0.95 liegen (werden aber auch separat in den Dataframes "Weird_Ctrl_RDeep" und "Weird_RNase_RDeep" abgespeichert)
# ---> Note: theres a overlap of 250 genes
Gene.Pos = c(which(rowSums(Ctrl_Cor_Rep) == 0)[-which(which(rowSums(Ctrl_Cor_Rep) == 0) %in% which(rowSums(RNase_Cor_Rep) == 0))], which(rowSums(RNase_Cor_Rep) == 0))

Weird_Ctrl_RDeep <- Ctrl_RDeep[which(rowSums(Ctrl_Cor_Rep) == 0 | rowSums(RNase_Cor_Rep) == 0), ]

Weird_RNase_RDeep <- RNase_RDeep[which(rowSums(Ctrl_Cor_Rep) == 0 | rowSums(RNase_Cor_Rep) == 0), ]

Ctrl_RDeep <- Ctrl_RDeep[- Gene.Pos,]

RNase_RDeep <- RNase_RDeep[- Gene.Pos,]

# ---> wie oben auch, müssen die Gene auch aus den "Ctrl_Cor" und "RNase_Cor" Dataframes gelöscht werden, zudem aus den "Ctrl_Cor_Rep" und "RNase_Cor_Rep" Dataframes
Ctrl_Cor <- Ctrl_Cor[- Gene.Pos,]

RNase_Cor <- RNase_Cor[- Gene.Pos,]

Ctrl_Cor_Rep <- Ctrl_Cor_Rep[- Gene.Pos,]

RNase_Cor_Rep <- RNase_Cor_Rep[- Gene.Pos,]


# ---> wir ersetzen nun die Replikate mit NA values, für die gilt, dass ihre beiden Korrelationen unter 0.95 liegen
Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == Ctrl_Cor_Rep[, 3] & rowSums(Ctrl_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == Ctrl_Cor_Rep[, 2] & rowSums(Ctrl_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 2] == Ctrl_Cor_Rep[, 3] & rowSums(Ctrl_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA


RNase_RDeep[which(RNase_Cor_Rep[, 1] == RNase_Cor_Rep[, 3] & rowSums(RNase_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

RNase_RDeep[which(RNase_Cor_Rep[, 1] == RNase_Cor_Rep[, 2] & rowSums(RNase_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

RNase_RDeep[which(RNase_Cor_Rep[, 2] == RNase_Cor_Rep[, 3] & rowSums(RNase_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA


# ---> Zum Schluss ersetzen wir jeweils das Replikat mit NA-values, wenn eine der Korrelationen unter 0.95 liegt und die andere Korrelation kleiner ist als die dritte Korrelation (wenn bspw. cor(Rep1, Rep2) unter 0.95 liegt und cor(Rep2,Rep3) größer als cor(Rep1, Rep3) ist, dann wird Rep1 ersetzt)

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 2] > Ctrl_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 2] < Ctrl_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


Ctrl_RDeep[which(Ctrl_Cor_Rep[, 2] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 1] > Ctrl_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 2] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 1] < Ctrl_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


Ctrl_RDeep[which(Ctrl_Cor_Rep[, 3] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 1] > Ctrl_Cor[, 2]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

Ctrl_RDeep[which(Ctrl_Cor_Rep[, 3] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor[, 1] < Ctrl_Cor[, 2]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA



RNase_RDeep[which(RNase_Cor_Rep[, 1] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 2] > RNase_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

RNase_RDeep[which(RNase_Cor_Rep[, 1] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 2] < RNase_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


RNase_RDeep[which(RNase_Cor_Rep[, 2] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 1] > RNase_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

RNase_RDeep[which(RNase_Cor_Rep[, 2] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 1] < RNase_Cor[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


RNase_RDeep[which(RNase_Cor_Rep[, 3] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 1] > RNase_Cor[, 2]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

RNase_RDeep[which(RNase_Cor_Rep[, 3] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor[, 1] < RNase_Cor[, 2]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA


# ---> Entfernung der erzeugten Variablen
rm(Rep1_Ctrl, Rep2_Ctrl, Rep3_Ctrl, Rep1_RNase, Rep2_RNase, Rep3_RNase, Ctrl_Cor_Rep, RNase_Cor_Rep, Gene.Pos)
```


##### 1.4 Normalize Rows to 100

This will be done for the Control and RNase Datasets separately:

```{r cleanup, include=FALSE}
Ctrl_Norm100 = as.data.frame(sapply(Ctrl_RDeep, function(i){(i/apply(Ctrl_RDeep,1, function(x) {sum(x, na.rm = T)}))*100}))

RNase_Norm100 = as.data.frame(sapply(RNase_RDeep, function(i){(i/apply(RNase_RDeep, 1, function(x) {sum(x, na.rm = T)}))*100}))
```


##### 1.5 Mean of Replicates

###### 1.5.1 Mean Calculation

```{r cleanup, include=FALSE}
Ctrl_Mean = as.data.frame(
            # Abspeichern als Dataframe
  
  sapply(seq(0,72,3), function(i) {
  # Äußere Schleife, die zum Auswählen der drei Replikate pro Fraktion da ist (Startvektor c(1,2,3) wird jeweils um c(3,3,3) erhöht) 
    
    apply(Ctrl_RDeep[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x, na.rm = T)})
    # Innere Schleife, die nachdem die drei Replikate für eine Fraktion ausgewählt wurden, über alle Zeilen dieser       Replikate den Mittelwert berechnet
    
    }))

# Erstellen neuer Spaltennamen für den Ctrl_Mean Dataframe. Der Befehl "paste" erlaubt es, sowohl Text als auch Befehle als ein String zu haben (sep="", bedeutet, dass die Elemente durch kein Leerzeichen voneinander getrennt werden sollen)
colnames(Ctrl_Mean) = paste("Fraction",seq(1,25,1),"_Ctrl_Mean",sep="")

# Analoges Vorgehen für den RNase Dataframe
RNase_Mean = as.data.frame(
  sapply(seq(0,72,3), function(i) {
    apply(RNase_RDeep[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x, na.rm = T)})
    }))

colnames(RNase_Mean) = paste("Fraction",seq(1,25,1),"_RNase_Mean",sep="")
```

###### 1.5.2 Standard Error 

This is primarily done for plotting, hence the standard errors are calculated for the normalized data:

```{r}
Ctrl_Norm100_sd = as.data.frame(t(sapply(seq(1, nrow(Ctrl_RDeep), 1), function(n) {
  sapply(seq(0,72,3), function(i) {
  sd(Ctrl_Norm100[n, c(1,2,3)+c(i,i,i)], na.rm = T)/sqrt(length(which(!is.na(Ctrl_Norm100[n, c(1,2,3)+c(i,i,i)]))))
    })
  })))

rownames(Ctrl_Norm100_sd) = rownames(Ctrl_RDeep)
colnames(Ctrl_Norm100_sd) = paste("Fraction",seq(1,25,1),"_Ctrl_sd",sep="")


RNase_Norm100_sd = as.data.frame(t(sapply(seq(1, nrow(RNase_RDeep), 1), function(n) {
  sapply(seq(0,72,3), function(i) {
  sd(RNase_Norm100[n, c(1,2,3)+c(i,i,i)], na.rm = T)/sqrt(length(which(!is.na(RNase_Norm100[n, c(1,2,3)+c(i,i,i)]))))
    })
  })))

rownames(RNase_Norm100_sd) = rownames(RNase_RDeep)
colnames(RNase_Norm100_sd) = paste("Fraction",seq(1,25,1),"_RNase_sd",sep="")
```


##### 1.6 Data Exploration, First Graphical Representations

###### 1.6.1 Without Normalization
```{r cleanup, echo=FALSE}
plot(1:25, Ctrl_Mean[which(rownames(Ctrl_RDeep)==c("CTCF_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CTCF_HUMAN")
lines(1:25, RNase_Mean[which(rownames(RNase_RDeep)==c("CTCF_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```
```{r cleanup, echo=FALSE}
plot(1:25, Ctrl_Mean[which(rownames(Ctrl_RDeep)==c("CY24A_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CY24A_HUMAN")
lines(1:25, RNase_Mean[which(rownames(RNase_RDeep)==c("CY24A_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```

###### 1.6.2 With Normailzation 
```{r cleanup, include=FALSE}
Ctrl_Mean_Norm100 = as.data.frame(sapply(Ctrl_Mean, function(i){(i/apply(Ctrl_Mean,1,sum))*100}))

RNase_Mean_Norm100 = as.data.frame(sapply(RNase_Mean, function(i){(i/apply(RNase_Mean,1,sum))*100}))
```

```{r cleanup, echo=FALSE}
plot(1:25, Ctrl_Mean_Norm100[which(rownames(Ctrl_RDeep)==c("CTCF_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CTCF_HUMAN Normalized", ylim=c(0,25))
lines(1:25, RNase_Mean_Norm100[which(rownames(RNase_RDeep)==c("CTCF_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```

```{r cleanup, echo=FALSE}
plot(1:25, Ctrl_Mean_Norm100[which(rownames(Ctrl_RDeep)==c("CY24A_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CY24A_HUMAN Normailzed", ylim=c(0,18))
lines(1:25, RNase_Mean_Norm100[which(rownames(RNase_RDeep)==c("CY24A_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```


#### 2. Smoothing and Determination of Maxima

##### 2.1 Smoothing the Data

We will smooth out the Data by calculating the mean value for each fraction within a defined neighborhood (n = 1):

```{r smoothing, include=FALSE}
# n = 1 (left and right neighbor)
Ctrl_Mean_Smooth = 
  # 5: Abspeichern der Matrix als Data.Frame
  as.data.frame(
# 4: Spaltenweises Verbinden der zwei Vektoren und der Matrix | Output: Matrix mit 25 Spalten und 7081 Zeilen 
cbind(
  
  # 2: Mittelwert-Berechnung für die Fraktion 1 (Mittelwert aus der Fraktion 1 und 2) | Output: Vektor mit 7081        Einträgen
  (Ctrl_Mean[,1]+Ctrl_Mean[,2])/2,
      
      # 1: Schleife, die jeweils ein Fenster aus 3 Fraktionen auswählt (startet bei 1,2,3 und endet bei 23,24,25) und       dann mit einer zweiten Schleife den Mittelwert dieser 3 Fraktione über alle Reihen berechnet | Output: Matrix        mit 23 Spalten und 7081 Zeilen, die die Mittelwerte für die Fraktionen 2 bis 24 enthält
      sapply(seq(0,22,1), function(i) {apply(Ctrl_Mean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})}), 
  
  # 3: Mittelwert-Berechnung für die Fraktion 25 (Mittelwert aus der Fraktion 24 und 25) | Output: Vektor mit 7081     Einträgen
  (Ctrl_Mean[,24]+Ctrl_Mean[,25])/2)
)

colnames(Ctrl_Mean_Smooth) = colnames(Ctrl_Mean)


# Gleicher Code für RNase
RNase_Mean_Smooth = 
  as.data.frame(
cbind((RNase_Mean[,1]+RNase_Mean[,2])/2,
      sapply(seq(0,22,1), function(i) {apply(RNase_Mean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})}), 
      (RNase_Mean[,24]+RNase_Mean[,25])/2)
)

colnames(RNase_Mean_Smooth) = colnames(RNase_Mean)
```

##### 2.2 Normalization of Smoothed Data

We will now normalize this data in a way, that the sum of each row will equal 100:

```{r smoothing, include=FALSE}
Ctrl_Mean_Smooth_Norm100 = as.data.frame(sapply(Ctrl_Mean_Smooth, function(i){(i/apply(Ctrl_Mean_Smooth,1,sum))*100}))

RNase_Mean_Smooth_Norm100 = as.data.frame(sapply(RNase_Mean_Smooth, function(i){(i/apply(RNase_Mean_Smooth,1,sum))*100}))
```

Now let us explore how this Smoothing and Normalization effects the data distribution:
```{r smoothing, echo=FALSE}
plot(1:25, Ctrl_Mean [which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CTCF_HUMAN", ylim=c(0,2200000))
lines(1:25, RNase_Mean[which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CTCF_HUMAN (Smoothed)", ylim=c(0,2200000))
lines(1:25, RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CTCF_HUMAN (Smoothed and Normalized)", ylim=c(0,22))
lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("CTCF_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```

```{r smoothing, echo=FALSE}
plot(1:25, Ctrl_Mean [which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CY24A_HUMAN", ylim=c(0,950000))
lines(1:25, RNase_Mean[which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CY24A_HUMAN (Smoothed)", ylim=c(0,950000))
lines(1:25, RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="CY24A_HUMAN (Smoothed and Normalized)", ylim=c(0,22))
lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("CY24A_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```
```{r smoothing, echo=FALSE}
plot(1:25, Ctrl_Mean [which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="ABCA1_HUMAN", ylim=c(0,220000))
lines(1:25, RNase_Mean[which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="ABCA1_HUMAN (Smoothed)", ylim=c(0,220000))
lines(1:25, RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main="ABCA1_HUMAN (Smoothed and Normalized)", ylim=c(0,38))
lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==c("ABCA1_HUMAN")),], type="l",lwd=3,col="red")
grid()
legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
```


##### 2.3 Determination of Global and Local Maxima

###### 2.3.1 Global Maxima

Let us first start with the global maxima: we want a code that tells us the global maximum fraction position for each gene and condition (Control and RNase).
We can calculate the global maxima by asking the question: "Which Protein Fractions contains the maximum protein amount?"
```{r global max, include=FALSE}
Ctrl_Mean_Gbl_Max = 
  
  # 2: Abspeichern als Matrix (besser für weiter Berechnungen (siehe unten))
  as.matrix(
    
    # 1: Schleife, die für jedes Gen des Datensatzes "Ctrl_Mean_Smooth_Norm100" bestimmt, welche Fraktion den           größten Protein-Anteil enthält | Output: Liste mit allen Fraktionen mit größtem Protein-Anteil pro Gen             (Problem: manchmal mehrere Einträge für ein Gen (siehe Plot von Gen ABCA1_HUMAN oben))
    sapply(seq(1, nrow(Ctrl_RDeep), 1), function(i) {which(Ctrl_Mean_Smooth_Norm100[i,] == max(Ctrl_Mean_Smooth_Norm100[i,]))}))


## If 2 fraction positions contain the maximum protein amount, we determine the mean of these 2 fraction positions

# 2: Wir rufen die Fraction Positions für die Zeilen ab, die genau zwei globale Maxima enthalten | Output: Liste mit den globalen Maxima für alle Gene
Ctrl_Mean_Gbl_Max[
  
  # 1: Für jedes Gen wird geschaut, wie viele Einträge es für die globalen Maxima gibt und verglichen, ob es genau 2   Einträge gibt. "which()" gibt dann die Gene aus, für die diese Bedingung TRUE ist. | Output: vektor aller Zeilen,    für die Bedingung stimmt.
  which(
    sapply(seq(1,nrow(Ctrl_RDeep),1),function(i) {
      length(which(Ctrl_Mean_Smooth_Norm100[i,] == max(Ctrl_Mean_Smooth_Norm100[i,])))}) == 2), 
     
     # 3: Wir ersetzen jede Zeile, die 2 Einträge besitzt, mit dem Mittelwert aus diesen 2 Einträgen
  1] = 
  apply(matrix(unlist(Ctrl_Mean_Gbl_Max[which(sapply(seq(1,nrow(Ctrl_RDeep),1),function(i) {length(which(Ctrl_Mean_Smooth_Norm100[i,] == max(Ctrl_Mean_Smooth_Norm100[i,]) ))}) == 2),1]), ncol=2, byrow=T), 1, function(x) {mean(x)})

## If 3 fraction positions contain the maximum protein amount, we determine the mean of these 3 fraction positions
Ctrl_Mean_Gbl_Max[which(sapply(seq(1,nrow(Ctrl_RDeep),1),function(i) {length(which(Ctrl_Mean_Smooth_Norm100[i,] == max(Ctrl_Mean_Smooth_Norm100[i,]) ))}) == 3),1] = apply(matrix(unlist(Ctrl_Mean_Gbl_Max[which(sapply(seq(1,nrow(Ctrl_RDeep),1),function(i) {length(which(Ctrl_Mean_Smooth_Norm100[i,] == max(Ctrl_Mean_Smooth_Norm100[i,]) ))}) == 3),1]), ncol=3, byrow=T), 1, function(x) {mean(x)})

Ctrl_Mean_Gbl_Max = as.data.frame(unlist(Ctrl_Mean_Gbl_Max))

colnames(Ctrl_Mean_Gbl_Max) = c("Ctrl_Gbl_Max")
rownames(Ctrl_Mean_Gbl_Max) = rownames(Ctrl_Mean_Smooth_Norm100)


RNase_Mean_Gbl_Max = as.matrix(sapply(seq(1,nrow(RNase_RDeep),1),function(i) {which(RNase_Mean_Smooth_Norm100[i,] == max(RNase_Mean_Smooth_Norm100[i,]))}))

RNase_Mean_Gbl_Max[which(sapply(seq(1,nrow(RNase_RDeep),1),function(i) {length(which(RNase_Mean_Smooth_Norm100[i,] == max(RNase_Mean_Smooth_Norm100[i,]) ))}) == 2),1] = apply(matrix(unlist(RNase_Mean_Gbl_Max[which(sapply(seq(1,nrow(RNase_RDeep),1),function(i) {length(which(RNase_Mean_Smooth_Norm100[i,] == max(RNase_Mean_Smooth_Norm100[i,]) ))}) == 2),1]), ncol=2, byrow=T), 1, function(x) {mean(x)})

RNase_Mean_Gbl_Max[which(sapply(seq(1,nrow(RNase_RDeep),1),function(i) {length(which(RNase_Mean_Smooth_Norm100[i,] == max(RNase_Mean_Smooth_Norm100[i,]) ))}) == 3),1] = apply(matrix(unlist(RNase_Mean_Gbl_Max[which(sapply(seq(1,nrow(RNase_RDeep),1),function(i) {length(which(RNase_Mean_Smooth_Norm100[i,] == max(RNase_Mean_Smooth_Norm100[i,]) ))}) == 3),1]), ncol=3, byrow=T), 1, function(x) {mean(x)})

RNase_Mean_Gbl_Max = as.data.frame(unlist(RNase_Mean_Gbl_Max))

colnames(RNase_Mean_Gbl_Max) = c("RNase_Gbl_Max")
rownames(RNase_Mean_Gbl_Max) = rownames(RNase_Mean_Smooth_Norm100)

Mean_Gbl_Max = cbind(Ctrl_Mean_Gbl_Max, RNase_Mean_Gbl_Max)

# length(which(unlist(Mean_Gbl_Max[,1]) == unlist(Mean_Gbl_Max[,2])))
# length(which(abs(unlist(Mean_Gbl_Max[,1])-unlist(Mean_Gbl_Max[,2])) >= 2))
```


Let us see if it worked!
```{r global max, echo=FALSE}
gene.name=c("CTCF_HUMAN")

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main=paste(paste(gene.name, "(Smoothed and Normalized)")), ylim=c(0,25))

abline(v=Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name),],lwd=3,col="green",lty=2)

lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),], type="l",lwd=3,col="red")

abline(v=RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name),],lwd=3,col="red",lty=3)

grid()

legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
rm(gene.name)
```


```{r global max, echo=FALSE}
gene.name=c("CY24A_HUMAN")

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main=paste(paste(gene.name, "(Smoothed and Normalized)")), ylim=c(0,20))

abline(v=Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name),],lwd=3,col="green",lty=2)

lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),], type="l",lwd=3,col="red")

abline(v=RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name),],lwd=3,col="red",lty=3)

grid()

legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)
rm(gene.name)
```

But Smoothing sometimes changes the position of the maxima:
```{r global max, echo=FALSE}
gene.name="XXLT1_HUMAN"

plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),],type="l",lwd=3,col="green",xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(paste(gene.name, "(Smoothed and Normalized)")), ylim=c(0,max(max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),]), max(RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),]))+3))

abline(v=Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name),],lwd=3,col="green",lty=3)

lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),], type="l",lwd=3,col="red")

abline(v=RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name),],lwd=3,col="red",lty=3)

grid()

legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)


plot(1:25, Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name),],type="l",lwd=3,col="green",xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(paste(gene.name, "(Normalized)")), ylim=c(0,max(max(Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name),]), max(RNase_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name),]))+3))

abline(v=Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name),],lwd=3,col="green",lty=3)

lines(1:25, RNase_Mean_Norm100[which(rownames(RNase_Mean)==gene.name),], type="l",lwd=3,col="red")

abline(v=RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name),],lwd=3,col="red",lty=3)

grid()

legend("topright",legend=c("Control","RNase"),col=c("green","red"),bg="white",lwd=2)

rm(gene.name)
```

###### 2.3.2 Local Maxima

We will now calculate the fraction positions of all local maxima for every gene and condition. But what defines a local maximum? 
We will look at the protein amount for a neighborhood of n = 2 for each fraction positions (for local maxima at the edges we will use slightly different criteria):

X X [X] X X 

We will then compare the protein amount in that fraction position to the protein amount for the 4 fraction positions around that fraction position and ask the question: Is the protein amount in that fraction greater or equal to its neighborhood? If TRUE then we define that fraction position as a local maximum.
```{r local max, include=FALSE}
# ---> Erstellen eines Data.Frames mit 25 Spalten und so vielen Zeilen, wie es Gene gibt (nur NA-values)
Ctrl_Mean_Loc_Max = as.data.frame(matrix(NA, nrow = nrow(Ctrl_RDeep), ncol = 25))

# ---> Bestimmung der Fraction Positions für alle lokalen Maxima (in den Control Samples), indem jeweils in einem 5 Fraktion-Window berechnet wird, welche Position den größten Protein Anteil beinhaltet und ob diese Position der mittleren Position entspricht
Fra.Pos = sapply(seq(0,20,1), function(i) {which(seq(2*nrow(Ctrl_RDeep)+1,3*nrow(Ctrl_RDeep),1) %in% which(apply(Ctrl_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) == Ctrl_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)] & apply(Ctrl_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) != 0))})

# ---> Einspeichern der lokalen Maxima im Data.Frame "Ctrl_Mean_Loc_Max" (erstellt in erster Zeile des Chunks), indem pro Gen der NA-value jeder Fraktion, die ein lokales Maximum ist, durch den Wert der Fraktion ersetzt wird (also, wenn in Gen 1 Fraktion 5 ein lokales Maximum ist, wird der Wert für Fraktion 5 in Gen 1 (NA) mit "5" ersetzt) 
Ctrl_Mean_Loc_Max[, 3:23] = sapply(seq(1,21,1), function(n) {
  replace(
        Ctrl_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        n+2)})

# ---> Benennung der Zeilen (Gennamen) und Spalten (Fraktionen)
rownames(Ctrl_Mean_Loc_Max) = rownames(Ctrl_Mean)
colnames(Ctrl_Mean_Loc_Max) = colnames(Ctrl_Mean)


# ---> Gleicher Code für die RNase Samples
RNase_Mean_Loc_Max = as.data.frame(matrix(NA, nrow = nrow(RNase_RDeep), ncol = 25))

Fra.Pos = sapply(seq(0,20,1), function(i) {which(seq(2*nrow(RNase_RDeep)+1,3*nrow(RNase_RDeep),1) %in% which(apply(RNase_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) == RNase_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)] & apply(RNase_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) != 0))})

RNase_Mean_Loc_Max[, 3:23] = sapply(seq(1,21,1), function(n) {
  replace(
        RNase_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        n+2)})

rownames(RNase_Mean_Loc_Max) = rownames(RNase_Mean)
colnames(RNase_Mean_Loc_Max) = colnames(RNase_Mean)


## Edge Cases:

# ---> Da wir eine Maske mit n = 2 anwenden, können wir mit dieser Methode nur die Fraktionen 3 bis 23 auf lokale Maxima überprüfen. Damit Fraktion 1 bzw. 25 ein lokales Maximum sind, müssen sie größer sein, als die Fraktionen 2 und 3 bzw. 24 und 23. Damit Fraktion 2 bzw. 24 ein lokales Maximum sind, müssen sie größer sein, als die Fraktionen 1, 3 und 4 bzw. 25, 23 und 22.  

# Fraction 1
Ctrl_Mean_Loc_Max[which(Ctrl_Mean_Smooth_Norm100[,1] >= Ctrl_Mean_Smooth_Norm100[,2] & Ctrl_Mean_Smooth_Norm100[,1] >= Ctrl_Mean_Smooth_Norm100[,3] & Ctrl_Mean_Smooth_Norm100[,1] != 0),1] = 1

RNase_Mean_Loc_Max[which(RNase_Mean_Smooth_Norm100[,1] >= RNase_Mean_Smooth_Norm100[,2] & RNase_Mean_Smooth_Norm100[,1] >= RNase_Mean_Smooth_Norm100[,3] & RNase_Mean_Smooth_Norm100[,1] != 0),1] = 1

# Fraction 2
Ctrl_Mean_Loc_Max[which(Ctrl_Mean_Smooth_Norm100[,2] >= Ctrl_Mean_Smooth_Norm100[,3] & Ctrl_Mean_Smooth_Norm100[,2] >= Ctrl_Mean_Smooth_Norm100[,4] & Ctrl_Mean_Smooth_Norm100[,2] >= Ctrl_Mean_Smooth_Norm100[,1] & Ctrl_Mean_Smooth_Norm100[,1] != 0), 2] = 2

RNase_Mean_Loc_Max[which(RNase_Mean_Smooth_Norm100[,2] >= RNase_Mean_Smooth_Norm100[,3] & RNase_Mean_Smooth_Norm100[,2] >= RNase_Mean_Smooth_Norm100[,4] & RNase_Mean_Smooth_Norm100[,2] >= RNase_Mean_Smooth_Norm100[,1] & RNase_Mean_Smooth_Norm100[,1] != 0), 2] = 2

# Fraction 25
Ctrl_Mean_Loc_Max[which(Ctrl_Mean_Smooth_Norm100[,25] >= Ctrl_Mean_Smooth_Norm100[,24] & Ctrl_Mean_Smooth_Norm100[,25] >= Ctrl_Mean_Smooth_Norm100[,23] & Ctrl_Mean_Smooth_Norm100[,25] != 0), 25] = 25

RNase_Mean_Loc_Max[which(RNase_Mean_Smooth_Norm100[,25] >= RNase_Mean_Smooth_Norm100[,24] & RNase_Mean_Smooth_Norm100[,25] >= RNase_Mean_Smooth_Norm100[,23] & RNase_Mean_Smooth_Norm100[,25] != 0), 25] = 25

# Fraction 24
Ctrl_Mean_Loc_Max[which(Ctrl_Mean_Smooth_Norm100[,24] >= Ctrl_Mean_Smooth_Norm100[,23] & Ctrl_Mean_Smooth_Norm100[,24] >= Ctrl_Mean_Smooth_Norm100[,22] & Ctrl_Mean_Smooth_Norm100[,24] >= Ctrl_Mean_Smooth_Norm100[,25] & Ctrl_Mean_Smooth_Norm100[,24] != 0), 24] = 24

RNase_Mean_Loc_Max[which(RNase_Mean_Smooth_Norm100[,24] >= RNase_Mean_Smooth_Norm100[,23] & RNase_Mean_Smooth_Norm100[,24] >= RNase_Mean_Smooth_Norm100[,22] & RNase_Mean_Smooth_Norm100[,24] >= RNase_Mean_Smooth_Norm100[,25] & RNase_Mean_Smooth_Norm100[,24] != 0), 24] = 24


## Removal of Global Maxima in Local Maxima Datasets (also removes all double and triple global maxima!!!)

# ---> Die Methode, die wir zum Finden der lokalen Maxima bisher angewendet haben, gibt uns als Output natürlich auch die Positionen der globalen Maxima. Diese wollen wir nun mit der Hilfe einer Maske (Ctrl_Mask bzw. RNase_Mask) entfernen: diese hat die gleiche Größe, wie der Data.frame Ctrl_Mean_Loc_Max bzw. RNase_Mean_Loc_Max (# Gene x 25) enthält aber nur den Wert "1", außer an den Stellen, an denen es globale Maxima gibt (dort ist der Wert NA vermerkt). Multiplizieren wir nun die Maske mit dem Data.frame, werden alle globalen Peaks gelöscht (durch NA ersetzt), während die lokalen Peaks erhalten bleiben (NA * any value = NA, 1 * any value = any value). 

Ctrl_Mask = matrix(1, nrow = nrow(Ctrl_RDeep)*25, ncol = 1)

Ctrl_Mask[which(apply(Ctrl_Mean_Smooth_Norm100, 1, function(x) {max(x)}) == Ctrl_Mean_Smooth_Norm100)] = NA

Ctrl_Mask = as.data.frame(matrix(unlist(Ctrl_Mask), nrow=nrow(Ctrl_RDeep), ncol=25))

Ctrl_Mean_Loc_Max = Ctrl_Mean_Loc_Max * Ctrl_Mask

rm(Ctrl_Mask)


RNase_Mask = matrix(1, nrow = nrow(RNase_RDeep)*25, ncol = 1)

RNase_Mask[which(apply(RNase_Mean_Smooth_Norm100, 1, function(x) {max(x)}) == RNase_Mean_Smooth_Norm100)] = NA

RNase_Mask = as.data.frame(matrix(unlist(RNase_Mask), nrow=nrow(RNase_RDeep), ncol=25))

RNase_Mean_Loc_Max = RNase_Mean_Loc_Max * RNase_Mask

rm(RNase_Mask)


### Combine double and triple peaks into single peaks

# ---> Wie bei der Bestimmung der globalen Peaks auch, gibt es auch bei den lokalen Peaks manchmal Fälle, in denen 2 oder 3 peaks direkt nebeneinander vorkommen. Diese wollen wir nun jeweils durch den Mittelwert der Positionen der peaks ersetzen (bei einem double peak wird der Mittelwert in die linke der beiden Fraktionen notiert und der rechte peak durch NA ersetzt; und bei einem triple peak werden die Fraction-positions links und rechts von mittleren peak durch NA ersetzt).

## Double peaks
Fra.Pos = sapply(seq(0,21,1), function(i) {which(!(is.na(Ctrl_Mean_Loc_Max[,c(2)+c(i)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(3)+c(i)])) & is.na(Ctrl_Mean_Loc_Max[,c(1)+c(i)]) & is.na(Ctrl_Mean_Loc_Max[,c(4)+c(i)]))})

Ctrl_Mean_Loc_Max[, 2:23] = sapply(seq(1,22,1), function(n) {
  replace(
        Ctrl_Mean_Loc_Max[, n+1], 
        Fra.Pos[[n]], 
        n+1.5)})

Ctrl_Mean_Loc_Max[, 3:24] = sapply(seq(1,22,1), function(n) {
  replace(
        Ctrl_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        NA)})


## Edge Cases (not necessary in this case)

# ---> Bei den double peaks müssten wir noch Fraktion 1 & 2 und 24 & 25 gesondert betrachen, da wir diese vorher nicht überprüfen können (der Code überprüft jeweils, ob in der aktuell ausgewählten Position und der Position rechts davon ein Wert vorhanden ist; um die Erkennung von triple peaks zu vermeiden, muss aber auch überprüft werden, ob in der Fraktion links und zweifach rechts von der aktuellen Position keine Werte (also NA-values) vorhanden sind). Diese Edge cases treten aber nicht auf und somit ist der Code redundant.

# Fra.Pos = which(!(is.na(Ctrl_Mean_Loc_Max[,c(1)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(2)])) & !(!(is.na(Ctrl_Mean_Loc_Max[,c(1)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(2)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(3)]))))

# Ctrl_Mean_Loc_Max[Fra.Pos[[1]],1]=1.5
# Ctrl_Mean_Loc_Max[Fra.Pos[[1]],2]=NA

# Fra.Pos = which(!(is.na(Ctrl_Mean_Loc_Max[,c(24)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(25)])) & !(!(is.na(Ctrl_Mean_Loc_Max[,c(23)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(24)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(25)]))))

# Ctrl_Mean_Loc_Max[Fra.Pos[[1]],24]=24.5
# Ctrl_Mean_Loc_Max[Fra.Pos[[1]],25]=NA


Fra.Pos = sapply(seq(0,21,1), function(i) {which(!(is.na(RNase_Mean_Loc_Max[,c(2)+c(i)])) & !(is.na(RNase_Mean_Loc_Max[,c(3)+c(i)])) & is.na(RNase_Mean_Loc_Max[,c(1)+c(i)]) & is.na(RNase_Mean_Loc_Max[,c(4)+c(i)]))})

RNase_Mean_Loc_Max[, 2:23] = sapply(seq(1,22,1), function(n) {
  replace(
        RNase_Mean_Loc_Max[, n+1], 
        Fra.Pos[[n]], 
        n+1.5)})

RNase_Mean_Loc_Max[, 3:24] = sapply(seq(1,22,1), function(n) {
  replace(
        RNase_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        NA)})

# Edge Cases (not necessary in this case)

# Fra.Pos = which(!(is.na(RNase_Mean_Loc_Max[,c(1)])) & !(is.na(RNase_Mean_Loc_Max[,c(2)])) & !(!(is.na(RNase_Mean_Loc_Max[,c(1)])) & !(is.na(RNase_Mean_Loc_Max[,c(2)])) & !(is.na(RNase_Mean_Loc_Max[,c(3)]))))

# RNase_Mean_Loc_Max[Fra.Pos[[1]],1]=1.5
# RNase_Mean_Loc_Max[Fra.Pos[[1]],2]=NA

# Fra.Pos = which(!(is.na(RNase_Mean_Loc_Max[,c(24)])) & !(is.na(RNase_Mean_Loc_Max[,c(25)])) & !(!(is.na(RNase_Mean_Loc_Max[,c(23)])) & !(is.na(RNase_Mean_Loc_Max[,c(24)])) & !(is.na(RNase_Mean_Loc_Max[,c(25)]))))

# RNase_Mean_Loc_Max[Fra.Pos[[1]],24]=24.5
# RNase_Mean_Loc_Max[Fra.Pos[[1]],25]=NA



# Triple peaks
Fra.Pos = sapply(seq(0,22,1), function(i) {which(!(is.na(Ctrl_Mean_Loc_Max[,c(1)+c(i)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(2)+c(i)])) & !(is.na(Ctrl_Mean_Loc_Max[,c(3)+c(i)])))})

Ctrl_Mean_Loc_Max[, 1:23] = sapply(seq(1,23,1), function(n) {
  replace(
        Ctrl_Mean_Loc_Max[, n], 
        Fra.Pos[[n]], 
        NA)})

Ctrl_Mean_Loc_Max[, 3:25] = sapply(seq(1,23,1), function(n) {
  replace(
        Ctrl_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        NA)})


Fra.Pos = sapply(seq(0,22,1), function(i) {which(!(is.na(RNase_Mean_Loc_Max[,c(1)+c(i)])) & !(is.na(RNase_Mean_Loc_Max[,c(2)+c(i)])) & !(is.na(RNase_Mean_Loc_Max[,c(3)+c(i)])))})

RNase_Mean_Loc_Max[, 1:23] = sapply(seq(1,23,1), function(n) {
  replace(
        RNase_Mean_Loc_Max[, n], 
        Fra.Pos[[n]], 
        NA)})

RNase_Mean_Loc_Max[, 3:25] = sapply(seq(1,23,1), function(n) {
  replace(
        RNase_Mean_Loc_Max[, n+2], 
        Fra.Pos[[n]], 
        NA)})


rm(Fra.Pos)
```


#### 3. Gaussian Fitting

##### 3.1 Introduction

A Normal Distribution can be described as:

f(x) = h/(sd * sqrt(2 * pi)) * exp^(-1/2 * ((x - mu)/sd)^2)

with **h** the **height**, **sd** the **standard deviation** and **mu** the **mean** of the distribution.

To fit a Gaussian curve to each global peak per gene and condition, we want to find the optimal values for these 3 parameters for each global peak per gene and condition. 
We define an optimal value as a value that minimizes the sum of squares of the differences between the Gaussian curve and the smoothed and normalized protein distribution.

But first we will approximate each parameter with the following values:

  * mu <- Fraction Position of Global Peak 
  * sd <- Half width at half maximum (HWHM)/sqrt(2 * ln(2)) (note: FWHM = 2 * sqrt(2 * ln(2))) * sd)
  * h <- Maximum Protein Amount * (sd * sqrt(2 * pi))

Now we can define 3 separate functions (`mu_finder`, `sd_finder`, `h_finder`) that calculate the sum of squares for each parameter and use the `optimise` function to tweak each parameter so that the sum of squares is minimized. Note that the order in which we will optimize these parameters matters, because depending on which parameters where optimized first the optimized values can differ. Based on experimentation we decided to first optimize **mu**, then **sd** and lastly **h**. 

Furthermore, we restrict the optimization to a specified interval around the first approximations of the parameters. This is needed because we just want to fit the Gaussian curve to the local region around each global peak. Because the protein distribution is mostly not normally distributed, too much freedom in the optimization process could lead to skewed results. 
We define these intervals as:

  * mu: [mu - 0.5, mu + 0.5]
  * sd: [sd - 0.2 * sd, sd + 0.2 * sd]
  * h:  [h - 5, h + 5]
  
Lastly, we calculate the protein amount under each gaussian curve (**prt_amount**) in the interval [0, 25]. 


##### 3.2 Proof-of-Concept

To test if this method works, we will try to fit Gaussian curves to the global peaks of the Control and RNase distributions of the *CTCF_HUMAN* gene:

```{r gauss, echo=FALSE}
# ---> Wir wählen ein beliebiges Gen aus
gene.name=c("CTCF_HUMAN")

# ---> Schätzung der Werte für mu, sd und h anhand der oben beschriebenen Berechnungen
mu_Ctrl <- unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name),])
sd_Ctrl <- min(abs(which(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),] == max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),])) - which(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),] <= max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),])/2)))/sqrt(2*log(2))
h_Ctrl <- max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),])*sqrt(2*pi)*sd_Ctrl


# ---> Aufstellen einer Funktion, die die Summe der quadratischen Differenzen zwischen Gaussian Fit und Protein Verteilung in Abhängigkeit von mu berechnet
mu_finder <- function(mu_Ctrl) {
  sum((sapply(seq(1,25,1), function(n) {h_Ctrl*(1/(sd_Ctrl*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_Ctrl)/sd_Ctrl)^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),]))^2)
}

# --> Optimieren der Funktion im Bezug auf den Parameter mu (innerhalb des oben beschriebenen Intervalls), sodass der Output der Funktion minimal wird (also die Summe der quadratischen Abstände). "$minimum" gibt den optimierten Wert für mu aus und dieser wird genutzt, um den alten Schätzwert zu überschreiben. 
mu_Ctrl_opt <- optimise(mu_finder, interval = c(mu_Ctrl-0.5, mu_Ctrl+0.5))$minimum


# --> selbes Spiel bezogen auf die Parameter sd und h

sd_finder <- function(sd_Ctrl) {
  sum((sapply(seq(1,25,1), function(n) {h_Ctrl*(1/(sd_Ctrl*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_Ctrl)/sd_Ctrl)^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),]))^2)
}

sd_Ctrl_opt <- optimise(sd_finder, interval = c(0.8*sd_Ctrl, 1.2*sd_Ctrl))$minimum


h_finder <- function(h_Ctrl) {
  sum((sapply(seq(1,25,1), function(n) {h_Ctrl*(1/(sd_Ctrl*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_Ctrl)/sd_Ctrl)^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),]))^2)
}

h_Ctrl_opt <- optimise(h_finder, interval = c(h_Ctrl-5, h_Ctrl+5))$minimum


# ---> Gleiches Spiel für die RNase Samples von dem Gen
mu_RNase <- unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name),])
sd_RNase <- min(abs(which(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),] == max(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),])) - which(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),] <= max(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),])/2)))/sqrt(2*log(2))
h_RNase <- max(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),])*sqrt(2*pi)*sd_RNase


mu_finder <- function(mu_RNase) {
  sum((sapply(seq(1,25,1), function(n) {h_RNase*(1/(sd_RNase*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_RNase)/sd_RNase)^2)}) - unlist(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),]))^2)
}

mu_RNase_opt <- optimise(mu_finder, interval = c(mu_RNase-0.5, mu_RNase+0.5))$minimum


sd_finder <- function(sd_RNase) {
  sum((sapply(seq(1,25,1), function(n) {h_RNase*(1/(sd_RNase*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_RNase)/sd_RNase)^2)}) - unlist(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),]))^2)
}

sd_RNase_opt <- optimise(sd_finder, interval = c(0.8*sd_RNase, 1.2*sd_RNase))$minimum


h_finder <- function(h_RNase) {
  sum((sapply(seq(1,25,1), function(n) {h_RNase*(1/(sd_RNase*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu_RNase)/sd_RNase)^2)}) - unlist(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),]))^2)
}

h_RNase_opt <- optimise(h_finder, interval = c(h_RNase-5, h_RNase+5))$minimum

# ---> Plotten der Protein-Verteilungen und gefitteten Gauß-Kurven.
plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main=paste(paste(gene.name, "(Smoothed and Normalized, w/o optimize)")), ylim=c(0,24))

lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),], type="l", lwd=3, col = "red")

curve(h_Ctrl*(1/(sd_Ctrl*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-mu_Ctrl)/sd_Ctrl)^2), add = T, lwd = 3, col = scales::alpha("blue", 0.65))

curve(h_RNase*(1/(sd_RNase*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-mu_RNase)/sd_RNase)^2), add = T, lwd = 3, col = scales::alpha("orange", 0.65))


plot(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name),],type="l",lwd=3,col="green",xlab="Fractions",ylab="Relative Protein Amount",main=paste(paste(gene.name, "(Smoothed and Normalized, with optimize)")), ylim=c(0,24))

lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name),], type="l", lwd=3, col = "red")

curve(h_Ctrl_opt*(1/(sd_Ctrl_opt*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-mu_Ctrl_opt)/sd_Ctrl_opt)^2), add = T, lwd = 3, col = scales::alpha("blue", 0.65))

curve(h_RNase_opt*(1/(sd_RNase_opt*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-mu_RNase_opt)/sd_RNase_opt)^2), add = T, lwd = 3, col = scales::alpha("orange", 0.65))

rm(mu_Ctrl, sd_Ctrl, h_Ctrl, mu_RNase, sd_RNase, h_RNase, mu_Ctrl_opt, sd_Ctrl_opt, h_Ctrl_opt, mu_RNase_opt, sd_RNase_opt, h_RNase_opt, gene.name, mu_finder, sd_finder, h_finder)
```


##### 3.3 Gaussian Fitting of the Entire Data Set

We will now do the same calculations we did for the *CTCF_HUMAN* gene for each gene in our data set. The results will be stored in the data frames **Ctrl_Gauss_Fit** and **RNase_Gauss_Fit**. 
Note, that we will also calculate the protein amount under each peak (area under the curve of fitted Gaussian curve) by using the `pnorm` function and scaling the results with **h**. 

**Note:** *This chunk can take up to several minutes to run.*

```{r gauss, include=FALSE}
# ---> Erstellen eines Data.Frames (Ctrl_Gauss_Fit) mit 5 Spalten ("mu", "sd", "h", "prt_amount" und "overlap") und so vielen zeilen, wie es Gene gibt. Füllen des Data.Frames mit NA-values. 
Ctrl_Gauss_Fit = as.data.frame(matrix(rep(NA, nrow(Ctrl_RDeep)*5), ncol = 5))
colnames(Ctrl_Gauss_Fit) = c("mu", "sd", "h", "prt_amount", "overlap")
rownames(Ctrl_Gauss_Fit) = rownames(Ctrl_RDeep)


# --> Schätzung der Werte für mu (Ctrl_Gauss_Fit[,1]), sd (Ctrl_Gauss_Fit[,2]) und h (Ctrl_Gauss_Fit[,3]) mit den oben beschriebenen Berechnungen (bei "3.1 Introduction") für alle Gene 
Ctrl_Gauss_Fit[,1] <- unlist(Ctrl_Mean_Gbl_Max)
Ctrl_Gauss_Fit[,2] <- sapply(seq(1, nrow(Ctrl_RDeep),1), function(k) {min(abs(unlist(Ctrl_Mean_Gbl_Max[k,]) - which(Ctrl_Mean_Smooth_Norm100[k,] <= max(Ctrl_Mean_Smooth_Norm100[k,])/2)))/sqrt(2*log(2))})
Ctrl_Gauss_Fit[,3] <- apply(Ctrl_Mean_Smooth_Norm100, 1, function(x) {max(x)})*sqrt(2*pi)*Ctrl_Gauss_Fit[,2]


# ---> Aufstellen und Optimieren der Funktion, die die Summe der quadratischen Abstände in Abhängigkeit von mu berechnet, über alle Gene und Abspeichern des resultierenden Vektors (enthält die jeweils optimierten Werte für mu über alle Gene) als erste Spalte von "Ctrl_Gauss_Fit". 
Ctrl_Gauss_Fit[,1] <- sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {
  
mu_finder <- function(mu = Ctrl_Gauss_Fit[k,1]) {sum((sapply(seq(1,25,1), function(n) {Ctrl_Gauss_Fit[k,3]*(1/(Ctrl_Gauss_Fit[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu)/Ctrl_Gauss_Fit[k,2])^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[k,]))^2)}

optimise(mu_finder, interval = c(Ctrl_Gauss_Fit[k,1]-0.5, Ctrl_Gauss_Fit[k,1]+0.5))$minimum})


# ---> Wieder gleiches Spiel für sd und h

Ctrl_Gauss_Fit[,2] <- sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {

sd_finder <- function(sd = Ctrl_Gauss_Fit[k,2]) {sum((sapply(seq(1,25,1), function(n) {Ctrl_Gauss_Fit[k,3]*(1/(sd*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Ctrl_Gauss_Fit[k,1])/sd)^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[k,]))^2)}

optimise(sd_finder, interval = c(0.8*Ctrl_Gauss_Fit[k,2], 1.2*Ctrl_Gauss_Fit[k,2]))$minimum})


Ctrl_Gauss_Fit[,3] <- sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {

h_finder <- function(h = Ctrl_Gauss_Fit[k,3]) {sum((sapply(seq(1,25,1), function(n) {h*(1/(Ctrl_Gauss_Fit[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Ctrl_Gauss_Fit[k,1])/Ctrl_Gauss_Fit[k,2])^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[k,]))^2)}

optimise(h_finder, interval = c(Ctrl_Gauss_Fit[k,3]-5, Ctrl_Gauss_Fit[k,3]+5))$minimum})


# --> Berechung des Protein-Anteils unterhalb der Gauß-Kurve im Intervall [0, 25] (Berechnung als pnorm(25) - pnorm(0) multipliziert mit h) über alle Gene und Abspeichern des resultierenden Vektors in der Spalte "prt_amount"
Ctrl_Gauss_Fit[,4] <- sapply(seq(1, nrow(Ctrl_RDeep),1), function(k) {Ctrl_Gauss_Fit[k,3] * (pnorm(25, mean = Ctrl_Gauss_Fit[k,1], sd = Ctrl_Gauss_Fit[k,2]) - pnorm(0, mean = Ctrl_Gauss_Fit[k,1], sd = Ctrl_Gauss_Fit[k,2]))})


# ---> Gleiches Spiel für die RNase Samples
RNase_Gauss_Fit = as.data.frame(matrix(rep(NA, nrow(RNase_RDeep)*5), ncol = 5))
colnames(RNase_Gauss_Fit) = c("mu", "sd", "h", "prt_amount", "overlap")
rownames(RNase_Gauss_Fit) = rownames(RNase_RDeep)

RNase_Gauss_Fit[,1] <- unlist(RNase_Mean_Gbl_Max)
RNase_Gauss_Fit[,2] <- sapply(seq(1, nrow(RNase_RDeep),1), function(k) {min(abs(unlist(RNase_Mean_Gbl_Max[k,]) - which(RNase_Mean_Smooth_Norm100[k,] <= max(RNase_Mean_Smooth_Norm100[k,])/2)))/sqrt(2*log(2))})
RNase_Gauss_Fit[,3] <- apply(RNase_Mean_Smooth_Norm100, 1, function(x) {max(x)})*sqrt(2*pi)*RNase_Gauss_Fit[,2]


RNase_Gauss_Fit[,1] <- sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {
  
mu_finder <- function(mu = RNase_Gauss_Fit[k,1]) {sum((sapply(seq(1,25,1), function(n) {RNase_Gauss_Fit[k,3]*(1/(RNase_Gauss_Fit[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu)/RNase_Gauss_Fit[k,2])^2)}) - unlist(RNase_Mean_Smooth_Norm100[k,]))^2)}

optimise(mu_finder, interval = c(RNase_Gauss_Fit[k,1]-0.5, RNase_Gauss_Fit[k,1]+0.5))$minimum})


RNase_Gauss_Fit[,2] <- sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {

sd_finder <- function(sd = RNase_Gauss_Fit[k,2]) {sum((sapply(seq(1,25,1), function(n) {RNase_Gauss_Fit[k,3]*(1/(sd*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-RNase_Gauss_Fit[k,1])/sd)^2)}) - unlist(RNase_Mean_Smooth_Norm100[k,]))^2)}

optimise(sd_finder, interval = c(0.8*RNase_Gauss_Fit[k,2], 1.2*RNase_Gauss_Fit[k,2]))$minimum})


RNase_Gauss_Fit[,3] <- sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {

h_finder <- function(h = RNase_Gauss_Fit[k,3]) {sum((sapply(seq(1,25,1), function(n) {h*(1/(RNase_Gauss_Fit[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-RNase_Gauss_Fit[k,1])/RNase_Gauss_Fit[k,2])^2)}) - unlist(RNase_Mean_Smooth_Norm100[k,]))^2)}

optimise(h_finder, interval = c(RNase_Gauss_Fit[k,3]-5, RNase_Gauss_Fit[k,3]+5))$minimum})


RNase_Gauss_Fit[,4] <- sapply(seq(1, nrow(RNase_RDeep),1), function(k) {RNase_Gauss_Fit[k,3] * (pnorm(25, mean = RNase_Gauss_Fit[k,1], sd = RNase_Gauss_Fit[k,2]) - pnorm(0, mean = RNase_Gauss_Fit[k,1], sd = RNase_Gauss_Fit[k,2]))})
```


##### 3.4 Calculation of Gaussian Overlap

The overlap will be calculated as the amount of shared area between the area under the curves of the fitted gaussian curves of the Control and RNase samples in the interval [0, 25]. The percental amount can be calculated by dividing the absolute overlap by the mean area under the curves ((protein amount under curve Control + protein amount under curve RNase)/2).

Because there are 3 parameters (**mu**, **sd**, **h**) with each 3 states (**<**, **>**, **=**), there are 3^3 = 27 possible cases how the 2 gaussian curves can be arranged in respect to each other. 
These 27 cases can be reduced to 9 cases ("**1**" = "**Ctrl**" and "**2**" = "**RNase**"; "|" meaning "or"):

  1. sd1 = sd2, mu1 = mu2, h1 = h2
  2. sd1 = sd2, mu1 > mu2, h1 = h2 | h1 < h2 | h1 > h2
  3. sd1 = sd2, mu1 < mu2, h1 = h2 | h1 < h2 | h1 > h2
  4. sd1 = sd2, mu1 = mu2, h1 > h2
  5. sd1 = sd2, mu1 = mu2, h1 < h2
  6. sd1 > sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 = h2 | h1 < h2
  7. sd1 > sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 > h2
  8. sd1 < sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 = h2 | h1 > h2
  9. sd1 < sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 < h2
  
These cases differ in their arrangement of the 2 gaussian curves and their number of points of intersection:

  1. endless number of points of intersection 
  2./3. 1 point of intersection
  4./5. 0 points of intersection (x)
  6./8. 2 points of intersection (x1 and x2)
  7./9. either 2 points of intersection or 0 points of intersection
  
Note, that for the cases 6. - 9. it must also be consider whether or not x1 and x2 are inside or outside the interval [0, 25]. 

The resulting overlap will be both stored in the data.frames **Ctrl_Gauss_Fit** and **RNase_Gauss_Fit** as the column **overlap**. 

``` {r overlap, include=FALSE}
# ---> Erstellen eines Vektors der so viele NA-values enthält, wie es Gene gibt
overlap = rep(NA, nrow(Ctrl_RDeep))


################### 1. sd1 = sd2, mu1 = mu2, h1 = h2

# ---> "gX" ist jeweils ein Vektor, der die Reihen (Genpositionen) enthält, für die die Bedingungen (je nach Fall) wahr sind (überprüft im Data.frame "Ctrl_Gauss_Fit")
g1 = which(Ctrl_Gauss_Fit[, 2] == RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 1] == RNase_Gauss_Fit[, 1] & Ctrl_Gauss_Fit[, 3] == RNase_Gauss_Fit[, 3])

# ---> Nachdem die Reihen identifiziert wurden, die sich dem entsprechenden Fall zuordnen lassen, werden diese Positionen im Vektor "overlap" durch die entsprechende berechnete prozentuale Überschneidung der Gaußkurven ersetzt (im 1. Fall sehr einfach, da beide Gaußkurven identisch sind und somit overlap = 1 ist)
overlap[g1] = 1


################### 2. sd1 = sd2, mu1 > mu2, h1 = h2 | h1 < h2 | h1 > h2

# ---> Gleiches, wie bei g1, nur, dass andere Bedingungen (für 2. Fall) angewendet werden
g2 = which(Ctrl_Gauss_Fit[, 2] == RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 1] > RNase_Gauss_Fit[, 1])

# ---> Berechnung der Schnittpunkte der Gaußkurven über alle Gene, auf die der 2. Fall zutrifft (mathematische Formel per Hand aufgestellt)
x = ((Ctrl_Gauss_Fit[g2, 2])^(2) * log(Ctrl_Gauss_Fit[g2, 3]/RNase_Gauss_Fit[g2, 3]))/(RNase_Gauss_Fit[g2, 1] -  Ctrl_Gauss_Fit[g2, 1]) + (RNase_Gauss_Fit[g2, 1] + Ctrl_Gauss_Fit[g2, 1])/2

# ---> Wieder Ersetzen der Positionen im vektor "overlap" durch die prozentualen Werte für die Überschneidung der Gaußkurven (berechnet mithilfe von pnorm())
overlap[g2] = sapply(seq(1,length(g2),1), function(k) {
  (Ctrl_Gauss_Fit[g2[k], 3] * (pnorm(x[k], mean = Ctrl_Gauss_Fit[g2[k], 1], sd = Ctrl_Gauss_Fit[g2[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[g2[k], 1], sd = Ctrl_Gauss_Fit[g2[k], 2])) + RNase_Gauss_Fit[g2[k], 3] * (pnorm(25, mean = RNase_Gauss_Fit[g2[k], 1], sd = RNase_Gauss_Fit[g2[k], 2]) - pnorm(x[k], mean = RNase_Gauss_Fit[g2[k], 1], sd = RNase_Gauss_Fit[g2[k], 2])))/((Ctrl_Gauss_Fit[g2[k], 4] + RNase_Gauss_Fit[g2[k], 4])/2)
})


# ---> Fast identisches Vorgehen für die Fälle 3 bis 9 (ABER: 1. Wenn die eine Gaußkurve komplett in der anderen liegt (Fälle 4 und 5 und potentiell 7 und 9), wird die prozentuale Überschneidung berechnet, indem die Fläche unter der Gaußkurve, die in der anderen Gaußkurve liegt, dividiert wird durch den Mittelwert beider Flächen unter den Gaußkurven & 2. Sobald sich die Standardabweichungen unterscheiden (Fälle 6 bis 9) gibt es jeweils potentiell 2 Schnittpunkte (diese werden mit der abc-Formel berechnet), zudem muss geschaut werden, ob die Schnittpunkte außerhalb des Intervalls [0, 25] liegen (da sich dann wieder die Berechnung der prozentualen Überschneidung verändert))

################### 3. sd1 = sd2, mu1 < mu2, h1 = h2 | h1 < h2 | h1 > h2
g3 = which(Ctrl_Gauss_Fit[, 2] == RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 1] < RNase_Gauss_Fit[, 1])

x = ((Ctrl_Gauss_Fit[g3, 2])^(2) * log(Ctrl_Gauss_Fit[g3, 3]/RNase_Gauss_Fit[g3, 3]))/(RNase_Gauss_Fit[g3, 1] -  Ctrl_Gauss_Fit[g3, 1]) + (RNase_Gauss_Fit[g3, 1] + Ctrl_Gauss_Fit[g3, 1])/2

overlap[g3] = sapply(seq(1,length(g3),1), function(k) {
  (RNase_Gauss_Fit[g3[k], 3] * (pnorm(x[k], mean = RNase_Gauss_Fit[g3[k], 1], sd = RNase_Gauss_Fit[g3[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[g3[k], 1], sd = RNase_Gauss_Fit[g3[k], 2])) + Ctrl_Gauss_Fit[g3[k], 3] * (pnorm(25, mean = Ctrl_Gauss_Fit[g3[k], 1], sd = Ctrl_Gauss_Fit[g3[k], 2]) - pnorm(x[k], mean = Ctrl_Gauss_Fit[g3[k], 1], sd = Ctrl_Gauss_Fit[g3[k], 2])))/((Ctrl_Gauss_Fit[g3[k], 4] + RNase_Gauss_Fit[g3[k], 4])/2)
})


################### 4. sd1 = sd2, mu1 = mu2, h1 > h2
g4 = which(Ctrl_Gauss_Fit[, 2] == RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 1] == RNase_Gauss_Fit[, 1] & Ctrl_Gauss_Fit[, 3] > RNase_Gauss_Fit[, 3])

overlap[g4] = sapply(seq(1, length(g4), 1), function(k) {
  (RNase_Gauss_Fit[g4[k], 4])/((Ctrl_Gauss_Fit[g4[k], 4] + RNase_Gauss_Fit[g4[k], 4])/2)
})


################### 5. sd1 = sd2, mu1 = mu2, h1 < h2
g5 = which(Ctrl_Gauss_Fit[, 2] == RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 1] == RNase_Gauss_Fit[, 1] & Ctrl_Gauss_Fit[, 3] < RNase_Gauss_Fit[, 3])

overlap[g5] = sapply(seq(1, length(g5), 1), function(k) {
  (Ctrl_Gauss_Fit[g5[k], 4])/((Ctrl_Gauss_Fit[g5[k], 4] + RNase_Gauss_Fit[g5[k], 4])/2)
})


################### 6. sd1 > sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 = h2 | h1 < h2
g6 = which(Ctrl_Gauss_Fit[, 2] > RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 3] <= RNase_Gauss_Fit[, 3])

a = (1/(Ctrl_Gauss_Fit[g6,2])^2 - 1/(RNase_Gauss_Fit[g6,2])^2)
b = 2 * ((RNase_Gauss_Fit[g6,1])/(RNase_Gauss_Fit[g6,2])^2 - (Ctrl_Gauss_Fit[g6,1])/(Ctrl_Gauss_Fit[g6,2])^2)
c = (Ctrl_Gauss_Fit[g6,1]/Ctrl_Gauss_Fit[g6,2])^2 - (RNase_Gauss_Fit[g6,1]/RNase_Gauss_Fit[g6,2])^2 - 2 * log((Ctrl_Gauss_Fit[g6,3] * RNase_Gauss_Fit[g6,2])/(RNase_Gauss_Fit[g6,3] * Ctrl_Gauss_Fit[g6,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g6[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) + pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g6[which(x1 > 25)]
u2 = which(x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g6[which(x2 < 0)]
u2 = which(x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})


################### 7. sd1 > sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 > h2
g7 = which(Ctrl_Gauss_Fit[, 2] > RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 3] > RNase_Gauss_Fit[, 3])

a = (1/(Ctrl_Gauss_Fit[g7,2])^2 - 1/(RNase_Gauss_Fit[g7,2])^2)
b = 2 * ((RNase_Gauss_Fit[g7,1])/(RNase_Gauss_Fit[g7,2])^2 - (Ctrl_Gauss_Fit[g7,1])/(Ctrl_Gauss_Fit[g7,2])^2)
c = (Ctrl_Gauss_Fit[g7,1]/Ctrl_Gauss_Fit[g7,2])^2 - (RNase_Gauss_Fit[g7,1]/RNase_Gauss_Fit[g7,2])^2 - 2 * log((Ctrl_Gauss_Fit[g7,3] * RNase_Gauss_Fit[g7,2])/(RNase_Gauss_Fit[g7,3] * Ctrl_Gauss_Fit[g7,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g7[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) + pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g7[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g7[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])) + Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g7[which(is.nan(x1))]
u2 = which(is.nan(x1))
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (RNase_Gauss_Fit[u1[k], 4])/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})


################### 8. sd1 < sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 = h2 | h1 > h2
g8 = which(Ctrl_Gauss_Fit[, 2] < RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 3] >= RNase_Gauss_Fit[, 3])

a = (1/(Ctrl_Gauss_Fit[g8,2])^2 - 1/(RNase_Gauss_Fit[g8,2])^2)
b = 2 * ((RNase_Gauss_Fit[g8,1])/(RNase_Gauss_Fit[g8,2])^2 - (Ctrl_Gauss_Fit[g8,1])/(Ctrl_Gauss_Fit[g8,2])^2)
c = (Ctrl_Gauss_Fit[g8,1]/Ctrl_Gauss_Fit[g8,2])^2 - (RNase_Gauss_Fit[g8,1]/RNase_Gauss_Fit[g8,2])^2 - 2 * log((Ctrl_Gauss_Fit[g8,3] * RNase_Gauss_Fit[g8,2])/(RNase_Gauss_Fit[g8,3] * Ctrl_Gauss_Fit[g8,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g8[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) + pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g8[which(x1 > 25)]
u2 = which(x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

u1 = g8[which(x2 < 0)]
u2 = which(x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})


################### 9. sd1 < sd2, mu1 = mu2 | mu1 > mu2 | mu1 < mu2, h1 < h2
g9 = which(Ctrl_Gauss_Fit[, 2] < RNase_Gauss_Fit[, 2] & Ctrl_Gauss_Fit[, 3] < RNase_Gauss_Fit[, 3])

a = (1/(Ctrl_Gauss_Fit[g9,2])^2 - 1/(RNase_Gauss_Fit[g9,2])^2)
b = 2 * ((RNase_Gauss_Fit[g9,1])/(RNase_Gauss_Fit[g9,2])^2 - (Ctrl_Gauss_Fit[g9,1])/(Ctrl_Gauss_Fit[g9,2])^2)
c = (Ctrl_Gauss_Fit[g9,1]/Ctrl_Gauss_Fit[g9,2])^2 - (RNase_Gauss_Fit[g9,1]/RNase_Gauss_Fit[g9,2])^2 - 2 * log((Ctrl_Gauss_Fit[g9,3] * RNase_Gauss_Fit[g9,2])/(RNase_Gauss_Fit[g9,3] * Ctrl_Gauss_Fit[g9,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g9[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) + pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((RNase_Gauss_Fit[u1[k], 4] + Ctrl_Gauss_Fit[u1[k], 4])/2)
})

u1 = g9[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(x2[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(x2[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((RNase_Gauss_Fit[u1[k], 4] + Ctrl_Gauss_Fit[u1[k], 4])/2)
})

u1 = g9[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 3] * (pnorm(25, mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2]) - pnorm(x1[u2[k]], mean = Ctrl_Gauss_Fit[u1[k], 1], sd = Ctrl_Gauss_Fit[u1[k], 2])) + RNase_Gauss_Fit[u1[k], 3] * (pnorm(x1[u2[k]], mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2]) - pnorm(0, mean = RNase_Gauss_Fit[u1[k], 1], sd = RNase_Gauss_Fit[u1[k], 2])))/((RNase_Gauss_Fit[u1[k], 4] + Ctrl_Gauss_Fit[u1[k], 4])/2)
})

u1 = g9[which(is.nan(x1))]
u2 = which(is.nan(x1))
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Ctrl_Gauss_Fit[u1[k], 4])/((Ctrl_Gauss_Fit[u1[k], 4] + RNase_Gauss_Fit[u1[k], 4])/2)
})

Ctrl_Gauss_Fit[, 5] = overlap 
RNase_Gauss_Fit[, 5] = overlap

rm(g1, g2, g3, g4, g5, g6, g7, g8, g9, u1, u2, a, b, c, x, x1, x2, overlap)
```


##### 3.5 Gaussian Fitting for Main Local Peaks

Furthermore, we want to fit each *main* local peak with a gaussian curve for the control and RNase samples. A main local peak is just the local peak with the highest protein amount. 
In contrast with global peak gaussian fitting, all computed values (*peak position*, *mu*, *sd*, *h* and *prt_amount*) will be stored in 1 dataframe called **Mean_Loc_Max**. 

In addition, we want to calculate the *overlap* between the gaussian curves of the global and main local Ctrl peaks (*Ctrl_overlap*), the global and main local RNase peaks (*RNase_overlap*) and the main local peaks (*Loc_overlap*). 
The calculations are analogous to the calculations in *"3.4 Calculation of Gaussian Overlap"*, with the small exception that we have to test whether or not a case even applies to the genes with local peaks (**2479** out of 5990 genes have *Ctrl* local peaks, **2404** have *RNase* local peaks and **2360** have *Ctrl and RNase* local peaks) (otherwise there will be an error message).

```{r}
# ---> 1. Erstellen des Dataframes (13 Spalten)
Mean_Loc_Max = as.data.frame(matrix(rep(NA, 13 * nrow(Ctrl_RDeep)), ncol = 13))


# ---> 2. Identische Berechnung der lokalen Maxima, wie in 2.3.2, aber nur bis zu dem Punkt, wo die double und triple peaks zusammengefasst werden würden (nötig, um diese als Spaltenauswahl für den Poteinanteil einzusetzen)

# ---> 2.1 Erstellen eines leeren Datensatzes für lokale Peaks
Dat_Loc_Ctrl = as.data.frame(matrix(NA, nrow = nrow(Ctrl_RDeep), ncol = 25))

# ---> 2.2 Bestimmung der Fraction Positions für alle lokalen Maxima (in den Control Samples), indem jeweils in einem 5 Fraktion-Window berechnet wird, welche Position den größten Protein Anteil beinhaltet und ob diese Position der mittleren Position entspricht
Fra.Pos_Ctrl = sapply(seq(0,20,1), function(i) {which(seq(2*nrow(Ctrl_RDeep)+1,3*nrow(Ctrl_RDeep),1) %in% which(apply(Ctrl_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) == Ctrl_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)] & apply(Ctrl_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) != 0))})

# ---> 2.3 Einspeichern der lokalen Maxima im Data.Frame "Dat_Loc_Ctrl" (erstellt in erster Zeile des Chunks), indem pro Gen der NA-value jeder Fraktion, die ein lokales Maximum ist, durch den Wert der Fraktion ersetzt wird (also, wenn in Gen 1 Fraktion 5 ein lokales Maximum ist, wird der Wert für Fraktion 5 in Gen 1 (NA) mit "5" ersetzt) 
Dat_Loc_Ctrl[, 3:23] = sapply(seq(1,21,1), function(n) {
  replace(
        Dat_Loc_Ctrl[, n+2], 
        Fra.Pos_Ctrl[[n]], 
        n+2)})

# ---> 2.4 Berechnungen für die Edge Cases (Fraktionen 1, 2, 24 und 25)
Dat_Loc_Ctrl[which(Ctrl_Mean_Smooth_Norm100[,1] >= Ctrl_Mean_Smooth_Norm100[,2] & Ctrl_Mean_Smooth_Norm100[,1] >= Ctrl_Mean_Smooth_Norm100[,3] & Ctrl_Mean_Smooth_Norm100[,1] != 0),1] = 1

Dat_Loc_Ctrl[which(Ctrl_Mean_Smooth_Norm100[,2] >= Ctrl_Mean_Smooth_Norm100[,3] & Ctrl_Mean_Smooth_Norm100[,2] >= Ctrl_Mean_Smooth_Norm100[,4] & Ctrl_Mean_Smooth_Norm100[,2] >= Ctrl_Mean_Smooth_Norm100[,1] & Ctrl_Mean_Smooth_Norm100[,1] != 0), 2] = 2

Dat_Loc_Ctrl[which(Ctrl_Mean_Smooth_Norm100[,25] >= Ctrl_Mean_Smooth_Norm100[,24] & Ctrl_Mean_Smooth_Norm100[,25] >= Ctrl_Mean_Smooth_Norm100[,23] & Ctrl_Mean_Smooth_Norm100[,25] != 0), 25] = 25

Dat_Loc_Ctrl[which(Ctrl_Mean_Smooth_Norm100[,24] >= Ctrl_Mean_Smooth_Norm100[,23] & Ctrl_Mean_Smooth_Norm100[,24] >= Ctrl_Mean_Smooth_Norm100[,22] & Ctrl_Mean_Smooth_Norm100[,24] >= Ctrl_Mean_Smooth_Norm100[,25] & Ctrl_Mean_Smooth_Norm100[,24] != 0), 24] = 24

# ---> 2.5 Löschen der globalen Maxima aus dem Datensatz mit den "lokalen" Maxima
Ctrl_Mask = matrix(1, nrow = nrow(Ctrl_RDeep)*25, ncol = 1)

Ctrl_Mask[which(apply(Ctrl_Mean_Smooth_Norm100, 1, function(x) {max(x)}) == Ctrl_Mean_Smooth_Norm100)] = NA

Ctrl_Mask = as.data.frame(matrix(unlist(Ctrl_Mask), nrow=nrow(Ctrl_RDeep), ncol=25))

Dat_Loc_Ctrl = Dat_Loc_Ctrl * Ctrl_Mask

rm(Ctrl_Mask)


# ---> 3. Extrahieren der Fraktions-Werte aus dem Dataframe, der die lokalen Peaks enthält (Dat_Loc_Ctrl), als Liste
Loc_Ctrl = sapply(seq(1, nrow(Dat_Loc_Ctrl), 1), function(n) {which(!is.na(Dat_Loc_Ctrl[n,]))})


# ---> 4. Bestimmung der Fraktions-Werte, zu denen der höchste lokale Protein-Anteil gehört
Main_Ctrl = sapply(seq(1, nrow(Ctrl_Mean_Smooth_Norm100), 1), function(n) {
if(!is.null(unlist(Ctrl_Mean_Smooth_Norm100[n, Loc_Ctrl[[n]]]))) {
  Loc_Ctrl[[n]][which(Ctrl_Mean_Smooth_Norm100[n, Loc_Ctrl[[n]]] == max(unlist(Ctrl_Mean_Smooth_Norm100[n, Loc_Ctrl[[n]]])))]
} 
  else {
  NA  
  }})

# ---> 5. Zusammenfassen der double und triple peaks zu single peaks und Abspeichern der Werte in der 1. Spalte des Dataframes "Mean_Loc_Max"
Mean_Loc_Max[, 1] = sapply(seq(1, nrow(Ctrl_Mean_Smooth_Norm100), 1), function(n) {
   if(length(Main_Ctrl[[n]]) == 2 | length(Main_Ctrl[[n]]) == 3) {
     mean(Main_Ctrl[[n]])
   }
   else {
     Main_Ctrl[[n]]
   }
 })


# ---> 6. Analoge Berechnungen für die RNase samples
Dat_Loc_RNase = as.data.frame(matrix(NA, nrow = nrow(RNase_RDeep), ncol = 25))

Fra.Pos_RNase = sapply(seq(0,20,1), function(i) {which(seq(2*nrow(RNase_RDeep)+1,3*nrow(RNase_RDeep),1) %in% which(apply(RNase_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) == RNase_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)] & apply(RNase_Mean_Smooth_Norm100[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) != 0))})

Dat_Loc_RNase[, 3:23] = sapply(seq(1,21,1), function(n) {
  replace(
        Dat_Loc_RNase[, n+2], 
        Fra.Pos_RNase[[n]], 
        n+2)})

Dat_Loc_RNase[which(RNase_Mean_Smooth_Norm100[,1] >= RNase_Mean_Smooth_Norm100[,2] & RNase_Mean_Smooth_Norm100[,1] >= RNase_Mean_Smooth_Norm100[,3] & RNase_Mean_Smooth_Norm100[,1] != 0),1] = 1

Dat_Loc_RNase[which(RNase_Mean_Smooth_Norm100[,2] >= RNase_Mean_Smooth_Norm100[,3] & RNase_Mean_Smooth_Norm100[,2] >= RNase_Mean_Smooth_Norm100[,4] & RNase_Mean_Smooth_Norm100[,2] >= RNase_Mean_Smooth_Norm100[,1] & RNase_Mean_Smooth_Norm100[,1] != 0), 2] = 2

Dat_Loc_RNase[which(RNase_Mean_Smooth_Norm100[,25] >= RNase_Mean_Smooth_Norm100[,24] & RNase_Mean_Smooth_Norm100[,25] >= RNase_Mean_Smooth_Norm100[,23] & RNase_Mean_Smooth_Norm100[,25] != 0), 25] = 25

Dat_Loc_RNase[which(RNase_Mean_Smooth_Norm100[,24] >= RNase_Mean_Smooth_Norm100[,23] & RNase_Mean_Smooth_Norm100[,24] >= RNase_Mean_Smooth_Norm100[,22] & RNase_Mean_Smooth_Norm100[,24] >= RNase_Mean_Smooth_Norm100[,25] & RNase_Mean_Smooth_Norm100[,24] != 0), 24] = 24

RNase_Mask = matrix(1, nrow = nrow(RNase_RDeep)*25, ncol = 1)

RNase_Mask[which(apply(RNase_Mean_Smooth_Norm100, 1, function(x) {max(x)}) == RNase_Mean_Smooth_Norm100)] = NA

RNase_Mask = as.data.frame(matrix(unlist(RNase_Mask), nrow=nrow(RNase_RDeep), ncol=25))

Dat_Loc_RNase = Dat_Loc_RNase * RNase_Mask

rm(RNase_Mask)


Loc_RNase = sapply(seq(1, nrow(Dat_Loc_RNase), 1), function(n) {which(!is.na(Dat_Loc_RNase[n,]))})

Main_RNase = sapply(seq(1, nrow(RNase_Mean_Smooth_Norm100), 1), function(n) {
if(!is.null(unlist(RNase_Mean_Smooth_Norm100[n, Loc_RNase[[n]]]))) {
  Loc_RNase[[n]][which(RNase_Mean_Smooth_Norm100[n, Loc_RNase[[n]]] == max(unlist(RNase_Mean_Smooth_Norm100[n, Loc_RNase[[n]]])))]
}
  else {
  NA  
  }})

Mean_Loc_Max[, 6] = sapply(seq(1, nrow(RNase_Mean_Smooth_Norm100), 1), function(n) {
   if(length(Main_RNase[[n]]) == 2 | length(Main_RNase[[n]]) == 3) {
     mean(Main_RNase[[n]])
   }
   else {
     Main_RNase[[n]]
   }
 })



# ---> 7. Gaussian Fitting (fast analoge Berechnung wie bei 3.3, außer dass NA-Zeilen nicht mit einbezogen werden (if-Befehle))
Mean_Loc_Max[,2] <- unlist(Mean_Loc_Max[, 1])
Mean_Loc_Max[,3] <- sapply(seq(1, nrow(Ctrl_RDeep),1), function(k) {if(!is.na(unlist(Mean_Loc_Max[k,1]))) {if(length(abs(unlist(Mean_Loc_Max[k,1]) - which(Ctrl_Mean_Smooth_Norm100[k,] <= max(Ctrl_Mean_Smooth_Norm100[k,Main_Ctrl[[k]]])/2))) != 0) {min(abs(unlist(Mean_Loc_Max[k,1]) - which(Ctrl_Mean_Smooth_Norm100[k,] <= max(Ctrl_Mean_Smooth_Norm100[k,Main_Ctrl[[k]]])/2)))/sqrt(2*log(2))} 
                           else {1}} else {NA}})
Mean_Loc_Max[,4] <- sapply(seq(1, nrow(Ctrl_RDeep),1), function(k) {if(!is.na(unlist(Mean_Loc_Max[k,1]))) {max(Ctrl_Mean_Smooth_Norm100[k, Main_Ctrl[[k]]]) * sqrt(2*pi)*Mean_Loc_Max[k,3]} else {NA}})


Mean_Loc_Max[,2] <- sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {

  if(!is.na(unlist(Mean_Loc_Max[k,1]))) {  
mu_finder <- function(mu = Mean_Loc_Max[k,2]) {sum((sapply(seq(1,25,1), function(n) {Mean_Loc_Max[k,4]*(1/(Mean_Loc_Max[k,3]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu)/Mean_Loc_Max[k,3])^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[k,]))^2)}

optimise(mu_finder, interval = c(Mean_Loc_Max[k,2]-0.5, Mean_Loc_Max[k,2]+0.5))$minimum} else {NA}})


Mean_Loc_Max[,3] <- sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {

   if(!is.na(unlist(Mean_Loc_Max[k,1]))) { 
sd_finder <- function(sd = Mean_Loc_Max[k,3]) {sum((sapply(seq(1,25,1), function(n) {Mean_Loc_Max[k,4]*(1/(sd*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Mean_Loc_Max[k,2])/sd)^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[k,]))^2)}

optimise(sd_finder, interval = c(0.8*Mean_Loc_Max[k,3], 1.2*Mean_Loc_Max[k,3]))$minimum} else {NA}})


Mean_Loc_Max[,4] <- sapply(seq(1, nrow(Ctrl_RDeep), 1), function(k) {

   if(!is.na(unlist(Mean_Loc_Max[k,1]))) { 
h_finder <- function(h = Mean_Loc_Max[k,4]) {sum((sapply(seq(1,25,1), function(n) {h*(1/(Mean_Loc_Max[k,3]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Mean_Loc_Max[k,2])/Mean_Loc_Max[k,3])^2)}) - unlist(Ctrl_Mean_Smooth_Norm100[k,]))^2)}

optimise(h_finder, interval = c(Mean_Loc_Max[k,4]-5, Mean_Loc_Max[k,4]+5))$minimum} else {NA}}) 


Mean_Loc_Max[,5] <- sapply(seq(1, nrow(Ctrl_RDeep),1), function(k) {if(!is.na(unlist(Mean_Loc_Max[k,1]))) {Mean_Loc_Max[k,4] * (pnorm(25, mean = Mean_Loc_Max[k,2], sd = Mean_Loc_Max[k,3]) - pnorm(0, mean = Mean_Loc_Max[k,2], sd = Mean_Loc_Max[k,3]))} else {NA}})



Mean_Loc_Max[,7] <- unlist(Mean_Loc_Max[, 6])
Mean_Loc_Max[,8] <- sapply(seq(1, nrow(RNase_RDeep),1), function(k) {if(!is.na(unlist(Mean_Loc_Max[k,6]))) {if(length(abs(unlist(Mean_Loc_Max[k,6]) - which(RNase_Mean_Smooth_Norm100[k,] <= max(RNase_Mean_Smooth_Norm100[k,Main_RNase[[k]]])/2))) != 0) {min(abs(unlist(Mean_Loc_Max[k,6]) - which(RNase_Mean_Smooth_Norm100[k,] <= max(RNase_Mean_Smooth_Norm100[k,Main_RNase[[k]]])/2)))/sqrt(2*log(2))} 
                           else {1}} else {NA}})
Mean_Loc_Max[,9] <- sapply(seq(1, nrow(RNase_RDeep),1), function(k) {if(!is.na(unlist(Mean_Loc_Max[k,6]))) {max(RNase_Mean_Smooth_Norm100[k, Main_RNase[[k]]]) * sqrt(2*pi)*Mean_Loc_Max[k,8]} else {NA}})


Mean_Loc_Max[,7] <- sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {

  if(!is.na(unlist(Mean_Loc_Max[k,6]))) {  
mu_finder <- function(mu = Mean_Loc_Max[k,7]) {sum((sapply(seq(1,25,1), function(n) {Mean_Loc_Max[k,9]*(1/(Mean_Loc_Max[k,8]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu)/Mean_Loc_Max[k,8])^2)}) - unlist(RNase_Mean_Smooth_Norm100[k,]))^2)}

optimise(mu_finder, interval = c(Mean_Loc_Max[k,7]-0.5, Mean_Loc_Max[k,7]+0.5))$minimum} else {NA}})


Mean_Loc_Max[,8] <- sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {

   if(!is.na(unlist(Mean_Loc_Max[k,6]))) { 
sd_finder <- function(sd = Mean_Loc_Max[k,8]) {sum((sapply(seq(1,25,1), function(n) {Mean_Loc_Max[k,9]*(1/(sd*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Mean_Loc_Max[k,7])/sd)^2)}) - unlist(RNase_Mean_Smooth_Norm100[k,]))^2)}

optimise(sd_finder, interval = c(0.8*Mean_Loc_Max[k,8], 1.2*Mean_Loc_Max[k,8]))$minimum} else {NA}})


Mean_Loc_Max[,9] <- sapply(seq(1, nrow(RNase_RDeep), 1), function(k) {

   if(!is.na(unlist(Mean_Loc_Max[k,6]))) { 
h_finder <- function(h = Mean_Loc_Max[k,9]) {sum((sapply(seq(1,25,1), function(n) {h*(1/(Mean_Loc_Max[k,8]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Mean_Loc_Max[k,7])/Mean_Loc_Max[k,8])^2)}) - unlist(RNase_Mean_Smooth_Norm100[k,]))^2)}

optimise(h_finder, interval = c(Mean_Loc_Max[k,9]-5, Mean_Loc_Max[k,9]+5))$minimum} else {NA}}) 


Mean_Loc_Max[,10] <- sapply(seq(1, nrow(RNase_RDeep),1), function(k) {if(!is.na(unlist(Mean_Loc_Max[k,6]))) {Mean_Loc_Max[k,9] * (pnorm(25, mean = Mean_Loc_Max[k,7], sd = Mean_Loc_Max[k,8]) - pnorm(0, mean = Mean_Loc_Max[k,7], sd = Mean_Loc_Max[k,8]))} else {NA}})


rownames(Mean_Loc_Max) = rownames(Ctrl_RDeep)
colnames(Mean_Loc_Max) = c("Ctrl_Loc_Max", "Ctrl_mu", "Ctrl_sd", "Ctrl_h", "Ctrl_prt_amount", "RNase_Loc_Max", "RNase_mu", "RNase_sd", "RNase_h", "RNase_prt_amount")

rm(Loc_Ctrl, Loc_RNase, Main_Ctrl, Main_RNase, Fra.Pos_Ctrl, Fra.Pos_RNase, Dat_Loc_Ctrl, Dat_Loc_RNase)



# ---> 8. Berechnung des Overlaps (analoge Berechnungen zu 3.4, nur, dass der Overlap zwischen dem Ctrl lokalen Peak & Ctrl globalen Peak (Ctrl_overlap) und RNase lokalen Peak & RNase globalen Peak (RNase_overlap) und RNase & Ctrl lokalen Peaks (Loc_overlap))

# ---> 8.1 Ctrl_overlap
l_Ctrl = Mean_Loc_Max[which(!is.na(Mean_Loc_Max[,1])), 2:5]
g_Ctrl = Ctrl_Gauss_Fit[which(!is.na(Mean_Loc_Max[,1])), ]

overlap = rep(NA, length(which(!is.na(Mean_Loc_Max[,1]))))

g1 = which(g_Ctrl[, 2] == l_Ctrl[, 2] & g_Ctrl[, 1] == l_Ctrl[, 1] & g_Ctrl[, 3] == l_Ctrl[, 3])

if(length(g1) != 0) {
overlap[g1] = 1}

g2 = which(g_Ctrl[, 2] == l_Ctrl[, 2] & g_Ctrl[, 1] > l_Ctrl[, 1])

x = ((g_Ctrl[g2, 2])^(2) * log(g_Ctrl[g2, 3]/l_Ctrl[g2, 3]))/(l_Ctrl[g2, 1] -  g_Ctrl[g2, 1]) + (l_Ctrl[g2, 1] + g_Ctrl[g2, 1])/2

if(length(g2) != 0) {
overlap[g2] = sapply(seq(1,length(g2),1), function(k) {
  (g_Ctrl[g2[k], 3] * (pnorm(x[k], mean = g_Ctrl[g2[k], 1], sd = g_Ctrl[g2[k], 2]) - pnorm(0, mean = g_Ctrl[g2[k], 1], sd = g_Ctrl[g2[k], 2])) + l_Ctrl[g2[k], 3] * (pnorm(25, mean = l_Ctrl[g2[k], 1], sd = l_Ctrl[g2[k], 2]) - pnorm(x[k], mean = l_Ctrl[g2[k], 1], sd = l_Ctrl[g2[k], 2])))/((g_Ctrl[g2[k], 4] + l_Ctrl[g2[k], 4])/2)
})}

g3 = which(g_Ctrl[, 2] == l_Ctrl[, 2] & g_Ctrl[, 1] < l_Ctrl[, 1])

x = ((g_Ctrl[g3, 2])^(2) * log(g_Ctrl[g3, 3]/l_Ctrl[g3, 3]))/(l_Ctrl[g3, 1] -  g_Ctrl[g3, 1]) + (l_Ctrl[g3, 1] + g_Ctrl[g3, 1])/2

if(length(g3) != 0) {
overlap[g3] = sapply(seq(1,length(g3),1), function(k) {
  (l_Ctrl[g3[k], 3] * (pnorm(x[k], mean = l_Ctrl[g3[k], 1], sd = l_Ctrl[g3[k], 2]) - pnorm(0, mean = l_Ctrl[g3[k], 1], sd = l_Ctrl[g3[k], 2])) + g_Ctrl[g3[k], 3] * (pnorm(25, mean = g_Ctrl[g3[k], 1], sd = g_Ctrl[g3[k], 2]) - pnorm(x[k], mean = g_Ctrl[g3[k], 1], sd = g_Ctrl[g3[k], 2])))/((g_Ctrl[g3[k], 4] + l_Ctrl[g3[k], 4])/2)
})}

g4 = which(g_Ctrl[, 2] == l_Ctrl[, 2] & g_Ctrl[, 1] == l_Ctrl[, 1] & g_Ctrl[, 3] > l_Ctrl[, 3])

if(length(g4) != 0) {
overlap[g4] = sapply(seq(1, length(g4), 1), function(k) {
  (l_Ctrl[g4[k], 4])/((g_Ctrl[g4[k], 4] + l_Ctrl[g4[k], 4])/2)
})}

g5 = which(g_Ctrl[, 2] == l_Ctrl[, 2] & g_Ctrl[, 1] == l_Ctrl[, 1] & g_Ctrl[, 3] < l_Ctrl[, 3])

if(length(g5) != 0) {
overlap[g5] = sapply(seq(1, length(g5), 1), function(k) {
  (g_Ctrl[g5[k], 4])/((g_Ctrl[g5[k], 4] + l_Ctrl[g5[k], 4])/2)
})}

g6 = which(g_Ctrl[, 2] > l_Ctrl[, 2] & g_Ctrl[, 3] <= l_Ctrl[, 3])

a = (1/(g_Ctrl[g6,2])^2 - 1/(l_Ctrl[g6,2])^2)
b = 2 * ((l_Ctrl[g6,1])/(l_Ctrl[g6,2])^2 - (g_Ctrl[g6,1])/(g_Ctrl[g6,2])^2)
c = (g_Ctrl[g6,1]/g_Ctrl[g6,2])^2 - (l_Ctrl[g6,1]/l_Ctrl[g6,2])^2 - 2 * log((g_Ctrl[g6,3] * l_Ctrl[g6,2])/(l_Ctrl[g6,3] * g_Ctrl[g6,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g6) != 0) {
u1 = g6[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) + pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + g_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])))/((g_Ctrl[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g6) != 0) {
u1 = g6[which(x1 > 25)]
u2 = which(x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + g_Ctrl[u1[k], 3] * (pnorm(25, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])))/((g_Ctrl[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g6) != 0) {
u1 = g6[which(x2 < 0)]
u2 = which(x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + g_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(0, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])))/((g_Ctrl[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

g7 = which(g_Ctrl[, 2] > l_Ctrl[, 2] & g_Ctrl[, 3] > l_Ctrl[, 3])

a = (1/(g_Ctrl[g7,2])^2 - 1/(l_Ctrl[g7,2])^2)
b = 2 * ((l_Ctrl[g7,1])/(l_Ctrl[g7,2])^2 - (g_Ctrl[g7,1])/(g_Ctrl[g7,2])^2)
c = (g_Ctrl[g7,1]/g_Ctrl[g7,2])^2 - (l_Ctrl[g7,1]/l_Ctrl[g7,2])^2 - 2 * log((g_Ctrl[g7,3] * l_Ctrl[g7,2])/(l_Ctrl[g7,3] * g_Ctrl[g7,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g7) != 0) {
u1 = g7[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) + pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + g_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])))/((g_Ctrl[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g7) != 0) {
u1 = g7[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + g_Ctrl[u1[k], 3] * (pnorm(25, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])))/((g_Ctrl[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g7) != 0) {
u1 = g7[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + g_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(0, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])))/((g_Ctrl[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g7) != 0) {
u1 = g7[which(is.nan(x1))]
u2 = which(is.nan(x1))

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 4])/((g_Ctrl[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

g8 = which(g_Ctrl[, 2] < l_Ctrl[, 2] & g_Ctrl[, 3] >= l_Ctrl[, 3])

a = (1/(g_Ctrl[g8,2])^2 - 1/(l_Ctrl[g8,2])^2)
b = 2 * ((l_Ctrl[g8,1])/(l_Ctrl[g8,2])^2 - (g_Ctrl[g8,1])/(g_Ctrl[g8,2])^2)
c = (g_Ctrl[g8,1]/g_Ctrl[g8,2])^2 - (l_Ctrl[g8,1]/l_Ctrl[g8,2])^2 - 2 * log((g_Ctrl[g8,3] * l_Ctrl[g8,2])/(l_Ctrl[g8,3] * g_Ctrl[g8,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g8) != 0) {
u1 = g8[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(0, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) + pnorm(25, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((g_Ctrl[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g8) != 0) {
u1 = g8[which(x1 > 25)]
u2 = which(x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(0, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((g_Ctrl[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g8) != 0) {
u1 = g8[which(x2 < 0)]
u2 = which(x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_Ctrl[u1[k], 3] * (pnorm(25, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((g_Ctrl[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

g9 = which(g_Ctrl[, 2] < l_Ctrl[, 2] & g_Ctrl[, 3] < l_Ctrl[, 3])

a = (1/(g_Ctrl[g9,2])^2 - 1/(l_Ctrl[g9,2])^2)
b = 2 * ((l_Ctrl[g9,1])/(l_Ctrl[g9,2])^2 - (g_Ctrl[g9,1])/(g_Ctrl[g9,2])^2)
c = (g_Ctrl[g9,1]/g_Ctrl[g9,2])^2 - (l_Ctrl[g9,1]/l_Ctrl[g9,2])^2 - 2 * log((g_Ctrl[g9,3] * l_Ctrl[g9,2])/(l_Ctrl[g9,3] * g_Ctrl[g9,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g9) != 0) {
u1 = g9[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(0, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) + pnorm(25, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((l_Ctrl[u1[k], 4] + g_Ctrl[u1[k], 4])/2)
})}}

if(length(g9) != 0) {
u1 = g9[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(0, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((l_Ctrl[u1[k], 4] + g_Ctrl[u1[k], 4])/2)
})}}

if(length(g9) != 0) {
u1 = g9[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_Ctrl[u1[k], 3] * (pnorm(25, mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = g_Ctrl[u1[k], 1], sd = g_Ctrl[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((l_Ctrl[u1[k], 4] + g_Ctrl[u1[k], 4])/2)
})}}

if(length(g9) != 0) {
u1 = g9[which(is.nan(x1))]
u2 = which(is.nan(x1))

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_Ctrl[u1[k], 4])/((g_Ctrl[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

Mean_Loc_Max[which(!is.na(Mean_Loc_Max[,1])), 11] = overlap


# ---> 8.2 RNase_overlap
l_RNase = Mean_Loc_Max[which(!is.na(Mean_Loc_Max[,6])), 7:10]
g_RNase = RNase_Gauss_Fit[which(!is.na(Mean_Loc_Max[,6])), ]

overlap = rep(NA, length(which(!is.na(Mean_Loc_Max[,6]))))

g1 = which(g_RNase[, 2] == l_RNase[, 2] & g_RNase[, 1] == l_RNase[, 1] & g_RNase[, 3] == l_RNase[, 3])

if(length(g1) != 0) {
overlap[g1] = 1}

g2 = which(g_RNase[, 2] == l_RNase[, 2] & g_RNase[, 1] > l_RNase[, 1])

x = ((g_RNase[g2, 2])^(2) * log(g_RNase[g2, 3]/l_RNase[g2, 3]))/(l_RNase[g2, 1] -  g_RNase[g2, 1]) + (l_RNase[g2, 1] + g_RNase[g2, 1])/2

if(length(g2) != 0) {
overlap[g2] = sapply(seq(1,length(g2),1), function(k) {
  (g_RNase[g2[k], 3] * (pnorm(x[k], mean = g_RNase[g2[k], 1], sd = g_RNase[g2[k], 2]) - pnorm(0, mean = g_RNase[g2[k], 1], sd = g_RNase[g2[k], 2])) + l_RNase[g2[k], 3] * (pnorm(25, mean = l_RNase[g2[k], 1], sd = l_RNase[g2[k], 2]) - pnorm(x[k], mean = l_RNase[g2[k], 1], sd = l_RNase[g2[k], 2])))/((g_RNase[g2[k], 4] + l_RNase[g2[k], 4])/2)
})}

g3 = which(g_RNase[, 2] == l_RNase[, 2] & g_RNase[, 1] < l_RNase[, 1])

x = ((g_RNase[g3, 2])^(2) * log(g_RNase[g3, 3]/l_RNase[g3, 3]))/(l_RNase[g3, 1] -  g_RNase[g3, 1]) + (l_RNase[g3, 1] + g_RNase[g3, 1])/2

if(length(g3) != 0) {
overlap[g3] = sapply(seq(1,length(g3),1), function(k) {
  (l_RNase[g3[k], 3] * (pnorm(x[k], mean = l_RNase[g3[k], 1], sd = l_RNase[g3[k], 2]) - pnorm(0, mean = l_RNase[g3[k], 1], sd = l_RNase[g3[k], 2])) + g_RNase[g3[k], 3] * (pnorm(25, mean = g_RNase[g3[k], 1], sd = g_RNase[g3[k], 2]) - pnorm(x[k], mean = g_RNase[g3[k], 1], sd = g_RNase[g3[k], 2])))/((g_RNase[g3[k], 4] + l_RNase[g3[k], 4])/2)
})}

g4 = which(g_RNase[, 2] == l_RNase[, 2] & g_RNase[, 1] == l_RNase[, 1] & g_RNase[, 3] > l_RNase[, 3])

if(length(g4) != 0) {
overlap[g4] = sapply(seq(1, length(g4), 1), function(k) {
  (l_RNase[g4[k], 4])/((g_RNase[g4[k], 4] + l_RNase[g4[k], 4])/2)
})}

g5 = which(g_RNase[, 2] == l_RNase[, 2] & g_RNase[, 1] == l_RNase[, 1] & g_RNase[, 3] < l_RNase[, 3])

if(length(g5) != 0) {
overlap[g5] = sapply(seq(1, length(g5), 1), function(k) {
  (g_RNase[g5[k], 4])/((g_RNase[g5[k], 4] + l_RNase[g5[k], 4])/2)
})}

g6 = which(g_RNase[, 2] > l_RNase[, 2] & g_RNase[, 3] <= l_RNase[, 3])

a = (1/(g_RNase[g6,2])^2 - 1/(l_RNase[g6,2])^2)
b = 2 * ((l_RNase[g6,1])/(l_RNase[g6,2])^2 - (g_RNase[g6,1])/(g_RNase[g6,2])^2)
c = (g_RNase[g6,1]/g_RNase[g6,2])^2 - (l_RNase[g6,1]/l_RNase[g6,2])^2 - 2 * log((g_RNase[g6,3] * l_RNase[g6,2])/(l_RNase[g6,3] * g_RNase[g6,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g6) != 0) {
u1 = g6[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) + pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + g_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])))/((g_RNase[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

if(length(g6) != 0) {
u1 = g6[which(x1 > 25)]
u2 = which(x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + g_RNase[u1[k], 3] * (pnorm(25, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])))/((g_RNase[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

if(length(g6) != 0) {
u1 = g6[which(x2 < 0)]
u2 = which(x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + g_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(0, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])))/((g_RNase[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

g7 = which(g_RNase[, 2] > l_RNase[, 2] & g_RNase[, 3] > l_RNase[, 3])

a = (1/(g_RNase[g7,2])^2 - 1/(l_RNase[g7,2])^2)
b = 2 * ((l_RNase[g7,1])/(l_RNase[g7,2])^2 - (g_RNase[g7,1])/(g_RNase[g7,2])^2)
c = (g_RNase[g7,1]/g_RNase[g7,2])^2 - (l_RNase[g7,1]/l_RNase[g7,2])^2 - 2 * log((g_RNase[g7,3] * l_RNase[g7,2])/(l_RNase[g7,3] * g_RNase[g7,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g7) != 0) {
u1 = g7[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) + pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + g_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])))/((g_RNase[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

if(length(g7) != 0) {
u1 = g7[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + g_RNase[u1[k], 3] * (pnorm(25, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])))/((g_RNase[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

if(length(g7) != 0) {
u1 = g7[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + g_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(0, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])))/((g_RNase[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

if(length(g7) != 0) {
u1 = g7[which(is.nan(x1))]
u2 = which(is.nan(x1))

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 4])/((g_RNase[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

g8 = which(g_RNase[, 2] < l_RNase[, 2] & g_RNase[, 3] >= l_RNase[, 3])

a = (1/(g_RNase[g8,2])^2 - 1/(l_RNase[g8,2])^2)
b = 2 * ((l_RNase[g8,1])/(l_RNase[g8,2])^2 - (g_RNase[g8,1])/(g_RNase[g8,2])^2)
c = (g_RNase[g8,1]/g_RNase[g8,2])^2 - (l_RNase[g8,1]/l_RNase[g8,2])^2 - 2 * log((g_RNase[g8,3] * l_RNase[g8,2])/(l_RNase[g8,3] * g_RNase[g8,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g8) != 0) {
u1 = g8[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(0, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) + pnorm(25, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((g_RNase[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

if(length(g8) != 0) {
u1 = g8[which(x1 > 25)]
u2 = which(x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(0, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((g_RNase[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

if(length(g8) != 0) {
u1 = g8[which(x2 < 0)]
u2 = which(x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_RNase[u1[k], 3] * (pnorm(25, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((g_RNase[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

g9 = which(g_RNase[, 2] < l_RNase[, 2] & g_RNase[, 3] < l_RNase[, 3])

a = (1/(g_RNase[g9,2])^2 - 1/(l_RNase[g9,2])^2)
b = 2 * ((l_RNase[g9,1])/(l_RNase[g9,2])^2 - (g_RNase[g9,1])/(g_RNase[g9,2])^2)
c = (g_RNase[g9,1]/g_RNase[g9,2])^2 - (l_RNase[g9,1]/l_RNase[g9,2])^2 - 2 * log((g_RNase[g9,3] * l_RNase[g9,2])/(l_RNase[g9,3] * g_RNase[g9,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g9) != 0) {
u1 = g9[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(0, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) + pnorm(25, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((l_RNase[u1[k], 4] + g_RNase[u1[k], 4])/2)
})}}

if(length(g9) != 0) {
u1 = g9[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(0, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((l_RNase[u1[k], 4] + g_RNase[u1[k], 4])/2)
})}}

if(length(g9) != 0) {
u1 = g9[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_RNase[u1[k], 3] * (pnorm(25, mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = g_RNase[u1[k], 1], sd = g_RNase[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((l_RNase[u1[k], 4] + g_RNase[u1[k], 4])/2)
})}}

if(length(g9) != 0) {
u1 = g9[which(is.nan(x1))]
u2 = which(is.nan(x1))

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (g_RNase[u1[k], 4])/((g_RNase[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

Mean_Loc_Max[which(!is.na(Mean_Loc_Max[,6])), 12] = overlap


# ---> 8.3 Loc_overlap
l_Ctrl = Mean_Loc_Max[which(!is.na(Mean_Loc_Max[,1]) & !is.na(Mean_Loc_Max[,6])), 2:5]
l_RNase = Mean_Loc_Max[which(!is.na(Mean_Loc_Max[,1]) & !is.na(Mean_Loc_Max[,6])), 7:10]

overlap = rep(NA, length(which(!is.na(Mean_Loc_Max[,1]) & !is.na(Mean_Loc_Max[,6]))))

g1 = which(l_RNase[, 2] == l_Ctrl[, 2] & l_RNase[, 1] == l_Ctrl[, 1] & l_RNase[, 3] == l_Ctrl[, 3])

if(length(g1) != 0) {
overlap[g1] = 1}

g2 = which(l_RNase[, 2] == l_Ctrl[, 2] & l_RNase[, 1] > l_Ctrl[, 1])

x = ((l_RNase[g2, 2])^(2) * log(l_RNase[g2, 3]/l_Ctrl[g2, 3]))/(l_Ctrl[g2, 1] -  l_RNase[g2, 1]) + (l_Ctrl[g2, 1] + l_RNase[g2, 1])/2

if(length(g2) != 0) {
overlap[g2] = sapply(seq(1,length(g2),1), function(k) {
  (l_RNase[g2[k], 3] * (pnorm(x[k], mean = l_RNase[g2[k], 1], sd = l_RNase[g2[k], 2]) - pnorm(0, mean = l_RNase[g2[k], 1], sd = l_RNase[g2[k], 2])) + l_Ctrl[g2[k], 3] * (pnorm(25, mean = l_Ctrl[g2[k], 1], sd = l_Ctrl[g2[k], 2]) - pnorm(x[k], mean = l_Ctrl[g2[k], 1], sd = l_Ctrl[g2[k], 2])))/((l_RNase[g2[k], 4] + l_Ctrl[g2[k], 4])/2)
})}

g3 = which(l_RNase[, 2] == l_Ctrl[, 2] & l_RNase[, 1] < l_Ctrl[, 1])

x = ((l_RNase[g3, 2])^(2) * log(l_RNase[g3, 3]/l_Ctrl[g3, 3]))/(l_Ctrl[g3, 1] -  l_RNase[g3, 1]) + (l_Ctrl[g3, 1] + l_RNase[g3, 1])/2

if(length(g3) != 0) {
overlap[g3] = sapply(seq(1,length(g3),1), function(k) {
  (l_Ctrl[g3[k], 3] * (pnorm(x[k], mean = l_Ctrl[g3[k], 1], sd = l_Ctrl[g3[k], 2]) - pnorm(0, mean = l_Ctrl[g3[k], 1], sd = l_Ctrl[g3[k], 2])) + l_RNase[g3[k], 3] * (pnorm(25, mean = l_RNase[g3[k], 1], sd = l_RNase[g3[k], 2]) - pnorm(x[k], mean = l_RNase[g3[k], 1], sd = l_RNase[g3[k], 2])))/((l_RNase[g3[k], 4] + l_Ctrl[g3[k], 4])/2)
})}

g4 = which(l_RNase[, 2] == l_Ctrl[, 2] & l_RNase[, 1] == l_Ctrl[, 1] & l_RNase[, 3] > l_Ctrl[, 3])

if(length(g4) != 0) {
overlap[g4] = sapply(seq(1, length(g4), 1), function(k) {
  (l_Ctrl[g4[k], 4])/((l_RNase[g4[k], 4] + l_Ctrl[g4[k], 4])/2)
})}

g5 = which(l_RNase[, 2] == l_Ctrl[, 2] & l_RNase[, 1] == l_Ctrl[, 1] & l_RNase[, 3] < l_Ctrl[, 3])

if(length(g5) != 0) {
overlap[g5] = sapply(seq(1, length(g5), 1), function(k) {
  (l_RNase[g5[k], 4])/((l_RNase[g5[k], 4] + l_Ctrl[g5[k], 4])/2)
})}

g6 = which(l_RNase[, 2] > l_Ctrl[, 2] & l_RNase[, 3] <= l_Ctrl[, 3])

a = (1/(l_RNase[g6,2])^2 - 1/(l_Ctrl[g6,2])^2)
b = 2 * ((l_Ctrl[g6,1])/(l_Ctrl[g6,2])^2 - (l_RNase[g6,1])/(l_RNase[g6,2])^2)
c = (l_RNase[g6,1]/l_RNase[g6,2])^2 - (l_Ctrl[g6,1]/l_Ctrl[g6,2])^2 - 2 * log((l_RNase[g6,3] * l_Ctrl[g6,2])/(l_Ctrl[g6,3] * l_RNase[g6,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g6) != 0) {
u1 = g6[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) + pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((l_RNase[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g6) != 0) {
u1 = g6[which(x1 > 25)]
u2 = which(x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((l_RNase[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g6) != 0) {
u1 = g6[which(x2 < 0)]
u2 = which(x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((l_RNase[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

g7 = which(l_RNase[, 2] > l_Ctrl[, 2] & l_RNase[, 3] > l_Ctrl[, 3])

a = (1/(l_RNase[g7,2])^2 - 1/(l_Ctrl[g7,2])^2)
b = 2 * ((l_Ctrl[g7,1])/(l_Ctrl[g7,2])^2 - (l_RNase[g7,1])/(l_RNase[g7,2])^2)
c = (l_RNase[g7,1]/l_RNase[g7,2])^2 - (l_Ctrl[g7,1]/l_Ctrl[g7,2])^2 - 2 * log((l_RNase[g7,3] * l_Ctrl[g7,2])/(l_Ctrl[g7,3] * l_RNase[g7,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g7) != 0) {
u1 = g7[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) + pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((l_RNase[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g7) != 0) {
u1 = g7[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((l_RNase[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g7) != 0) {
u1 = g7[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 3] * (pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])) + l_RNase[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])))/((l_RNase[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g7) != 0) {
u1 = g7[which(is.nan(x1))]
u2 = which(is.nan(x1))

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_Ctrl[u1[k], 4])/((l_RNase[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

g8 = which(l_RNase[, 2] < l_Ctrl[, 2] & l_RNase[, 3] >= l_Ctrl[, 3])

a = (1/(l_RNase[g8,2])^2 - 1/(l_Ctrl[g8,2])^2)
b = 2 * ((l_Ctrl[g8,1])/(l_Ctrl[g8,2])^2 - (l_RNase[g8,1])/(l_RNase[g8,2])^2)
c = (l_RNase[g8,1]/l_RNase[g8,2])^2 - (l_Ctrl[g8,1]/l_Ctrl[g8,2])^2 - 2 * log((l_RNase[g8,3] * l_Ctrl[g8,2])/(l_Ctrl[g8,3] * l_RNase[g8,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g8) != 0) {
u1 = g8[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) + pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((l_RNase[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g8) != 0) {
u1 = g8[which(x1 > 25)]
u2 = which(x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((l_RNase[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

if(length(g8) != 0) {
u1 = g8[which(x2 < 0)]
u2 = which(x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((l_RNase[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

g9 = which(l_RNase[, 2] < l_Ctrl[, 2] & l_RNase[, 3] < l_Ctrl[, 3])

a = (1/(l_RNase[g9,2])^2 - 1/(l_Ctrl[g9,2])^2)
b = 2 * ((l_Ctrl[g9,1])/(l_Ctrl[g9,2])^2 - (l_RNase[g9,1])/(l_RNase[g9,2])^2)
c = (l_RNase[g9,1]/l_RNase[g9,2])^2 - (l_Ctrl[g9,1]/l_Ctrl[g9,2])^2 - 2 * log((l_RNase[g9,3] * l_Ctrl[g9,2])/(l_Ctrl[g9,3] * l_RNase[g9,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

if(length(g9) != 0) {
u1 = g9[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) + pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((l_Ctrl[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

if(length(g9) != 0) {
u1 = g9[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(x2[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(0, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(25, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(x2[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((l_Ctrl[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

if(length(g9) != 0) {
u1 = g9[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 3] * (pnorm(25, mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2]) - pnorm(x1[u2[k]], mean = l_RNase[u1[k], 1], sd = l_RNase[u1[k], 2])) + l_Ctrl[u1[k], 3] * (pnorm(x1[u2[k]], mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2]) - pnorm(0, mean = l_Ctrl[u1[k], 1], sd = l_Ctrl[u1[k], 2])))/((l_Ctrl[u1[k], 4] + l_RNase[u1[k], 4])/2)
})}}

if(length(g9) != 0) {
u1 = g9[which(is.nan(x1))]
u2 = which(is.nan(x1))

if(length(u1) != 0 | length(u2) != 0) {
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (l_RNase[u1[k], 4])/((l_RNase[u1[k], 4] + l_Ctrl[u1[k], 4])/2)
})}}

Mean_Loc_Max[which(!is.na(Mean_Loc_Max[,1]) & !is.na(Mean_Loc_Max[,6])), 13] = overlap

rm(g1, g2, g3, g4, g5, g6, g7, g8, g9, u1, u2, a, b, c, x, x1, x2, overlap, l_RNase, g_Ctrl, l_Ctrl, g_RNase)

colnames(Mean_Loc_Max) = c(colnames(Mean_Loc_Max)[-c(11,12,13)], "Ctrl_overlap", "RNase_overlap", "Loc_overlap")
```


#### 4. Selection Criteria and Identification of RNA-Dependent Proteins


##### 4.1 Summary of Collected Data in one Dataframe

We will now summarize all our collected data (*global* and *local peak positions*, *gaussian fittings* and *overlaps*) in one dataframe called "**Summary**": 

```{r}
Summary = as.data.frame(cbind(
  Mean_Gbl_Max[, 1],   # ---> Global peak positions for Ctrl
  Ctrl_Gauss_Fit[, 1:4],   # ---> Gaussian Fitting Ctrl: mu, sd, h, prt_amount
  Mean_Gbl_Max[, 2],   # ---> Global peak positions for RNase
  RNase_Gauss_Fit[, 1:4],   # ---> Gaussian Fitting RNase: mu, sd, h, prt_amount
  Ctrl_Gauss_Fit[, 5],   # ---> Gaussian Fitting: overlap
  as.matrix(sapply(seq(1, nrow(Ctrl_Mean_Loc_Max), 1), function(k) {unlist(Ctrl_Mean_Loc_Max[k, which(!is.na(Ctrl_Mean_Loc_Max[k,]))], use.names = F)})),   # ---> all local peak positions for Ctrl 
  Mean_Loc_Max[, 1:5],  # ---> Main local peak positions and gaussian fittings for Ctrl
  as.matrix(sapply(seq(1, nrow(RNase_Mean_Loc_Max), 1), function(k) {unlist(RNase_Mean_Loc_Max[k, which(!is.na(RNase_Mean_Loc_Max[k,]))], use.names = F)})),   # ---> all local peak positions for RNase
  Mean_Loc_Max[, 6:10],  # ---> Main local peak positions and gaussian fittings for RNase
  Mean_Loc_Max[, 11:13]  # ---> Overlaps between gaussian curves of local and global peaks
  ))

colnames(Summary) <- c("Ctrl_Gbl_Max", "Ctrl_Gbl_mu", "Ctrl_Gbl_sd", "Ctrl_Gbl_h", "Ctrl_Gbl_prt_amount", "RNase_Gbl_Max", "RNase_Gbl_mu", "RNase_Gbl_sd", "RNase_Gbl_h", "RNase_Gbl_prt_amount", "Gbl_overlap", "Ctrl_Loc_Max", "Ctrl_Loc_Main", "Ctrl_Loc_mu", "Ctrl_Loc_sd", "Ctrl_Loc_h", "Ctrl_Loc_prt_amount", "RNase_Loc_Max", "RNase_Loc_Main", "RNase_Loc_mu", "RNase_Loc_sd", "RNase_Loc_h", "RNase_Loc_prt_amount", "Ctrl_overlap", "RNase_overlap", "Loc_overlap")

head(Summary)
```


##### 4.2 Comparison between Ctrl and RNase Samples & Categorization

Based on the variables collected in the dataframe **Summary** we can now calculate the absolute and relative changes between the Ctrl and RNase samples for each gene. The resulting variables are stored in the dataframe "**Sel_Crit**" (short for *"Selection Criteria"*).

The variables are the following:

  1. **delta_Gbl_mu**: absolute peak shift between the Ctrl and RNase global peaks (mu1 - mu2)
  2. **delta_Gbl_mu_%**: percentage of peak shift between the Ctrl and RNase global peaks ((mu1 - mu2)/25)
  
  3. **delta_Gbl_sd**: absolute change in the standard deviation between Ctrl and RNase (sd2 - sd1)
  4. **delta_Gbl_sd_%**: percentage of change in the standard deviation between Ctrl and RNase (sd2/sd1 - 1)
  
  5. **delta_Gbl_h**: absolute change in global peak height between Ctrl and RNase (h2 - h1)
  6. **delta_Gbl_h_%**: percentage of change in peak height between Ctrl and RNase (h2/h1 - 1)
  
  7. **delta_Gbl_prt_amount**: absolute change between the protein amount under the gaussian curves of the Ctrl and RNase peaks (peak_prt2 - peak_prt1)
  8. **delta_Gbl_prt_amount_%**: percentage of change between the protein amount under the gaussian curves of the Ctrl and RNase peaks (peak_prt2/peak_prt1 - 1)
  
  9. **Ctrl_Gbl_prt_prop**: absolute protein amount that is lost under the global peak of Ctrl after RNase treatment (prt1 - prt2)
  10. **Ctrl_Gbl_prt_prop_%**: how much percent of protein amount under the Ctrl peak is lost upon RNase treatment? (1 - prt2/prt1)
  
  11. **RNase_Gbl_prt_prop**: absolute protein amount that is gained under the globak peak of RNase after RNase treatment (prt2 - prt1)
  12. **RNase_Gbl_prt_prop_%**: how much percent of protein amount under the RNase peak is gained upon RNase treatment? (1 - prt1/prt2)
  
  13. **Gbl_overlap_%**: percentage of overlap between the gaussian curves of Ctrl and RNase 
  
  14. **delta_g_l_Ctrl_mu**: absolute peak shift between the global and main local peak of Ctrl (mu_g - mu_l)
  15. **delta_g_l_Ctrl_mu_%**: percentage of peak shift between the global and main local peak of Ctrl ((mu_g - mu_l)/25)
  
  16. **delta_g_l_RNase_mu**: absolute peak shift between the global and main local peak of RNase (mu_g - mu_l)
  17. **delta_g_l_RNase_mu_%**: percentage of peak shift between the global and main local peak of Ctrl ((mu_g - mu_l)/25)
  
  18. **Ctrl_overlap_%**: percentage of overlap between the gaussian curves of main local peak and global peak of Ctrl
  19. **RNase_overlap_%**: percentage of overlap between the gaussian curves of main local peak and global peak of RNase
  20. **Loc_overlap_%**: percentage of overlap between the gaussian curves of main local peaks Ctrl and RNase
  
  21. **Ctrl_Loc_prt_prop**: absolute difference in the protein amounts of Ctrl and RNase samples under the main local Ctrl peak
  22. **Ctrl_Loc_prt_prop_%**: percentage of difference in the protein amounts of Ctrl and RNase samples under the main local Ctrl peak
  
  23. **Ctrl_Loc_prt_prop**: absolute difference in the protein amounts of Ctrl and RNase samples under the main local RNase peak
  24. **Ctrl_Loc_prt_prop_%**: percentage of difference in the protein amounts of Ctrl and RNase samples under the main local RNase peak
  
  25. **shift**: character variable that states whether a protein is **left**, **right** or **non** shifting (shifting defined as delta mu gbl over 1 fraction) or **precipitated** (if one of the global peaks are over 24) (not used directly in PCA but for visualizing the results)
  

**Note**: *"Ctrl_Gbl_prt_prop"*, *"RNase_Gbl_prt_prop"*, *"Ctrl_Loc_prt_prop"* and *"RNase_Loc_prt_prop"* are computed by calculating the x-values (x1 and x2) for which the fitted gaussian curves reach their half maximum y-value (max(y)/2) and then computing the area under the smoothed and normalized protein distributions of Ctrl and RNase in the interval [floor(x2), ceiling(x1)].

```{r}
# ---> Erstellen eines leeren Dataframes (nur eine Spalte NA -> weiter Spalten können angefügt werden)
Sel_Crit = as.data.frame(rep(NA, nrow(Ctrl_RDeep)))

# ---> 1. "delta_Gbl_mu": Berechnung des absoluten Peak Shifts über alle Gene
Sel_Crit[, 1] = Summary[, 2] - Summary[, 7]

# ---> 2. "delta_Gbl_mu_%": Berechnung des prozentualen Peak Shifts über alle Gene
Sel_Crit[, 2] = (Summary[, 2] - Summary[, 7])/25


# ---> 3. "delta_Gbl_sd": Berechnung der absoluten Veränderung der Standardabweichung zwischen Ctrl und RNase für alle Gene
Sel_Crit[, 3] = Summary[, 8] - Summary[, 3]

# ---> 4. "delta_Gbl_sd_%": Berechnung der prozentualen Veränderung der Standardabweichung zwischen Ctrl und RNase für alle Gene
Sel_Crit[, 4] = Summary[, 8]/Summary[, 3] - 1


# ---> 5. "delta_Gbl_h": Berechnung der absoluten Veränderung der Höhe zwischen Ctrl und RNase für alle Gene
Sel_Crit[, 5] = Summary[, 9] - Summary[, 4] 

# ---> 6. "delta_Gbl_h_%": Berechnung der prozentualen Veränderung der Höhe zwischen Ctrl und RNase für alle Gene
Sel_Crit[, 6] = Summary[, 9]/Summary[, 4] - 1


# ---> 7. "delta_Gbl_prt_amount": Berechnung der absoluten Veränderung des Protein-Anteils unter den Gaußkurven zwischen Ctrl und RNase
Sel_Crit[, 7] = Summary[, 10] - Summary[, 5]

# ---> 8. "delta_Gbl_prt_amount_%": Berechnung der prozentualen Veränderung des Protein-Anteils unter den Gaußkurven zwischen Ctrl und RNase
Sel_Crit[, 8] = Summary[, 10]/Summary[, 5] - 1


# ---> 9. "Ctrl_Gbl_prt_prop": Berechnung des Verlusts an Protein unter dem Ctrl peak nach Zugabe von RNase
# ---> 9. "Ctrl_Gbl_prt_prop": 1. Berechnung der Fraktions-Werte für die gilt, dass der y-Wert der Gausskurve für Ctrl bei 2 liegt 
x1 = sqrt(- Ctrl_Gauss_Fit[, 2] * log(0.5)) + Ctrl_Gauss_Fit[, 1]
x2 = - sqrt(- Ctrl_Gauss_Fit[, 2] * log(0.5)) + Ctrl_Gauss_Fit[, 1]

# ---> 9. "Ctrl_Gbl_prt_prop": 2. Ersetzen aller Werte über 25 mit 25 und unter 1 mit 1 (Fraktion 0 existiert nicht im Datensatz)
x1[which(x1 > 25)] = 25
x2[which(x2 < 1)] = 1 

# ---> 9. "Ctrl_Gbl_prt_prop": 3. Runden der erhaltenen Fraktions-Werte auf ganze Zahlen (Note: x1 > x2 für alle Gene)
x1 = ceiling(x1)
x2 = floor(x2)

# ---> 9. "Ctrl_Gbl_prt_prop": 4. Erstellen einer Sequenz für jedes Gen, die von x2 bis x1 - 1 geht (für die Berechnung der Fläche unter der Kurve nur anhand der Daten aus "Ctrl_Mean_Smooth_Norm100" bzw. "RNase_Mean_Smooth_Norm100")
Fra.Pos = sapply(seq(1, nrow(Sel_Crit), 1), function(n) {seq(x2[n], x1[n] - 1, 1)})

# ---> 9. "Ctrl_Gbl_prt_prop": 5. Berechnung des Protein-Anteils unter der geglätteten und normalisierten Protein-Verteilung von Ctrl anhand von "Fra.Pos" (mathematische Flächenberechnung von Trapezen)
Ctrl_prt_amount = sapply(seq(1, nrow(Sel_Crit), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (Ctrl_Mean_Smooth_Norm100[n, Fra.Pos[[n]][i]] + Ctrl_Mean_Smooth_Norm100[n, Fra.Pos[[n]][i] + 1])})))})

# ---> 9. "Ctrl_Gbl_prt_prop": 6. Gleiche Berechnung für RNase (Note: hier an der Position des globalen Maximums der Ctrl-Verteilung)
RNase_prt_amount = sapply(seq(1, nrow(Sel_Crit), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (RNase_Mean_Smooth_Norm100[n, Fra.Pos[[n]][i]] + RNase_Mean_Smooth_Norm100[n, Fra.Pos[[n]][i] + 1])})))})

# ---> 9. "Ctrl_Gbl_prt_prop": 7. Berechnung des absoluten Verlustes an Protein unter dem globalen Maximums der Ctrl Probe nach Zugabe von RNase
Sel_Crit[, 9] = Ctrl_prt_amount - RNase_prt_amount

# ---> 10. "Ctrl_Gbl_prt_prop_%": 8. Berechnung, um wie viel Prozent der Protein-Anteil unter dem globalen Maximums der Ctrl abnimmt nach Zugabe von RNase
Sel_Crit[, 10] = 1 - RNase_prt_amount/Ctrl_prt_amount


# ---> 11./12. "RNase_Gbl_prt_prop" und "RNase_Gbl_prt_prop_%": Gleiche Berechnungen wie für "Ctrl_Gbl_prt_prop" und "Ctrl_Gbl_prt_prop_%" für RNase (Note: hier wird aber berechnet, um wie viel Prozent der Protein-Anteil unter dem globalen Maximum der RNase *zunimmt* nach RNase-Zugabe)
x1 = sqrt(- RNase_Gauss_Fit[, 2] * log(0.5)) + RNase_Gauss_Fit[, 1]
x2 = - sqrt(- RNase_Gauss_Fit[, 2] * log(0.5)) + RNase_Gauss_Fit[, 1]

x1[which(x1 > 25)] = 25
x2[which(x2 < 1)] = 1 

x1 = ceiling(x1)
x2 = floor(x2)

Fra.Pos = sapply(seq(1, nrow(Sel_Crit), 1), function(n) {seq(x2[n], x1[n] - 1, 1)})

Ctrl_prt_amount = sapply(seq(1, nrow(Sel_Crit), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (Ctrl_Mean_Smooth_Norm100[n, Fra.Pos[[n]][i]] + Ctrl_Mean_Smooth_Norm100[n, Fra.Pos[[n]][i] + 1])})))})

RNase_prt_amount = sapply(seq(1, nrow(Sel_Crit), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (RNase_Mean_Smooth_Norm100[n, Fra.Pos[[n]][i]] + RNase_Mean_Smooth_Norm100[n, Fra.Pos[[n]][i] + 1])})))})

# ---> 11. "RNase_Gbl_prt_prop"
Sel_Crit[, 11] = RNase_prt_amount - Ctrl_prt_amount

# ---> 12. "RNase_Gbl_prt_prop_%"
Sel_Crit[, 12] = 1 - Ctrl_prt_amount/RNase_prt_amount


# ---> 13. "Gbl_overlap_%": Hinzufügen der prozentualen Überlappung der Gaußkurven von Ctrl und RNase (Berechnung: s. "3.4 Calculation of Gaussian Overlap")
Sel_Crit[, 13] = Summary[, 11]

# ---> 14. "delta_g_l_Ctrl_mu": Berechnung des absoluten Shifts zwischen globalen und main lokalen Peak von Ctrl
Sel_Crit[, 14] = Summary[, 2] - Summary[, 14]

# ---> 15. "delta_g_l_Ctrl_mu_%": Berechnung des prozentualen Shifts zwischen globalen und main lokalen Peak von Ctrl
Sel_Crit[, 15] = (Summary[, 2] - Summary[, 14])/25

# ---> 16. "delta_g_l_RNase_mu":  Berechnung des absoluten Shifts zwischen globalen und main lokalen Peak von RNase
Sel_Crit[, 16] = Summary[, 7] - Summary[, 20]

# ---> 17. "delta_g_l_RNase_mu_%": Berechnung des prozentualen Shifts zwischen globalen und main lokalen Peak von RNase
Sel_Crit[, 17] = (Summary[, 7] - Summary[, 20])/25

# ---> 18. "Ctrl_overlap_%": Hinzufügen des prozentualen Überlappung der Gaußkurven vom lokalen Peak und globalen Peak Ctrl
Sel_Crit[, 18] = Summary[, 24]

# ---> 19. "RNase_overlap_%": Hinzufügen des prozentualen Überlappung der Gaußkurven vom lokalen Peak und globalen Peak RNase
Sel_Crit[, 19] = Summary[, 25]

# ---> 20. "Loc_overlap_%": Hinzufügen des prozentualen Überlappung der Gaußkurven der lokalen Peaks
Sel_Crit[, 20] = Summary[, 26]

# ---> 21./22. "Ctrl_Loc_prt_prop"/"Ctrl_Loc_prt_prop_%": Veränderung des Protein Anteils unter dem lokalen Haupt-Peak von Ctrl (analog zu 9. "Ctrl_Gbl_prt_prop")
l_Ctrl = na.omit(Summary[, 14:17])

x1 = sqrt(- l_Ctrl[, 2] * log(0.5)) + l_Ctrl[, 1]
x2 = - sqrt(- l_Ctrl[, 2] * log(0.5)) + l_Ctrl[, 1]

x1[which(x1 > 25)] = 25
x2[which(x2 < 1)] = 1 

x1 = ceiling(x1)
x2 = floor(x2)

Fra.Pos = sapply(seq(1, nrow(l_Ctrl), 1), function(n) {seq(x2[n], x1[n] - 1, 1)})

Ctrl_prt_amount = sapply(seq(1, nrow(l_Ctrl), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (Ctrl_Mean_Smooth_Norm100[which(!is.na(Summary[, 14]))[n], Fra.Pos[[n]][i]] + Ctrl_Mean_Smooth_Norm100[which(!is.na(Summary[, 14]))[n], Fra.Pos[[n]][i] + 1])})))})

RNase_prt_amount = sapply(seq(1, nrow(l_Ctrl), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (RNase_Mean_Smooth_Norm100[which(!is.na(Summary[, 14]))[n], Fra.Pos[[n]][i]] + RNase_Mean_Smooth_Norm100[which(!is.na(Summary[, 14]))[n], Fra.Pos[[n]][i] + 1])})))})

# ---> 21. "Ctrl_Loc_prt_prop"
Sel_Crit[which(!is.na(Summary[, 14])), 21] = Ctrl_prt_amount - RNase_prt_amount

# ---> 22. "Ctrl_Loc_prt_prop_%"
Sel_Crit[which(!is.na(Summary[, 14])), 22] = 1 - RNase_prt_amount/Ctrl_prt_amount


# ---> 23./24. "RNase_Loc_prt_prop"/"RNase_Loc_prt_prop_%": analog zu 11. "RNase_Gbl_prt_prop"
l_RNase = na.omit(Summary[, 20:23])

x1 = sqrt(- l_RNase[, 2] * log(0.5)) + l_RNase[, 1]
x2 = - sqrt(- l_RNase[, 2] * log(0.5)) + l_RNase[, 1]

x1[which(x1 > 25)] = 25
x2[which(x2 < 1)] = 1 

x1 = ceiling(x1)
x2 = floor(x2)

Fra.Pos = sapply(seq(1, nrow(l_RNase), 1), function(n) {seq(x2[n], x1[n] - 1, 1)})

Ctrl_prt_amount = sapply(seq(1, nrow(l_RNase), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (Ctrl_Mean_Smooth_Norm100[which(!is.na(Summary[, 20]))[n], Fra.Pos[[n]][i]] + Ctrl_Mean_Smooth_Norm100[which(!is.na(Summary[, 20]))[n], Fra.Pos[[n]][i] + 1])})))})

RNase_prt_amount = sapply(seq(1, nrow(l_RNase), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (RNase_Mean_Smooth_Norm100[which(!is.na(Summary[, 20]))[n], Fra.Pos[[n]][i]] + RNase_Mean_Smooth_Norm100[which(!is.na(Summary[, 20]))[n], Fra.Pos[[n]][i] + 1])})))})

# ---> 23. "RNase_Loc_prt_prop"
Sel_Crit[which(!is.na(Summary[, 20])), 23] = RNase_prt_amount - Ctrl_prt_amount

# ---> 24. "RNase_Loc_prt_prop_%"
Sel_Crit[which(!is.na(Summary[, 20])), 24] = 1 - Ctrl_prt_amount/RNase_prt_amount


## ---> Kategorisierung
# ---> 25. "shift": Kategorisieren der Gene in "left", "right" and "no" shifting und "precipitated" anhand der Mittelwerte der gefitteten Gaußkurven (wir gehen erst von einem Shift aus, wenn die Differenz der Mittelwerte größer als 1 Fraktion ist)
Sel_Crit[, 25] = rep(NA, nrow(Sel_Crit))
Sel_Crit[which((Ctrl_Gauss_Fit[, 1] - RNase_Gauss_Fit[, 1]) > 1 & !(Ctrl_Gauss_Fit[, 1] > 24 | RNase_Gauss_Fit[, 1] > 24)), 25] = "left"
Sel_Crit[which((Ctrl_Gauss_Fit[, 1] - RNase_Gauss_Fit[, 1]) < -1 & !(Ctrl_Gauss_Fit[, 1] > 24 | RNase_Gauss_Fit[, 1] > 24)), 25] = "right"
Sel_Crit[which(Ctrl_Gauss_Fit[, 1] > 24 | RNase_Gauss_Fit[, 1] > 24), 25] = "precipitated"
Sel_Crit[which((Ctrl_Gauss_Fit[, 1] - RNase_Gauss_Fit[, 1]) <= 1 & (Ctrl_Gauss_Fit[, 1] - RNase_Gauss_Fit[, 1]) >= -1 & !(Ctrl_Gauss_Fit[, 1] > 24 | RNase_Gauss_Fit[, 1] > 24)), 25] = "no"


# ---> Benennung der Zeilen und Spalten des Dataframes
rownames(Sel_Crit) = rownames(Summary)
colnames(Sel_Crit) = c("delta_Gbl_mu", "delta_Gbl_mu_%", "delta_Gbl_sd", "delta_Gbl_sd_%", "delta_Gbl_h", "delta_Gbl_h_%", "delta_Gbl_prt_amount", "delta_Gbl_prt_amount_%", "Ctrl_Gbl_prt_prop", "Ctrl_Gbl_prt_prop_%", "RNase_Gbl_prt_prop", "RNase_Gbl_prt_prop_%", "Gbl_overlap_%", "delta_g_l_Ctrl_mu", "delta_g_l_Ctrl_mu_%", "delta_g_l_RNase_mu", "delta_g_l_RNase_mu_%", "Ctrl_overlap_%", "RNase_overlap_%", "Loc_overlap_%", "Ctrl_Loc_prt_prop", "Ctrl_Loc_prt_prop_%", "RNase_Loc_prt_prop", "RNase_Loc_prt_prop_%","shift")

# ---> Entfernung erstellter Variablen
rm(Fra.Pos, x1, x2, Ctrl_prt_amount, RNase_prt_amount, l_Ctrl, l_RNase)

# ---> Wie sieht der Datensatz aus?
head(Sel_Crit)
```


##### 4.3 Visualization of Shifting Behavior

To visualize the shifting behavior of each gene, we plot the peak positions of the global peaks of the Control and RNase samples against each other (x: Ctrl peak positions; y: RNase peak positions). The genes will be colorized based on the column *"shift"* in the **Sel_Crit** dataframe according to their shifting behavior:

```{r}
# ---> Plotten der peak positions und Einfärben nach "left", "right", "precipitated" und "no" shifting
col = rep(NA, nrow(Ctrl_RDeep))
col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"

plot(Ctrl_Gauss_Fit[, 1], RNase_Gauss_Fit[, 1], pch = 16, col = col, main = "Shifting Behavior", xlab = "Ctrl Gbl Peak Position", ylab = "RNase Gbl Peak Position")
legend("topleft", legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))

rm(col)
```


##### 4.4 Principal Component Analysis of the Selection Criteria

We want to determine which selection criteria from the "**Sel_Crit**" dataframe separate our genes the best. To do this we will use **Principal Component Analysis (PCA)**. The main idea is that we will use PCA to reduce the dimensions of the dataframe "**Sel_Crit**". If our selection criteria are sufficient to determine the RNA-dependency of a protein the points in our reduced data set should separate nicely along these criteria. 

PCA results in new (non-correlating) variables (**Principal Components** (**PC**)):

**Note**: *Only the variables calculated in percent are used for PCA (so that they are comparable to each other).*

**Extra-Note**: *The variables regarding main local peaks will be used for identification of partially shifting RDPs but not in PCA because only 2360 genes have local peaks for Ctrl and RNase*

```{r}
# ---> PCA mit dem "prcomp" Befehl
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# ---> "$sdev" gibt die Standardabweichungen der PCs aus, also erhalten wir durch Quadrieren die Varianz der einzelnen PCs und, wenn wir diese durch die Gesamtvarianz teilen, den prozentualen Anteil der einzelnen PCs an der Gesamtvarianz des Datensatzes "Sel_Crit"
pca$sdev^2/(sum(pca$sdev^2))*100

# ---> "$rotation" gibt die loadings der einzelnen originalen Variablen an den PCs aus 
pca$rotation

rm(pca)
```

We can also visualize our PCA results by plotting the first 2 PCs (**Note**: *requires the packages "ggplot2" and "factoextra"*): 

```{r}
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# ---> Plot, der die Datenpunkte je nach Kategorisierung in "left", "right" und "no" shift einfärbt 
col = rep(NA, nrow(Sel_Crit))

col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"


plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Shifting Behavior", xlab = "PC1", ylab = "PC2")
legend("bottomright", legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))

# ---> Plot, der die Dichte der Punkteverteilung im Plot durch Farben anzeigt ("rot" = sehr dicht beieinander; "blau" = nicht dicht beieinander)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = densCols(pca$x[, 1], pca$x[, 2], colramp = colorRampPalette(c("blue", "cyan", "green", "yellow", "orange", "red"))), main = "Point Density", xlab = "PC1", ylab = "PC2")
abline(h = 0, lty =3, col = "grey")
abline(v = 0, lty = 3, col = "grey")


# --> Erstellen eines "Biplots" der die ersten zwei PCs mit den loadings der Variablen zeigt
library(ggplot2)
library(factoextra)

fviz_pca_biplot(pca, axes = c(1,2) , label = "var", col.var = "black", repel = T, col.ind = Sel_Crit[,25])

rm(col, pca)
```

We can also repeat the PCA but this time we will only apply it to the selection criteria **delta_Gbl_mu_%**, **Ctrl_Gbl_prt_prop_%**, **RNase_Gbl_prt_prop_%** and **Gbl_overlap_%**: 

```{r}
# ---> PCA
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

# ---> Plot, der die Datenpunkte je nach Kategorisierung in "left", "right" und "no" shift einfärbt 
col = rep(NA, nrow(Sel_Crit))
col[which(Sel_Crit[, 25] == "left")] = "blue"
col[which(Sel_Crit[, 25] == "right")] = "red"
col[which(Sel_Crit[, 25] == "precipitated")] = "orange"
col[which(Sel_Crit[, 25] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Shifting Behavior", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("left (", length(which(Sel_Crit[, 25] == "left")), ")", sep =""), paste("right (", length(which(Sel_Crit[, 25] == "right")), ")", sep =""), paste("precipitated (", length(which(Sel_Crit[, 25] == "precipitated")), ")", sep =""), paste("no (", length(which(Sel_Crit[, 25] == "no")), ")", sep ="")), pch = 16, col = c("blue", "red", "orange", "grey"))


# ---> Plot, der die Dichte der Punkteverteilung im Plot durch Farben anzeigt ("rot" = sehr dicht beieinander; "blau" = nicht dicht beieinander)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = densCols(pca$x[, 1], pca$x[, 2], colramp = colorRampPalette(c("blue", "cyan", "green", "yellow", "orange", "red"))), main = "Point Density", xlab = "PC1", ylab = "PC2")
abline(h = 0, lty =3, col = "grey")
abline(v = 0, lty = 3, col = "grey")


# --> Erstellen eines "Biplots" der die ersten zwei PCs mit den loadings der Variablen zeigt
library(ggplot2)
library(factoextra)

fviz_pca_biplot(pca, axes = c(1,2) , label = "var", col.var = "black", repel = T, col.ind = Sel_Crit[,25])

rm(col, pca)
```


##### 4.5 Application of the Selection Criteria

Based on the PCA we can conclude that the selection criteria **delta_Gbl_mu**, **Ctrl_Gbl_prt_prop_%**, **RNase_Gbl_prt_prop_%** and **Gbl_overlap_%** are the most important to separate shifting and non shifting proteins from each other.
Based on observations and experience we set the following thresholds for an RNA-dependent protein (RDP):

  1. Global peak shift of more than **1 fraction**
  2. Protein loss under Ctrl global peak of more than **20 %** after RNase treatment
  3. Protein gain under RNase global peak of more than **20 %** after RNase treatment
  4. Overlap the gaussian curves of less than **75 %**
  
Furthermore, we define a *partially* RNA-dependent proteins as either a protein that satisfies 1. and 4. and 2. or 3. (1. & 4. & (2. | 3.)) or as a protein that satisfies the following criteria:

  1. Fraction shift between global and main local peak positions of more than **1 fraction**
  2. Overlap between the gaussian curves of global and main local peaks of less than **75 %**
  3. Overlap between the gaussian curves of the local peaks of less than **75 %**
  4. Protein gain under main local peak in relation to protein distribution of other sample under the same peak of more than **20 %**
  5. Protein amount at main local peak of more than **8**
  6. Categorization as **"non RDP"**

```{r}
# ---> Neue Spalte, die den RDP-Status ("yes", "no" oder "partial") angibt
Sel_Crit[, 26] = rep(NA, nrow(Sel_Crit))
colnames(Sel_Crit) = c(colnames(Sel_Crit)[-26], "RDP")

# ---> Anwenden der Selection Criteria
Sel_Crit[which(abs(Sel_Crit[, 1]) > 1 & Sel_Crit[, 10] > 0.2 & Sel_Crit[, 12] > 0.2 & Sel_Crit[, 13] < 0.75), 26] = "yes"
Sel_Crit[which(!(abs(Sel_Crit[, 1]) > 1 & (Sel_Crit[, 10] > 0.2 | Sel_Crit[, 12] > 0.2) & Sel_Crit[, 13] < 0.75)), 26] = "no"

Sel_Crit[which(abs(Sel_Crit[, 1]) > 1 & (Sel_Crit[, 10] > 0.2 | Sel_Crit[, 12] > 0.2) & Sel_Crit[, 13] < 0.75 & !(Sel_Crit[, 10] > 0.2 & Sel_Crit[, 12] > 0.2)), 26] = "partial"

Sel_Crit[which(abs(Sel_Crit[, 14]) > 1 & Sel_Crit[, 18] < 0.75 & Sel_Crit[, 20] < 0.75 & Sel_Crit[, 22] > 0.2 & (Summary[, 16]/(sqrt(2*pi) * Summary[, 15])) > 8 & Sel_Crit[, 26] == "no"), 26] = "partial"

Sel_Crit[which(abs(Sel_Crit[, 16]) > 1 & Sel_Crit[, 19] < 0.75 & Sel_Crit[, 20] < 0.75 & Sel_Crit[, 24] > 0.2 & (Summary[, 22]/(sqrt(2*pi) * Summary[, 21])) > 8 & Sel_Crit[, 26] == "no"), 26] = "partial"

# ---> Wie viele Gene werden jeweils zugewiesen?
length(which(Sel_Crit[, 26] == "yes"))
length(which(Sel_Crit[, 26] == "no"))
length(which(Sel_Crit[, 26] == "partial"))
```


##### 4.6 Visualization of RDPs, non RDPs and partial RDPs

Plotting the first 2 PCs from the PCA from before, we can colorize each gene based on whether or not it is an RDP, non RDP or partial RDP based on our analysis:

```{r}
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# ---> Plot, der die Datenpunkte je nach Kategorisierung in "RDP" oder "non RDP" einfärbt 
col = rep(NA, nrow(Sel_Crit))
col[which(Sel_Crit[, 26] == "yes")] = "blue"
col[which(Sel_Crit[, 26] == "partial")] = "orange"
col[which(Sel_Crit[, 26] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("bottomright", legend = c(paste("RDP (", length(which(Sel_Crit[, 26] == "yes")), ")", sep =""), paste("partial RDP (", length(which(Sel_Crit[, 26] == "partial")), ")", sep =""), paste("non RDP (", length(which(Sel_Crit[, 26] == "no")), ")", sep ="")), pch = 16, col = c("blue","orange", "grey"))


pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

# ---> Plot, der die Datenpunkte je nach Kategorisierung in "RDP" oder "non RDP" einfärbt 
col = rep(NA, nrow(Sel_Crit))
col[which(Sel_Crit[, 26] == "yes")] = "blue"
col[which(Sel_Crit[, 26] == "partial")] = "orange"
col[which(Sel_Crit[, 26] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("RDP (", length(which(Sel_Crit[, 26] == "yes")), ")", sep =""), paste("partial RDP (", length(which(Sel_Crit[, 26] == "partial")), ")", sep =""), paste("non RDP (", length(which(Sel_Crit[, 26] == "no")), ")", sep ="")), pch = 16, col = c("blue","orange", "grey"))

rm(pca, col)
```


#### 5. Further Analysis


##### 5.1 k-Means clustering 

We can use *k-Means Clustering* to identify clusters from our PCA analysis and compare these clusters with our identification of RDPs.

**Note**: *The optimal cluster number for the first PCA is 3, even though 2 clusters would make more sense. Hence we will manually combine two clusters to one.*

```{r}
# ---> PCA
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# ---> kmeans-Clustering
kmeans = kmeans(pca$x, 3, iter.max = 10, nstart = 1)

col = rep(NA, nrow(Sel_Crit))
col[which(kmeans$cluster == 1)] = "blue"
col[which(kmeans$cluster == 2)] = "red"
col[which(kmeans$cluster == 3)] = "orange"
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "k-Means Clustering (n = 3)", xlab = "PC1", ylab = "PC2")
legend("bottomright", legend = c(paste("1 (", length(which(kmeans$cluster == 1)), ")", sep =""), paste("2 (", length(which(kmeans$cluster == 2)), ")", sep =""), paste("3 (", length(which(kmeans$cluster == 3)), ")", sep ="")), pch = 16, col = c("blue", "red", "orange"))

# ---> Erstellung eines Elbow-Plots
plot(1:5, c(kmeans(pca$x[,1:2], 1, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 2, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 3, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 4, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 5, iter.max = 10, nstart = 1)$tot.withinss), type = "b", pch = 19, main = "Elbow Method", xlab = "Number of cluster", ylab = "Total within-cluster sum of squares")


# ---> PCA
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

# ---> kmeans-Clustering
kmeans = kmeans(pca$x, 2, iter.max = 10, nstart = 1)

col = rep(NA, nrow(Sel_Crit))
col[which(kmeans$cluster == 1)] = "blue"
col[which(kmeans$cluster == 2)] = "red"
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "k-Means Clustering (n = 2)", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("1 (", length(which(kmeans$cluster == 1)), ")", sep =""), paste("2 (", length(which(kmeans$cluster == 2)), ")", sep ="")), pch = 16, col = c("blue", "red"))

# ---> Erstellung eines Elbow-Plots
plot(1:5, c(kmeans(pca$x[,1:2], 1, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 2, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 3, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 4, iter.max = 10, nstart = 1)$tot.withinss,
            kmeans(pca$x[,1:2], 5, iter.max = 10, nstart = 1)$tot.withinss), type = "b", pch = 19, main = "Elbow Method", xlab = "Number of cluster", ylab = "Total within-cluster sum of squares")

rm(col, pca, kmeans)
```


##### 5.2 Linear Regression

```{r}
col = rep(NA, nrow(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), ]))
col[which(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 26] == "yes")] = "blue"
col[which(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 26] == "partial")] = "orange"
col[which(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 26] == "no")] = "grey"

plot(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 9], Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 11], col = col, pch = 16, xlab = "Ctrl_Gbl_prt_prop", ylab = "RNase_Gbl_prt_prop")

fit <- lm(Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 9] ~ Sel_Crit[which(Sel_Crit$RDP == "no" | Sel_Crit$RDP == "partial"), 11])

curve(fit$coefficients[2]*x + fit$coefficients[1], lwd = 3, col = "blue", add = T)
summary(fit)$r.squared
rm(col, fit)
```


##### 5.3 Comparison with the RBP2GO Database

First, we will load the data from the RBP2GO databank for *homo sapiens*: 

```{r}
Table_HS_RBP = read.csv("https://www.dropbox.com/s/xpjob8g8flxl3ik/Table_HS_RBP.txt?dl=1", sep = "", header = T, row.names = 1)

Table_HS_RBP = Table_HS_RBP[order(row.names(Table_HS_RBP)),]

Table_HS_Non_RBP = read.csv("https://www.dropbox.com/s/cgbrvponhw7arpt/Table_HS_Non_RBP.txt?dl=1", sep = "", header = T, row.names = 1)

Table_HS_Non_RBP = Table_HS_Non_RBP[order(row.names(Table_HS_Non_RBP)),]
```

Next, we expand our dataframe **Sel_Crit** with a twenty-seventh column containing the RBP2GO-Score for each gene: 

```{r}
# ---> Erstellen der 27. Spalte (nur NA)
Sel_Crit[, 27] = rep(NA, nrow(Sel_Crit))
colnames(Sel_Crit) = c(colnames(Sel_Crit)[-27], "RBP2GO_Score")

# ---> Hinzufügen der RBP2GO-Scores aus dem Datensatz für RBPs
Sel_Crit[which(rownames(Sel_Crit) %in% rownames(Table_HS_RBP)), 27] = Table_HS_RBP[which(rownames(Table_HS_RBP) %in% rownames(Sel_Crit)), 3]

# ---> Hinzufügen der RBP2GO-Scores aus dem Datensatz für non RBPs
Sel_Crit[which(rownames(Sel_Crit) %in% rownames(Table_HS_Non_RBP)), 27] = Table_HS_Non_RBP[which(rownames(Table_HS_Non_RBP) %in% rownames(Sel_Crit)), 3]
```


###### 5.3.1 Direct Comparison

Now we can look again at our PCA results and compare our findings with the RBP2GO databank:

```{r}
# ---> PCA
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# ---> Erstellen eines Farbenvektors basierend auf den Kategorien "yes", "partial" und "no" (bezogen auf RDP)
col = rep(NA, nrow(Sel_Crit))
col[which(Sel_Crit[, 26] == "yes")] = "blue"
col[which(Sel_Crit[, 26] == "partial")] = "orange"
col[which(Sel_Crit[, 26] == "no")] = "grey"

# ---> Generieren des PCA biplots mit entsprechender Einfärbung
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Our RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("bottomright", legend = c(paste("RDP (", length(which(Sel_Crit[, 26] == "yes")), ")", sep =""), paste("partial RDP (", length(which(Sel_Crit[, 26] == "partial")), ")", sep =""), paste("non RDP (", length(which(Sel_Crit[, 26] == "no")), ")", sep ="")), pch = 16, col = c("blue","orange", "grey"))

# ---> Vergleich mit RBP2GO Datenbank
col = rep(NA, nrow(Sel_Crit))
col[which(rownames(Sel_Crit) %in% rownames(Table_HS_RBP))] = "blue"
col[which(rownames(Sel_Crit) %in% rownames(Table_HS_Non_RBP))] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RBP2GO RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("bottomright", legend = c(paste("RDP (", length(which(rownames(Sel_Crit) %in% rownames(Table_HS_RBP))), ")", sep =""), paste("non RDP (", length(which(rownames(Sel_Crit) %in% rownames(Table_HS_Non_RBP))), ")", sep ="")), pch = 16, col = c("blue", "grey"))


# ---> Gleiche Berechnungen für die 4 ausgewählten Selektionskriterien
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

col = rep(NA, nrow(Sel_Crit))
col[which(Sel_Crit[, 26] == "yes")] = "blue"
col[which(Sel_Crit[, 26] == "partial")] = "orange"
col[which(Sel_Crit[, 26] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Our RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("RDP (", length(which(Sel_Crit[, 26] == "yes")), ")", sep =""), paste("partial RDP (", length(which(Sel_Crit[, 26] == "partial")), ")", sep =""), paste("non RDP (", length(which(Sel_Crit[, 26] == "no")), ")", sep ="")), pch = 16, col = c("blue","orange", "grey"))

col = rep(NA, nrow(Sel_Crit))
col[which(rownames(Sel_Crit) %in% rownames(Table_HS_RBP))] = "blue"
col[which(rownames(Sel_Crit) %in% rownames(Table_HS_Non_RBP))] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RBP2GO RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c(paste("RDP (", length(which(rownames(Sel_Crit) %in% rownames(Table_HS_RBP))), ")", sep =""), paste("non RDP (", length(which(rownames(Sel_Crit) %in% rownames(Table_HS_Non_RBP))), ")", sep ="")), pch = 16, col = c("blue", "grey"))

rm(pca, col)
```

###### 5.3.2 Comparison with RBP2GO-Score

Mmmmmh ... maybe we get more clear results if we color our points according to their RBP2GO-scores: we have 5970 genes with RBP2GO-scores (20 genes are not included in the RBP2GO databank (= NA)). We want to obtain 6 ruffly equally sized groups (so 995 genes in each): 

  RBP2-Score Range    Number of Genes
  [0, 0.9]            1039
  (0.9, 2.3]          1075
  (2.3, 4]            993
  (4, 6.9]            973
  (6.9, 15.9]         995
  (15.9, 100]         895
  NA                  20

```{r}
# ---> PCA
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# ---> Erstellen eines Farbvektors anhand der RBP2GO-scores
col = rep(NA, nrow(Sel_Crit))
col[which(is.na(Sel_Crit[, 27]))] = "grey" # 20
col[which(Sel_Crit[, 27] <= 0.9)] = "purple" # 1039
col[which(0.9 < Sel_Crit[, 27] & Sel_Crit[, 27] <= 2.3)] = "blue" # 1075
col[which(2.3 < Sel_Crit[, 27] & Sel_Crit[, 27] <= 4)] = "green" # 993
col[which(4 < Sel_Crit[, 27] & Sel_Crit[, 27] <= 6.9)] = "yellow" # 973
col[which(6.9 < Sel_Crit[, 27] & Sel_Crit[, 27] <= 15.9)] = "orange" # 995
col[which(15.9 < Sel_Crit[, 27] & Sel_Crit[, 27] <= 100)] = "red" # 895

# ---> Erstellen des entsprechend eingefärbten Biplots
par(mar=c(5, 4, 4, 7), xpd=F)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RBP2GO_Score", xlab = "PC1", ylab = "PC2")
par(xpd=T)
legend("topright", inset = c(-0.24,0), legend = c("[0, 0.9]", "(0.9, 2.3]", "(2.3, 4]", "(4, 6.9]", "(6.9, 15.9]", "(15.9, 100]", "NA"), pch = 16, col = c("purple", "blue", "green", "yellow", "orange", "red", "grey"))


# ---> Gleiche Berechnungen für die 4 ausgewählten Selektionskriterien
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

col = rep(NA, nrow(Sel_Crit))
col[which(is.na(Sel_Crit[, 27]))] = "grey" # 20
col[which(Sel_Crit[, 27] <= 0.9)] = "purple" # 1039
col[which(0.9 < Sel_Crit[, 27] & Sel_Crit[, 27] <= 2.3)] = "blue" # 1075
col[which(2.3 < Sel_Crit[, 27] & Sel_Crit[, 27] <= 4)] = "green" # 993
col[which(4 < Sel_Crit[, 27] & Sel_Crit[, 27] <= 6.9)] = "yellow" # 973
col[which(6.9 < Sel_Crit[, 27] & Sel_Crit[, 27] <= 15.9)] = "orange" # 995
col[which(15.9 < Sel_Crit[, 27] & Sel_Crit[, 27] <= 100)] = "red" # 895

par(mar=c(5, 4, 4, 7), xpd=F)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RBP2GO_Score", xlab = "PC1", ylab = "PC2")
par(xpd=T)
legend("topright", inset = c(-0.24,0), legend = c("[0, 0.9]", "(0.9, 2.3]", "(2.3, 4]", "(4, 6.9]", "(6.9, 15.9]", "(15.9, 100]", "NA"), pch = 16, col = c("purple", "blue", "green", "yellow", "orange", "red", "grey"))

rm(pca, col)
```

Maybe we have more success if we do not use different colors but give genes with a higher RBP2GO-Score more opacity: 

```{r}
library(scales)
# ---> PCA
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# ---> Erstellen des Biplots mit einer Farbe, aber unterschiedlicher Deckungskraft je nach RBP2GO-Score
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = alpha("blue", Sel_Crit[, 27]/100), main = "RBP2GO_Score", xlab = "PC1", ylab = "PC2")


# ---> Gleiche Berechnungen für die 4 ausgewählten Selektionskriterien
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = alpha("blue", Sel_Crit[, 27]/100), main = "RBP2GO_Score", xlab = "PC1", ylab = "PC2")

rm(pca)
```

###### 5.3.3 Cluster Comparison with t-Test

Maybe we can go back to our k-means clustering. By calculating the **mean RBP2GO-score** for each cluster, we can estimate how RNA-dependent a cluster is. 
Furthermore, we can use a t-Test to calculate how significant the differences between the mean values are (H0: *The mean values are not significantly different from each other*, H1: *The mean values are significantly different from each other* (two-sided t-test)):

```{r}
# ---> PCA
pca = prcomp(Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# ---> k-Means-Clustering für 3 Cluster
kmeans = kmeans(pca$x, 3, iter.max = 10, nstart = 1)

# ---> Erstellen eines Farbenvektors basierend auf den Clustern
col = rep(NA, nrow(Sel_Crit))
col[which(kmeans$cluster == 1)] = "blue"
col[which(kmeans$cluster == 2)] = "red"
col[which(kmeans$cluster == 3)] = "orange"

# ---> Erstellen des Biplots mit entsprechender Einfärbung und t-Test Berechnungen in der Legende
par(mar=c(4, 4, 4, 11), xpd=F)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "k-Means Clustering (n = 3)", xlab = "PC1", ylab = "PC2")
par(xpd=T)
legend("topright", inset = c(-0.49,0), legend = c(paste("Cluster 1 (", length(which(kmeans$cluster == 1)), ")", sep = ""), paste("(mu = ", round(mean(Sel_Crit[which(kmeans$cluster == 1), 27], na.rm = T), 2),",", " sd = ", round(sd(Sel_Crit[which(kmeans$cluster == 1), 27], na.rm = T)/sqrt(length(which(kmeans$cluster == 1))), 2), ")", sep = ""), paste("Cluster 2 (", length(which(kmeans$cluster == 2)), ")", sep = ""), paste("(mu = ", round(mean(Sel_Crit[which(kmeans$cluster == 2), 27], na.rm = T), 2),",", " sd = ", round(sd(Sel_Crit[which(kmeans$cluster == 2), 27], na.rm = T)/sqrt(length(which(kmeans$cluster == 2))), 2), ")", sep = ""), paste("Cluster 3 (", length(which(kmeans$cluster == 3)), ")", sep = ""), paste("(mu = ", round(mean(Sel_Crit[which(kmeans$cluster == 3), 27], na.rm = T), 2),",", " sd = ", round(sd(Sel_Crit[which(kmeans$cluster == 3), 27], na.rm = T)/sqrt(length(which(kmeans$cluster == 3))), 2), ")", sep = ""), "", paste("p(1&2) = ", signif(t.test(Sel_Crit[which(kmeans$cluster == 1), 27], Sel_Crit[which(kmeans$cluster == 2), 27], alternative = "two.sided")$p.value, 3), sep = ""), paste("p(1&3) = ", signif(t.test(Sel_Crit[which(kmeans$cluster == 1), 27], Sel_Crit[which(kmeans$cluster == 3), 27], alternative = "two.sided")$p.value, 3), sep = ""), paste("p(2&3) = ", signif(t.test(Sel_Crit[which(kmeans$cluster == 2), 27], Sel_Crit[which(kmeans$cluster == 3), 27], alternative = "two.sided")$p.value, 3), sep = "")), pch = 16, col = c("blue", NA, "red", NA, "orange", NA, NA, NA, NA, NA))


# ---> Gleiche Berechnungen für die 4 ausgewählten Selektionskriterien
pca = prcomp(Sel_Crit[, c(2, 10, 12, 13)])

kmeans = kmeans(pca$x, 2, iter.max = 10, nstart = 1)

col = rep(NA, nrow(Sel_Crit))
col[which(kmeans$cluster == 1)] = "blue"
col[which(kmeans$cluster == 2)] = "red"

par(mar=c(4, 4, 4, 11), xpd=F)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "k-Means Clustering (n = 2)", xlab = "PC1", ylab = "PC2")
par(xpd=T)
legend("topright", 
       inset = c(-0.49,0), 
       legend = c(paste("Cluster 1 (", length(which(kmeans$cluster == 1)), ")", sep = ""), paste("(mu = ", round(mean(Sel_Crit[which(kmeans$cluster == 1), 27], na.rm = T), 2),",", " sd = ", round(sd(Sel_Crit[which(kmeans$cluster == 1), 27], na.rm = T)/sqrt(length(which(kmeans$cluster == 1))), 2), ")", sep = ""), paste("Cluster 2 (", length(which(kmeans$cluster == 2)), ")", sep = ""), paste("(mu = ", round(mean(Sel_Crit[which(kmeans$cluster == 2), 27], na.rm = T), 2),",", " sd = ", round(sd(Sel_Crit[which(kmeans$cluster == 2), 27], na.rm = T)/sqrt(length(which(kmeans$cluster == 2))), 2), ")", sep = ""), "", paste("p(1&2) = ", signif(t.test(Sel_Crit[which(kmeans$cluster == 1), 27], Sel_Crit[which(kmeans$cluster == 2), 27], alternative = "two.sided")$p.value, 3), sep = "")), 
       pch = 16, 
       col = c("blue", NA, "red", NA, NA, NA))

rm(pca, kmeans, col)
```

###### 5.3.4 Venn-Diagram & Barplot

Maybe this is not the right approach. Let us just compare the number of RDPs and non RDPs between the datasets using venn diagrams:

```{r}
library("VennDiagram")

grid.newpage()

draw.triple.venn(
  area1 = length(which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial")),   # Our identified RDPs
  area2 = nrow(Table_HS_RBP),  # RBPs in RBP2GO-Databank
  area3 = length(which(Table_HS_RBP$R.DeeP_HeLa == "X")),   # RDPs from the R-Deep-Databank
  n12 = length(which(rownames(Table_HS_RBP) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]))), 
  n23 = length(which(Table_HS_RBP$R.DeeP_HeLa == "X")),
  n13 = length(which(rownames(Table_HS_RBP[which(Table_HS_RBP$R.DeeP_HeLa == "X"),]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]))), 
  n123 = length(which(which(rownames(Table_HS_RBP[which(Table_HS_RBP$R.DeeP_HeLa == "X"),]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ])) %in% which(rownames(Table_HS_RBP[which(Table_HS_RBP$R.DeeP_HeLa == "X"),]) %in% rownames(Table_HS_RBP)))),
  fill = c("dodgerblue", "darkorange", "red"),
  lwd = 1,
  category = c(paste("Our RDPs (", length(which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial")), ")", sep = ""), paste("RBP2GO RBPs (", nrow(Table_HS_RBP), ")", sep =""), paste("R-Deep (", length(which(Table_HS_RBP$R.DeeP_HeLa == "X")), ")", sep = "")),
  fontfamily = "plain",
  cat.fontfamily = "plain",
  cat.fontface = "bold",
  cat.dist = c(0.09, 0.085, 0.08),
  cat.pos = c(-25, 24, 150),
  cat.col = c("dodgerblue", "darkorange", "red")
)


grid.newpage()

draw.triple.venn(
  area1 = length(which(Sel_Crit[, 26] == "no")),   # Our identified non RDPs
  area2 = nrow(Table_HS_RBP),  # RBPs in RBP2GO-Databank
  area3 = length(which(Table_HS_RBP$R.DeeP_HeLa == "X")),   # RDPs from the R-Deep-Databank
  n12 = length(which(rownames(Table_HS_RBP) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]))), 
  n23 = length(which(Table_HS_RBP$R.DeeP_HeLa == "X")),
  n13 = length(which(rownames(Table_HS_RBP[which(Table_HS_RBP$R.DeeP_HeLa == "X"),]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]))), 
  n123 = length(which(which(rownames(Table_HS_RBP[which(Table_HS_RBP$R.DeeP_HeLa == "X"),]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ])) %in% which(rownames(Table_HS_RBP[which(Table_HS_RBP$R.DeeP_HeLa == "X"),]) %in% rownames(Table_HS_RBP)))),
  fill = c("dodgerblue", "darkorange", "red"),
  lwd = 1,
  category = c(paste("Our non RDPs (", length(which(Sel_Crit[, 26] == "no")), ")", sep = ""), paste("RBP2GO RBPs (", nrow(Table_HS_RBP), ")", sep =""), paste("R-Deep (", length(which(Table_HS_RBP$R.DeeP_HeLa == "X")), ")", sep = "")),
  fontfamily = "plain",
  cat.fontfamily = "plain",
  cat.fontface = "bold",
  cat.dist = c(0.09, 0.085, 0.08),
  cat.pos = c(-25, 24, 150),
  cat.col = c("dodgerblue", "darkorange", "red")
)


grid.newpage()

draw.triple.venn(
  area1 = nrow(Sel_Crit),   # Our Genes
  area2 = nrow(Table_HS_RBP),  # RBPs in RBP2GO-Databank
  area3 = length(which(Table_HS_RBP$R.DeeP_HeLa == "X")),   # RDPs from the R-Deep-Databank
  n12 = length(which(rownames(Table_HS_RBP) %in% rownames(Sel_Crit))), 
  n23 = length(which(Table_HS_RBP$R.DeeP_HeLa == "X")),
  n13 = length(which(rownames(Table_HS_RBP[which(Table_HS_RBP$R.DeeP_HeLa == "X"),]) %in% rownames(Sel_Crit))), 
  n123 = length(which(which(rownames(Table_HS_RBP[which(Table_HS_RBP$R.DeeP_HeLa == "X"),]) %in% rownames(Sel_Crit)) %in% which(rownames(Table_HS_RBP[which(Table_HS_RBP$R.DeeP_HeLa == "X"),]) %in% rownames(Table_HS_RBP)))),
  fill = c("dodgerblue", "darkorange", "red"),
  lwd = 1,
  category = c(paste("Our Genes (", nrow(Sel_Crit), ")", sep = ""), paste("RBP2GO RBPs (", nrow(Table_HS_RBP), ")", sep =""), paste("R-Deep (", length(which(Table_HS_RBP$R.DeeP_HeLa == "X")), ")", sep = "")),
  fontfamily = "plain",
  cat.fontfamily = "plain",
  cat.fontface = "bold",
  cat.dist = c(0.09, 0.085, 0.08),
  cat.pos = c(-25, 24, 150),
  cat.col = c("dodgerblue", "darkorange", "red")
)

par(mar=c(1, 3, 1, 7.5))
barplot(matrix(c(
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]))),
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_RBP))),
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_RBP))),
  length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]))),
  rep(NA, 4)),
  nrow = 4),
  axes = F,
  col = c("red", "orange", "yellow", "green"), 
  legend.text = c(paste("Non RDPs (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]))), ")", sep = ""), 
                  paste("RDPs (only RBP2GO) (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "no"), ]) %in% rownames(Table_HS_RBP))), ")", sep = ""), 
                  paste("RDPS (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_RBP))), ")", sep = ""), 
                  paste("New RDPs (", length(which(rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]) %in% rownames(Table_HS_Non_RBP))) + length(which(rownames(Ctrl_RDeep[which(!(rownames(Ctrl_RDeep) %in% rownames(Table_HS_RBP)) & !(rownames(Ctrl_RDeep) %in% rownames(Table_HS_Non_RBP))), ]) %in% rownames(Sel_Crit[which(Sel_Crit[, 26] == "yes" | Sel_Crit[, 26] == "partial"), ]))), ")", sep = "")),
  )
```

##### 5.4 PCA with Local Peaks

```{r}
# 15, 17, 22, 24, 18, 19, 20
pca = prcomp(na.omit(Sel_Crit[, c(2, 10, 12, 13, 15, 17, 20)]))

# ---> Plot, der die Datenpunkte je nach Kategorisierung in "left", "right" und "no" shift einfärbt 
col = rep(NA, length(which(!is.na(Sel_Crit[, 14]) & !is.na(Sel_Crit[, 16]))))

col[which(Sel_Crit[which(!is.na(Sel_Crit[, 14]) & !is.na(Sel_Crit[, 16])), 26] == "yes")] = "blue"
col[which(Sel_Crit[which(!is.na(Sel_Crit[, 14]) & !is.na(Sel_Crit[, 16])), 26] == "partial")] = "orange"
col[which(Sel_Crit[which(!is.na(Sel_Crit[, 14]) & !is.na(Sel_Crit[, 16])), 26] == "no")] = "grey"


plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RDPs and non RDPs", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c("RDP", "partial RDP", "non RDP"), pch = 16, col = c("blue", "orange", "grey"))

col = rep(NA, length(which(!is.na(Sel_Crit[, 14]) & !is.na(Sel_Crit[, 16]))))

col[which(Sel_Crit[which(!is.na(Sel_Crit[, 14]) & !is.na(Sel_Crit[, 16])), 25] == "left")] = "blue"
col[which(Sel_Crit[which(!is.na(Sel_Crit[, 14]) & !is.na(Sel_Crit[, 16])), 25] == "right")] = "red"
col[which(Sel_Crit[which(!is.na(Sel_Crit[, 14]) & !is.na(Sel_Crit[, 16])), 25] == "precipitated")] = "orange"
col[which(Sel_Crit[which(!is.na(Sel_Crit[, 14]) & !is.na(Sel_Crit[, 16])), 25] == "no")] = "grey"


plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Shifting Behavior", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c("left", "right", "precipitated", "no"), pch = 16, col = c("blue", "red", "orange", "grey"))

# ---> Plot, der die Dichte der Punkteverteilung im Plot durch Farben anzeigt ("rot" = sehr dicht beieinander; "blau" = nicht dicht beieinander)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = densCols(pca$x[, 1], pca$x[, 2], colramp = colorRampPalette(c("blue", "cyan", "green", "yellow", "orange", "red"))), main = "Point Density", xlab = "PC1", ylab = "PC2")
abline(h = 0, lty =3, col = "grey")
abline(v = 0, lty = 3, col = "grey")


# --> Erstellen eines "Biplots" der die ersten zwei PCs mit den loadings der Variablen zeigt
library(ggplot2)
library(factoextra)

fviz_pca_biplot(pca, axes = c(1,2) , label = "var", col.var = "black", repel = T, col.ind = Sel_Crit[which(!is.na(Sel_Crit[, 14]) & !is.na(Sel_Crit[, 16])),25])

rm(col, pca)
```


#### 6. Weird Analysis


##### 6.1 Analysis and Application of Selection Criteria

Next, we want to do the same analysis for the genes for which all 3 pearson correlations were under 0.95 (in the dataframes "**Weird_Ctrl_RDeep**" and "**Weird_RNase_RDeep**"). This will yield the dataframes "**Weird_Summary**" and "**Weird_Sel_Crit**".

**Note**: The mean is only calculated for the 2 highest correlating replicates for genes were the correlations are all under 0.95.

```{r}
# ---> 1. Pearson Correlation
# ---> 1.1 Aufteilen der Replikate
Rep1_Ctrl = Weird_Ctrl_RDeep[, c(sapply(seq(0,72,3), function(k) {1 + k}))]
Rep2_Ctrl = Weird_Ctrl_RDeep[, c(sapply(seq(0,72,3), function(k) {2 + k}))]
Rep3_Ctrl = Weird_Ctrl_RDeep[, c(sapply(seq(0,72,3), function(k) {3 + k}))]

# ---> 1.2 Berechnung der Pearson Correlation zwischen den Replikaten
Ctrl_Cor_Weird = as.data.frame(cbind(
      sapply(seq(1, nrow(Weird_Ctrl_RDeep), 1), function(k) {cor(unlist(Rep1_Ctrl[k,]), unlist(Rep2_Ctrl[k,]), method = "pearson")}),
      sapply(seq(1, nrow(Weird_Ctrl_RDeep), 1), function(k) {cor(unlist(Rep2_Ctrl[k,]), unlist(Rep3_Ctrl[k,]), method = "pearson")}),
      sapply(seq(1, nrow(Weird_Ctrl_RDeep), 1), function(k) {cor(unlist(Rep1_Ctrl[k,]), unlist(Rep3_Ctrl[k,]), method = "pearson")})
      ))

# ---> 1.3 Erstellen eines Datensatzes zum vergleichen der Correlationen (>= 0.95 = 1; < 0.95 = 0)
Ctrl_Cor_Rep = rep(1, nrow(Ctrl_Cor_Weird)*3)
Ctrl_Cor_Rep[which(Ctrl_Cor_Weird < 0.95)] = 0
Ctrl_Cor_Rep = matrix(Ctrl_Cor_Rep, ncol = 3)

# ---> 1.4 Ersetzen der Replikate mit NA, bei denen 2 Correlationen unter 0.95 liegen
Weird_Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == Ctrl_Cor_Rep[, 3] & rowSums(Ctrl_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Weird_Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == Ctrl_Cor_Rep[, 2] & rowSums(Ctrl_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

Weird_Ctrl_RDeep[which(Ctrl_Cor_Rep[, 2] == Ctrl_Cor_Rep[, 3] & rowSums(Ctrl_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

# ---> 1.5 Ersetzen der Replikate mit NA, bei denen 1 Correlation unter 0.95 liegt
Weird_Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor_Weird[, 2] > Ctrl_Cor_Weird[, 3]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Weird_Ctrl_RDeep[which(Ctrl_Cor_Rep[, 1] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor_Weird[, 2] < Ctrl_Cor_Weird[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


Weird_Ctrl_RDeep[which(Ctrl_Cor_Rep[, 2] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor_Weird[, 1] > Ctrl_Cor_Weird[, 3]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

Weird_Ctrl_RDeep[which(Ctrl_Cor_Rep[, 2] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor_Weird[, 1] < Ctrl_Cor_Weird[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


Weird_Ctrl_RDeep[which(Ctrl_Cor_Rep[, 3] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor_Weird[, 1] > Ctrl_Cor_Weird[, 2]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

Weird_Ctrl_RDeep[which(Ctrl_Cor_Rep[, 3] == 0 & rowSums(Ctrl_Cor_Rep) == 2 & Ctrl_Cor_Weird[, 1] < Ctrl_Cor_Weird[, 2]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

# ---> 1.6 Wenn alle 3 Korrelationen unter 0.95 liegen, wird das Replikat mit der niedrigsten Korrelation ersetzt 
Weird_Ctrl_RDeep[which(Ctrl_Cor_Weird[, 2] == apply(Ctrl_Cor_Weird, 1, function(x) {max(x)})), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Weird_Ctrl_RDeep[which(Ctrl_Cor_Weird[, 3] == apply(Ctrl_Cor_Weird, 1, function(x) {max(x)})), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

Weird_Ctrl_RDeep[which(Ctrl_Cor_Weird[, 1] == apply(Ctrl_Cor_Weird, 1, function(x) {max(x)})), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

# ---> 1.7 Gleiche Berechnungen für RNase
Rep1_RNase = Weird_RNase_RDeep[, c(sapply(seq(0,72,3), function(k) {1 + k}))]
Rep2_RNase = Weird_RNase_RDeep[, c(sapply(seq(0,72,3), function(k) {2 + k}))]
Rep3_RNase = Weird_RNase_RDeep[, c(sapply(seq(0,72,3), function(k) {3 + k}))]

RNase_Cor_Weird = as.data.frame(cbind(
      sapply(seq(1, nrow(Weird_RNase_RDeep), 1), function(k) {cor(unlist(Rep1_RNase[k,]), unlist(Rep2_RNase[k,]), method = "pearson")}),
      sapply(seq(1, nrow(Weird_RNase_RDeep), 1), function(k) {cor(unlist(Rep2_RNase[k,]), unlist(Rep3_RNase[k,]), method = "pearson")}),
      sapply(seq(1, nrow(Weird_RNase_RDeep), 1), function(k) {cor(unlist(Rep1_RNase[k,]), unlist(Rep3_RNase[k,]), method = "pearson")})
      ))


RNase_Cor_Rep = rep(1, nrow(RNase_Cor_Weird)*3)
RNase_Cor_Rep[which(RNase_Cor_Weird < 0.95)] = 0
RNase_Cor_Rep = matrix(RNase_Cor_Rep, ncol = 3)


Weird_RNase_RDeep[which(RNase_Cor_Rep[, 1] == RNase_Cor_Rep[, 3] & rowSums(RNase_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Weird_RNase_RDeep[which(RNase_Cor_Rep[, 1] == RNase_Cor_Rep[, 2] & rowSums(RNase_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

Weird_RNase_RDeep[which(RNase_Cor_Rep[, 2] == RNase_Cor_Rep[, 3] & rowSums(RNase_Cor_Rep) == 1), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA


Weird_RNase_RDeep[which(RNase_Cor_Rep[, 1] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor_Weird[, 2] > RNase_Cor_Weird[, 3]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Weird_RNase_RDeep[which(RNase_Cor_Rep[, 1] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor_Weird[, 2] < RNase_Cor_Weird[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


Weird_RNase_RDeep[which(RNase_Cor_Rep[, 2] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor_Weird[, 1] > RNase_Cor_Weird[, 3]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

Weird_RNase_RDeep[which(RNase_Cor_Rep[, 2] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor_Weird[, 1] < RNase_Cor_Weird[, 3]), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA


Weird_RNase_RDeep[which(RNase_Cor_Rep[, 3] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor_Weird[, 1] > RNase_Cor_Weird[, 2]), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA

Weird_RNase_RDeep[which(RNase_Cor_Rep[, 3] == 0 & rowSums(RNase_Cor_Rep) == 2 & RNase_Cor_Weird[, 1] < RNase_Cor_Weird[, 2]), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA


Weird_RNase_RDeep[which(RNase_Cor_Weird[, 2] == apply(RNase_Cor_Weird, 1, function(x) {max(x)})), c(sapply(seq(0,72,3), function(k) {1 + k}))] = NA

Weird_RNase_RDeep[which(RNase_Cor_Weird[, 3] == apply(RNase_Cor_Weird, 1, function(x) {max(x)})), c(sapply(seq(0,72,3), function(k) {2 + k}))] = NA

Weird_RNase_RDeep[which(RNase_Cor_Weird[, 1] == apply(RNase_Cor_Weird, 1, function(x) {max(x)})), c(sapply(seq(0,72,3), function(k) {3 + k}))] = NA


rm(Rep1_Ctrl, Rep2_Ctrl, Rep3_Ctrl, Ctrl_Cor_Weird, Rep1_RNase, Rep2_RNase, Rep3_RNase, RNase_Cor_Weird, Ctrl_Cor_Rep, RNase_Cor_Rep)


# ---> 2. Mean
Weird_Ctrl_Mean = as.data.frame(
  sapply(seq(0,72,3), function(i) {
    apply(Weird_Ctrl_RDeep[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x, na.rm = T)})
    }))

colnames(Weird_Ctrl_Mean) = colnames(Ctrl_Mean)


Weird_RNase_Mean = as.data.frame(
  sapply(seq(0,72,3), function(i) {
    apply(Weird_RNase_RDeep[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x, na.rm = T)})
    }))

colnames(Weird_RNase_Mean) = colnames(RNase_Mean)


# ---> 3. Smoothing
Weird_Ctrl_Mean = 
  as.data.frame(
cbind((Weird_Ctrl_Mean[,1]+Weird_Ctrl_Mean[,2])/2,
      sapply(seq(0,22,1), function(i) {apply(Weird_Ctrl_Mean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})}), 
      (Weird_Ctrl_Mean[,24]+Weird_Ctrl_Mean[,25])/2)
)


Weird_RNase_Mean = 
  as.data.frame(
cbind((Weird_RNase_Mean[,1]+Weird_RNase_Mean[,2])/2,
      sapply(seq(0,22,1), function(i) {apply(Weird_RNase_Mean[,c(1,2,3)+c(i,i,i)], 1, function(x) {mean(x)})}), 
      (Weird_RNase_Mean[,24]+Weird_RNase_Mean[,25])/2)
)


# ---> 4. Normalization to 100
Weird_Ctrl_Mean = as.data.frame(sapply(Weird_Ctrl_Mean, function(i){(i/apply(Weird_Ctrl_Mean,1,sum))*100}))

Weird_RNase_Mean = as.data.frame(sapply(Weird_RNase_Mean, function(i){(i/apply(Weird_RNase_Mean,1,sum))*100}))


# ---> 5. Global Maxima
# ---> 5.1 Berechnung der globalen Maxima
Gbl1 = as.matrix(sapply(seq(1,nrow(Weird_Ctrl_RDeep),1),function(i) {which(Weird_Ctrl_Mean[i,] == max(Weird_Ctrl_Mean[i,]))}))
rownames(Gbl1) = rownames(Weird_Ctrl_RDeep)

# ---> 5.2 Zusammenfassen der Double Peaks
Gbl1[which(sapply(seq(1,nrow(Weird_Ctrl_RDeep),1),function(i) {length(which(Weird_Ctrl_Mean[i,] == max(Weird_Ctrl_Mean[i,]) ))}) == 2),1] = apply(matrix(unlist(Gbl1[which(sapply(seq(1,nrow(Weird_Ctrl_RDeep),1),function(i) {length(which(Weird_Ctrl_Mean[i,] == max(Weird_Ctrl_Mean[i,]) ))}) == 2),1]), ncol=2, byrow=T), 1, function(x) {mean(x)})

# ---> 5.3 Zusammenfassen der Triple Peaks
Gbl1[which(sapply(seq(1,nrow(Weird_Ctrl_RDeep),1),function(i) {length(which(Weird_Ctrl_Mean[i,] == max(Weird_Ctrl_Mean[i,]) ))}) == 3),1] = apply(matrix(unlist(Gbl1[which(sapply(seq(1,nrow(Weird_Ctrl_RDeep),1),function(i) {length(which(Weird_Ctrl_Mean[i,] == max(Weird_Ctrl_Mean[i,]) ))}) == 3),1]), ncol=3, byrow=T), 1, function(x) {mean(x)})

# ---> 5.4 Abspeichern als Dataframe
Gbl1 = as.data.frame(unlist(Gbl1))

# ---> 5.5 Gleiche Berechnungen für RNase
Gbl2 = as.matrix(sapply(seq(1,nrow(Weird_RNase_RDeep),1),function(i) {which(Weird_RNase_Mean[i,] == max(Weird_RNase_Mean[i,]))}))
rownames(Gbl2) = rownames(Weird_RNase_RDeep)

Gbl2[which(sapply(seq(1,nrow(Weird_RNase_RDeep),1),function(i) {length(which(Weird_RNase_Mean[i,] == max(Weird_RNase_Mean[i,]) ))}) == 2),1] = apply(matrix(unlist(Gbl2[which(sapply(seq(1,nrow(Weird_RNase_RDeep),1),function(i) {length(which(Weird_RNase_Mean[i,] == max(Weird_RNase_Mean[i,]) ))}) == 2),1]), ncol=2, byrow=T), 1, function(x) {mean(x)})

Gbl2[which(sapply(seq(1,nrow(Weird_RNase_RDeep),1),function(i) {length(which(Weird_RNase_Mean[i,] == max(Weird_RNase_Mean[i,]) ))}) == 3),1] = apply(matrix(unlist(Gbl2[which(sapply(seq(1,nrow(Weird_RNase_RDeep),1),function(i) {length(which(Weird_RNase_Mean[i,] == max(Weird_RNase_Mean[i,]) ))}) == 3),1]), ncol=3, byrow=T), 1, function(x) {mean(x)})

Gbl2 = as.data.frame(unlist(Gbl2))


# ---> 6. Local Maxima
# ---> 6.1 Erstellen eines leeren Dataframes
Loc1 = as.data.frame(matrix(NA, nrow = nrow(Weird_Ctrl_RDeep), ncol = 25))

# ---> 6.2 In welchen Fraktionen gibt es lokale Maxima?
Fra.Pos = sapply(seq(0,20,1), function(i) {which(seq(2*nrow(Weird_Ctrl_RDeep)+1,3*nrow(Weird_Ctrl_RDeep),1) %in% which(apply(Weird_Ctrl_Mean[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) == Weird_Ctrl_Mean[,c(1:5)+c(i,i,i,i,i)] & apply(Weird_Ctrl_Mean[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) != 0))})

# ---> 6.3 Einspeichern der lokalen Maxima im leeren Dataframe
Loc1[, 3:23] = sapply(seq(1,21,1), function(n) {
  replace(
        Loc1[, n+2], 
        Fra.Pos[[n]], 
        n+2)})

# ---> 6.4 Gleiche Berechnungen für RNase
Loc2 = as.data.frame(matrix(NA, nrow = nrow(Weird_RNase_RDeep), ncol = 25))

Fra.Pos = sapply(seq(0,20,1), function(i) {which(seq(2*nrow(Weird_RNase_RDeep)+1,3*nrow(Weird_RNase_RDeep),1) %in% which(apply(Weird_RNase_Mean[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) == Weird_RNase_Mean[,c(1:5)+c(i,i,i,i,i)] & apply(Weird_RNase_Mean[,c(1:5)+c(i,i,i,i,i)], 1, function(x) {max(x)}) != 0))})

Loc2[, 3:23] = sapply(seq(1,21,1), function(n) {
  replace(
        Loc2[, n+2], 
        Fra.Pos[[n]], 
        n+2)})

# ---> 6.5 Randbedingungen für lokale Maxima
Loc1[which(Weird_Ctrl_Mean[,1] >= Weird_Ctrl_Mean[,2] & Weird_Ctrl_Mean[,1] >= Weird_Ctrl_Mean[,3] & Weird_Ctrl_Mean[,1] != 0),1] = 1
Loc2[which(Weird_RNase_Mean[,1] >= Weird_RNase_Mean[,2] & Weird_RNase_Mean[,1] >= Weird_RNase_Mean[,3] & Weird_RNase_Mean[,1] != 0),1] = 1

Loc1[which(Weird_Ctrl_Mean[,2] >= Weird_Ctrl_Mean[,3] & Weird_Ctrl_Mean[,2] >= Weird_Ctrl_Mean[,4] & Weird_Ctrl_Mean[,2] >= Weird_Ctrl_Mean[,1] & Weird_Ctrl_Mean[,1] != 0), 2] = 2
Loc2[which(Weird_RNase_Mean[,2] >= Weird_RNase_Mean[,3] & Weird_RNase_Mean[,2] >= Weird_RNase_Mean[,4] & Weird_RNase_Mean[,2] >= Weird_RNase_Mean[,1] & Weird_RNase_Mean[,1] != 0), 2] = 2

Loc1[which(Weird_Ctrl_Mean[,25] >= Weird_Ctrl_Mean[,24] & Weird_Ctrl_Mean[,25] >= Weird_Ctrl_Mean[,23] & Weird_Ctrl_Mean[,25] != 0), 25] = 25
Loc2[which(Weird_RNase_Mean[,25] >= Weird_RNase_Mean[,24] & Weird_RNase_Mean[,25] >= Weird_RNase_Mean[,23] & Weird_RNase_Mean[,25] != 0), 25] = 25

Loc1[which(Weird_Ctrl_Mean[,24] >= Weird_Ctrl_Mean[,23] & Weird_Ctrl_Mean[,24] >= Weird_Ctrl_Mean[,22] & Weird_Ctrl_Mean[,24] >= Weird_Ctrl_Mean[,25] & Weird_Ctrl_Mean[,24] != 0), 24] = 24
Loc2[which(Weird_RNase_Mean[,24] >= Weird_RNase_Mean[,23] & Weird_RNase_Mean[,24] >= Weird_RNase_Mean[,22] & Weird_RNase_Mean[,24] >= Weird_RNase_Mean[,25] & Weird_RNase_Mean[,24] != 0), 24] = 24

# ---> 6.6 Entfernung der globalen Maxima aus den Dataframes
Crtl_Mask = matrix(1, nrow = nrow(Weird_Ctrl_RDeep)*25, ncol = 1)

Crtl_Mask[which(apply(Weird_Ctrl_Mean, 1, function(x) {max(x)}) == Weird_Ctrl_Mean)] = NA

Crtl_Mask = as.data.frame(matrix(unlist(Crtl_Mask), nrow=nrow(Weird_Ctrl_RDeep), ncol=25))

Loc1 = Loc1 * Crtl_Mask

rm(Crtl_Mask)


RNase_Mask = matrix(1, nrow = nrow(Weird_RNase_RDeep)*25, ncol = 1)

RNase_Mask[which(apply(Weird_RNase_Mean, 1, function(x) {max(x)}) == Weird_RNase_Mean)] = NA

RNase_Mask = as.data.frame(matrix(unlist(RNase_Mask), nrow=nrow(Weird_RNase_RDeep), ncol=25))

Loc2 = Loc2 * RNase_Mask

rm(RNase_Mask)

# ---> 6.7 Zusammenfassen der Double Peaks
Fra.Pos = sapply(seq(0,21,1), function(i) {which(!(is.na(Loc1[,c(2)+c(i)])) & !(is.na(Loc1[,c(3)+c(i)])) & is.na(Loc1[,c(1)+c(i)]) & is.na(Loc1[,c(4)+c(i)]))})

Loc1[, 2:23] = sapply(seq(1,22,1), function(n) {
  replace(
        Loc1[, n+1], 
        Fra.Pos[[n]], 
        n+1.5)})

Loc1[, 3:24] = sapply(seq(1,22,1), function(n) {
  replace(
        Loc1[, n+2], 
        Fra.Pos[[n]], 
        NA)})


Fra.Pos = sapply(seq(0,21,1), function(i) {which(!(is.na(Loc2[,c(2)+c(i)])) & !(is.na(Loc2[,c(3)+c(i)])) & is.na(Loc2[,c(1)+c(i)]) & is.na(Loc2[,c(4)+c(i)]))})

Loc2[, 2:23] = sapply(seq(1,22,1), function(n) {
  replace(
        Loc2[, n+1], 
        Fra.Pos[[n]], 
        n+1.5)})

Loc2[, 3:24] = sapply(seq(1,22,1), function(n) {
  replace(
        Loc2[, n+2], 
        Fra.Pos[[n]], 
        NA)})

# ---> 6.8 Zusammenfassen der Triple Peaks
Fra.Pos = sapply(seq(0,22,1), function(i) {which(!(is.na(Loc1[,c(1)+c(i)])) & !(is.na(Loc1[,c(2)+c(i)])) & !(is.na(Loc1[,c(3)+c(i)])))})

Loc1[, 1:23] = sapply(seq(1,23,1), function(n) {
  replace(
        Loc1[, n], 
        Fra.Pos[[n]], 
        NA)})

Loc1[, 3:25] = sapply(seq(1,23,1), function(n) {
  replace(
        Loc1[, n+2], 
        Fra.Pos[[n]], 
        NA)})


Fra.Pos = sapply(seq(0,22,1), function(i) {which(!(is.na(Loc2[,c(1)+c(i)])) & !(is.na(Loc2[,c(2)+c(i)])) & !(is.na(Loc2[,c(3)+c(i)])))})

Loc2[, 1:23] = sapply(seq(1,23,1), function(n) {
  replace(
        Loc2[, n], 
        Fra.Pos[[n]], 
        NA)})

Loc2[, 3:25] = sapply(seq(1,23,1), function(n) {
  replace(
        Loc2[, n+2], 
        Fra.Pos[[n]], 
        NA)})

# ---> 6.9 Erstellen des "Weird_Summary" Dataframes aus den bisher gesammelten Daten
Weird_Summary = as.data.frame(cbind(Gbl1,
                      Gbl2,
                      as.matrix(sapply(seq(1, nrow(Loc1), 1), function(k) {unlist(Loc1[k, which(!is.na(Loc1[k,]))], use.names = F)})),
                      as.matrix(sapply(seq(1, nrow(Loc2), 1), function(k) {unlist(Loc2[k, which(!is.na(Loc2[k,]))], use.names = F)}))))
rownames(Weird_Summary) = rownames(Weird_Ctrl_RDeep)
colnames(Weird_Summary) = c("Ctrl_Gbl_Max", "RNase_Gbl_Max", "Ctrl_Loc_Max", "RNase_Loc_Max")

rm(Gbl1, Gbl2, Loc1, Loc2, Fra.Pos)


# ---> 7. Gaussian Fitting 
# ---> 7.1 Erstellen des Dataframes
Gauss1 = as.data.frame(matrix(rep(NA, nrow(Weird_Ctrl_RDeep)*5), ncol = 5))
colnames(Gauss1) = c("mu", "sd", "h", "prt_amount", "overlap")
rownames(Gauss1) = rownames(Weird_Ctrl_RDeep)

# ---> 7.2 Schätzung der Werte für das Gaussian Fitting
Gauss1[,1] <- unlist(Weird_Summary[, 1])
Gauss1[,2] <- sapply(seq(1, nrow(Weird_Ctrl_RDeep),1), function(k) {min(abs(unlist(Weird_Summary[k, 1]) - which(Weird_Ctrl_Mean[k,] <= max(Weird_Ctrl_Mean[k,])/2)))/sqrt(2*log(2))})
Gauss1[,3] <- apply(Weird_Ctrl_Mean, 1, function(x) {max(x)})*sqrt(2*pi)*Gauss1[,2]

# ---> 7.3 Optimieren der Werte für das Gaussian Fitting
Gauss1[,1] <- sapply(seq(1, nrow(Weird_Ctrl_RDeep), 1), function(k) {
  
mu_finder <- function(mu = Gauss1[k,1]) {sum((sapply(seq(1,25,1), function(n) {Gauss1[k,3]*(1/(Gauss1[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu)/Gauss1[k,2])^2)}) - unlist(Weird_Ctrl_Mean[k,]))^2)}

optimise(mu_finder, interval = c(Gauss1[k,1]-0.5, Gauss1[k,1]+0.5))$minimum})


Gauss1[,2] <- sapply(seq(1, nrow(Weird_Ctrl_RDeep), 1), function(k) {

sd_finder <- function(sd = Gauss1[k,2]) {sum((sapply(seq(1,25,1), function(n) {Gauss1[k,3]*(1/(sd*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Gauss1[k,1])/sd)^2)}) - unlist(Weird_Ctrl_Mean[k,]))^2)}

optimise(sd_finder, interval = c(0.8*Gauss1[k,2], 1.2*Gauss1[k,2]))$minimum})


Gauss1[,3] <- sapply(seq(1, nrow(Weird_Ctrl_RDeep), 1), function(k) {

h_finder <- function(h = Gauss1[k,3]) {sum((sapply(seq(1,25,1), function(n) {h*(1/(Gauss1[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Gauss1[k,1])/Gauss1[k,2])^2)}) - unlist(Weird_Ctrl_Mean[k,]))^2)}

optimise(h_finder, interval = c(Gauss1[k,3]-5, Gauss1[k,3]+5))$minimum})

# ---> 7.4 Berechnung des Protein-Anteils unter den Gaußkurven
Gauss1[,4] <- sapply(seq(1, nrow(Weird_Ctrl_RDeep),1), function(k) {Gauss1[k,3] * (pnorm(25, mean = Gauss1[k,1], sd = Gauss1[k,2]) - pnorm(0, mean = Gauss1[k,1], sd = Gauss1[k,2]))})

# ---> 7.5 Gleiche Berechnungen für die RNase
Gauss2 = as.data.frame(matrix(rep(NA, nrow(Weird_RNase_RDeep)*5), ncol = 5))
colnames(Gauss2) = c("mu", "sd", "h", "prt_amount", "overlap")
rownames(Gauss2) = rownames(Weird_RNase_RDeep)

Gauss2[,1] <- unlist(Weird_Summary[, 2])
Gauss2[,2] <- sapply(seq(1, nrow(Weird_RNase_RDeep),1), function(k) {min(abs(unlist(Weird_Summary[k, 2]) - which(Weird_RNase_Mean[k,] <= max(Weird_RNase_Mean[k,])/2)))/sqrt(2*log(2))})
Gauss2[,3] <- apply(Weird_RNase_Mean, 1, function(x) {max(x)})*sqrt(2*pi)*Gauss2[,2]


Gauss2[,1] <- sapply(seq(1, nrow(Weird_RNase_RDeep), 1), function(k) {
  
mu_finder <- function(mu = Gauss2[k,1]) {sum((sapply(seq(1,25,1), function(n) {Gauss2[k,3]*(1/(Gauss2[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-mu)/Gauss2[k,2])^2)}) - unlist(Weird_RNase_Mean[k,]))^2)}

optimise(mu_finder, interval = c(Gauss2[k,1]-0.5, Gauss2[k,1]+0.5))$minimum})


Gauss2[,2] <- sapply(seq(1, nrow(Weird_RNase_RDeep), 1), function(k) {

sd_finder <- function(sd = Gauss2[k,2]) {sum((sapply(seq(1,25,1), function(n) {Gauss2[k,3]*(1/(sd*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Gauss2[k,1])/sd)^2)}) - unlist(Weird_RNase_Mean[k,]))^2)}

optimise(sd_finder, interval = c(0.8*Gauss2[k,2], 1.2*Gauss2[k,2]))$minimum})


Gauss2[,3] <- sapply(seq(1, nrow(Weird_RNase_RDeep), 1), function(k) {

h_finder <- function(h = Gauss2[k,3]) {sum((sapply(seq(1,25,1), function(n) {h*(1/(Gauss2[k,2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((n-Gauss2[k,1])/Gauss2[k,2])^2)}) - unlist(Weird_RNase_Mean[k,]))^2)}

optimise(h_finder, interval = c(Gauss2[k,3]-5, Gauss2[k,3]+5))$minimum})


Gauss2[,4] <- sapply(seq(1, nrow(Weird_RNase_RDeep),1), function(k) {Gauss2[k,3] * (pnorm(25, mean = Gauss2[k,1], sd = Gauss2[k,2]) - pnorm(0, mean = Gauss2[k,1], sd = Gauss2[k,2]))})

# ---> 7.6 Berechnung des prozentualen Überlaps zwischen den Gaußkurven
overlap = rep(NA, nrow(Weird_Ctrl_RDeep))

g1 = which(Gauss1[, 2] == Gauss2[, 2] & Gauss1[, 1] == Gauss2[, 1] & Gauss1[, 3] == Gauss2[, 3])

overlap[g1] = 1

g2 = which(Gauss1[, 2] == Gauss2[, 2] & Gauss1[, 1] > Gauss2[, 1])

x = ((Gauss1[g2, 2])^(2) * log(Gauss1[g2, 3]/Gauss2[g2, 3]))/(Gauss2[g2, 1] -  Gauss1[g2, 1]) + (Gauss2[g2, 1] + Gauss1[g2, 1])/2

overlap[g2] = sapply(seq(1,length(g2),1), function(k) {
  (Gauss1[g2[k], 3] * (pnorm(x[k], mean = Gauss1[g2[k], 1], sd = Gauss1[g2[k], 2]) - pnorm(0, mean = Gauss1[g2[k], 1], sd = Gauss1[g2[k], 2])) + Gauss2[g2[k], 3] * (pnorm(25, mean = Gauss2[g2[k], 1], sd = Gauss2[g2[k], 2]) - pnorm(x[k], mean = Gauss2[g2[k], 1], sd = Gauss2[g2[k], 2])))/((Gauss1[g2[k], 4] + Gauss2[g2[k], 4])/2)
})

g3 = which(Gauss1[, 2] == Gauss2[, 2] & Gauss1[, 1] < Gauss2[, 1])

x = ((Gauss1[g3, 2])^(2) * log(Gauss1[g3, 3]/Gauss2[g3, 3]))/(Gauss2[g3, 1] -  Gauss1[g3, 1]) + (Gauss2[g3, 1] + Gauss1[g3, 1])/2

overlap[g3] = sapply(seq(1,length(g3),1), function(k) {
  (Gauss2[g3[k], 3] * (pnorm(x[k], mean = Gauss2[g3[k], 1], sd = Gauss2[g3[k], 2]) - pnorm(0, mean = Gauss2[g3[k], 1], sd = Gauss2[g3[k], 2])) + Gauss1[g3[k], 3] * (pnorm(25, mean = Gauss1[g3[k], 1], sd = Gauss1[g3[k], 2]) - pnorm(x[k], mean = Gauss1[g3[k], 1], sd = Gauss1[g3[k], 2])))/((Gauss1[g3[k], 4] + Gauss2[g3[k], 4])/2)
})

g4 = which(Gauss1[, 2] == Gauss2[, 2] & Gauss1[, 1] == Gauss2[, 1] & Gauss1[, 3] > Gauss2[, 3])

overlap[g4] = sapply(seq(1, length(g4), 1), function(k) {
  (Gauss2[g4[k], 4])/((Gauss1[g4[k], 4] + Gauss2[g4[k], 4])/2)
})

g5 = which(Gauss1[, 2] == Gauss2[, 2] & Gauss1[, 1] == Gauss2[, 1] & Gauss1[, 3] < Gauss2[, 3])

overlap[g5] = sapply(seq(1, length(g5), 1), function(k) {
  (Gauss1[g5[k], 4])/((Gauss1[g5[k], 4] + Gauss2[g5[k], 4])/2)
})

g6 = which(Gauss1[, 2] > Gauss2[, 2] & Gauss1[, 3] <= Gauss2[, 3])

a = (1/(Gauss1[g6,2])^2 - 1/(Gauss2[g6,2])^2)
b = 2 * ((Gauss2[g6,1])/(Gauss2[g6,2])^2 - (Gauss1[g6,1])/(Gauss1[g6,2])^2)
c = (Gauss1[g6,1]/Gauss1[g6,2])^2 - (Gauss2[g6,1]/Gauss2[g6,2])^2 - 2 * log((Gauss1[g6,3] * Gauss2[g6,2])/(Gauss2[g6,3] * Gauss1[g6,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g6[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss2[u1[k], 3] * (pnorm(x2[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(0, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) + pnorm(25, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(x1[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])) + Gauss1[u1[k], 3] * (pnorm(x1[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(x2[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])))/((Gauss1[u1[k], 4] + Gauss2[u1[k], 4])/2)
})

u1 = g6[which(x1 > 25)]
u2 = which(x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss2[u1[k], 3] * (pnorm(x2[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(0, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])) + Gauss1[u1[k], 3] * (pnorm(25, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(x2[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])))/((Gauss1[u1[k], 4] + Gauss2[u1[k], 4])/2)
})

u1 = g6[which(x2 < 0)]
u2 = which(x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss2[u1[k], 3] * (pnorm(25, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(x1[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])) + Gauss1[u1[k], 3] * (pnorm(x1[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(0, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])))/((Gauss1[u1[k], 4] + Gauss2[u1[k], 4])/2)
})

g7 = which(Gauss1[, 2] > Gauss2[, 2] & Gauss1[, 3] > Gauss2[, 3])

a = (1/(Gauss1[g7,2])^2 - 1/(Gauss2[g7,2])^2)
b = 2 * ((Gauss2[g7,1])/(Gauss2[g7,2])^2 - (Gauss1[g7,1])/(Gauss1[g7,2])^2)
c = (Gauss1[g7,1]/Gauss1[g7,2])^2 - (Gauss2[g7,1]/Gauss2[g7,2])^2 - 2 * log((Gauss1[g7,3] * Gauss2[g7,2])/(Gauss2[g7,3] * Gauss1[g7,2]))

x1 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x2 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g7[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss2[u1[k], 3] * (pnorm(x2[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(0, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) + pnorm(25, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(x1[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])) + Gauss1[u1[k], 3] * (pnorm(x1[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(x2[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])))/((Gauss1[u1[k], 4] + Gauss2[u1[k], 4])/2)
})

u1 = g7[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss2[u1[k], 3] * (pnorm(x2[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(0, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])) + Gauss1[u1[k], 3] * (pnorm(25, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(x2[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])))/((Gauss1[u1[k], 4] + Gauss2[u1[k], 4])/2)
})

u1 = g7[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss2[u1[k], 3] * (pnorm(25, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(x1[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])) + Gauss1[u1[k], 3] * (pnorm(x1[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(0, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])))/((Gauss1[u1[k], 4] + Gauss2[u1[k], 4])/2)
})

u1 = g7[which(is.nan(x1))]
u2 = which(is.nan(x1))
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss2[u1[k], 4])/((Gauss1[u1[k], 4] + Gauss2[u1[k], 4])/2)
})

g8 = which(Gauss1[, 2] < Gauss2[, 2] & Gauss1[, 3] >= Gauss2[, 3])

a = (1/(Gauss1[g8,2])^2 - 1/(Gauss2[g8,2])^2)
b = 2 * ((Gauss2[g8,1])/(Gauss2[g8,2])^2 - (Gauss1[g8,1])/(Gauss1[g8,2])^2)
c = (Gauss1[g8,1]/Gauss1[g8,2])^2 - (Gauss2[g8,1]/Gauss2[g8,2])^2 - 2 * log((Gauss1[g8,3] * Gauss2[g8,2])/(Gauss2[g8,3] * Gauss1[g8,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g8[which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss1[u1[k], 3] * (pnorm(x2[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(0, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) + pnorm(25, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(x1[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])) + Gauss2[u1[k], 3] * (pnorm(x1[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(x2[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])))/((Gauss1[u1[k], 4] + Gauss2[u1[k], 4])/2)
})

u1 = g8[which(x1 > 25)]
u2 = which(x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss1[u1[k], 3] * (pnorm(x2[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(0, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])) + Gauss2[u1[k], 3] * (pnorm(25, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(x2[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])))/((Gauss1[u1[k], 4] + Gauss2[u1[k], 4])/2)
})

u1 = g8[which(x2 < 0)]
u2 = which(x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss1[u1[k], 3] * (pnorm(25, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(x1[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])) + Gauss2[u1[k], 3] * (pnorm(x1[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(0, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])))/((Gauss1[u1[k], 4] + Gauss2[u1[k], 4])/2)
})

g9 = which(Gauss1[, 2] < Gauss2[, 2] & Gauss1[, 3] < Gauss2[, 3])

a = (1/(Gauss1[g9,2])^2 - 1/(Gauss2[g9,2])^2)
b = 2 * ((Gauss2[g9,1])/(Gauss2[g9,2])^2 - (Gauss1[g9,1])/(Gauss1[g9,2])^2)
c = (Gauss1[g9,1]/Gauss1[g9,2])^2 - (Gauss2[g9,1]/Gauss2[g9,2])^2 - 2 * log((Gauss1[g9,3] * Gauss2[g9,2])/(Gauss2[g9,3] * Gauss1[g9,2]))

x2 = (- b - sqrt(b^(2) - 4 * a * c))/(2 * a)
x1 = (- b + sqrt(b^(2) - 4 * a * c))/(2 * a)

u1 = g9[which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)]
u2 = which(!is.nan(x1) & x1 <= 25 & x1 >= 0 & x2 <= 25 & x2 >= 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss1[u1[k], 3] * (pnorm(x2[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(0, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) + pnorm(25, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(x1[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])) + Gauss2[u1[k], 3] * (pnorm(x1[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(x2[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])))/((Gauss2[u1[k], 4] + Gauss1[u1[k], 4])/2)
})

u1 = g9[which(!is.nan(x1) & x1 > 25)]
u2 = which(!is.nan(x1) & x1 > 25)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss1[u1[k], 3] * (pnorm(x2[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(0, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])) + Gauss2[u1[k], 3] * (pnorm(25, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(x2[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])))/((Gauss2[u1[k], 4] + Gauss1[u1[k], 4])/2)
})

u1 = g9[which(!is.nan(x1) & x2 < 0)]
u2 = which(!is.nan(x1) & x2 < 0)
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss1[u1[k], 3] * (pnorm(25, mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2]) - pnorm(x1[u2[k]], mean = Gauss1[u1[k], 1], sd = Gauss1[u1[k], 2])) + Gauss2[u1[k], 3] * (pnorm(x1[u2[k]], mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2]) - pnorm(0, mean = Gauss2[u1[k], 1], sd = Gauss2[u1[k], 2])))/((Gauss2[u1[k], 4] + Gauss1[u1[k], 4])/2)
})

u1 = g9[which(is.nan(x1))]
u2 = which(is.nan(x1))
overlap[u1] = sapply(seq(1, length(u1), 1), function(k) {
  (Gauss1[u1[k], 4])/((Gauss1[u1[k], 4] + Gauss2[u1[k], 4])/2)
})

Gauss1[, 5] = overlap 
Gauss2[, 5] = overlap

# ---> 7.7 Abspeichern der Daten aus dem Gaussian Fitting in "Weird_Summary"
Weird_Summary[, 5] = Gauss1[, 1]
Weird_Summary[, 6] = Gauss2[, 1]
Weird_Summary[, 7] = Gauss1[, 2]
Weird_Summary[, 8] = Gauss2[, 2]
Weird_Summary[, 9] = Gauss1[, 3]
Weird_Summary[, 10] = Gauss2[, 3]
Weird_Summary[, 11] = Gauss1[, 4]
Weird_Summary[, 12] = Gauss2[, 4]
Weird_Summary[, 13] = Gauss1[, 5]

colnames(Weird_Summary) = c(colnames(Weird_Summary)[-(5:13)], "Ctrl_mu", "RNase_mu", "Ctrl_sd", "RNase_sd", "Ctrl_h", "RNase_h", "Ctrl_prt_amount", "RNase_prt_amount", "overlap")

rm(g1, g2, g3, g4, g5, g6, g7, g8, g9, u1, u2, a, b, c, x, x1, x2, overlap)


# ---> 8. Vergleich der Variablen in "Weird_Summary"
# ---> 8.1 Erstellen des Dataframes "Weird_Sel_Crit"
Weird_Sel_Crit = as.data.frame(rep(NA, nrow(Weird_Summary)))

Weird_Sel_Crit[, 1] = Weird_Summary[, 5] - Weird_Summary[, 6]

Weird_Sel_Crit[, 2] = (Weird_Summary[, 5] - Weird_Summary[, 6])/25

Weird_Sel_Crit[, 3] = Weird_Summary[, 8] - Weird_Summary[, 7]

Weird_Sel_Crit[, 4] = Weird_Summary[, 8]/Weird_Summary[, 7] - 1

Weird_Sel_Crit[, 5] = Weird_Summary[, 10] - Weird_Summary[, 9] 

Weird_Sel_Crit[, 6] = Weird_Summary[, 10]/Weird_Summary[, 9] - 1

Weird_Sel_Crit[, 7] = Weird_Summary[, 12] - Weird_Summary[, 11]

Weird_Sel_Crit[, 8] = Weird_Summary[, 12]/Weird_Summary[, 11] - 1

x1 = sqrt(- Gauss1[, 2] * log(0.5)) + Gauss1[, 1]
x2 = - sqrt(- Gauss1[, 2] * log(0.5)) + Gauss1[, 1]

x1[which(x1 > 25)] = 25
x2[which(x2 < 1)] = 1 

x1 = ceiling(x1)
x2 = floor(x2)

Fra.Pos = sapply(seq(1, nrow(Weird_Sel_Crit), 1), function(n) {seq(x2[n], x1[n] - 1, 1)})

Ctrl_prt_amount = sapply(seq(1, nrow(Weird_Sel_Crit), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (Weird_Ctrl_Mean[n, Fra.Pos[[n]][i]] + Weird_Ctrl_Mean[n, Fra.Pos[[n]][i] + 1])})))})

RNase_prt_amount = sapply(seq(1, nrow(Weird_Sel_Crit), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (Weird_RNase_Mean[n, Fra.Pos[[n]][i]] + Weird_RNase_Mean[n, Fra.Pos[[n]][i] + 1])})))})

Weird_Sel_Crit[, 9] = Ctrl_prt_amount - RNase_prt_amount

Weird_Sel_Crit[, 10] = 1 - RNase_prt_amount/Ctrl_prt_amount

x1 = sqrt(- Gauss2[, 2] * log(0.5)) + Gauss2[, 1]
x2 = - sqrt(- Gauss2[, 2] * log(0.5)) + Gauss2[, 1]

x1[which(x1 > 25)] = 25
x2[which(x2 < 1)] = 1 

x1 = ceiling(x1)
x2 = floor(x2)

Fra.Pos = sapply(seq(1, nrow(Weird_Sel_Crit), 1), function(n) {seq(x2[n], x1[n] - 1, 1)})

Ctrl_prt_amount = sapply(seq(1, nrow(Weird_Sel_Crit), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (Weird_Ctrl_Mean[n, Fra.Pos[[n]][i]] + Weird_Ctrl_Mean[n, Fra.Pos[[n]][i] + 1])})))})

RNase_prt_amount = sapply(seq(1, nrow(Weird_Sel_Crit), 1), function(n) {sum(unlist(sapply(seq(1, length(Fra.Pos[[n]]), 1), function(i) {0.5 * (Weird_RNase_Mean[n, Fra.Pos[[n]][i]] + Weird_RNase_Mean[n, Fra.Pos[[n]][i] + 1])})))})

Weird_Sel_Crit[, 11] = RNase_prt_amount - Ctrl_prt_amount

Weird_Sel_Crit[, 12] = 1 - Ctrl_prt_amount/RNase_prt_amount

Weird_Sel_Crit[, 13] = Weird_Summary[, 13]

Weird_Sel_Crit[, 14] = rep(NA, nrow(Weird_Sel_Crit))
Weird_Sel_Crit[which((Gauss1[, 1] - Gauss2[, 1]) > 1 & !(Gauss1[, 1] > 24 | Gauss2[, 1] > 24)), 14] = "left"
Weird_Sel_Crit[which((Gauss1[, 1] - Gauss2[, 1]) < -1 & !(Gauss1[, 1] > 24 | Gauss2[, 1] > 24)), 14] = "right"
Weird_Sel_Crit[which(Gauss1[, 1] > 24 | Gauss2[, 1] > 24), 14] = "precipitated"
Weird_Sel_Crit[which((Gauss1[, 1] - Gauss2[, 1]) <= 1 & (Gauss1[, 1] - Gauss2[, 1]) >= -1 & !(Gauss1[, 1] > 24 | Gauss2[, 1] > 24)), 14] = "no"

rownames(Weird_Sel_Crit) = rownames(Weird_Summary)
colnames(Weird_Sel_Crit) = c("delta_mu", "delta_mu_%", "delta_sd", "delta_sd_%", "delta_h", "delta_h_%", "delta_prt_amount", "delta_prt_amount_%", "Ctrl_prt_prop", "Ctrl_prt_prop_%", "RNase_prt_prop", "RNase_prt_prop_%", "overlap_%", "shift")

rm(Fra.Pos, x1, x2, Ctrl_prt_amount, RNase_prt_amount, Gauss1, Gauss2)

# ---> 8.2 Anwenden der Selection Criteria
Weird_Sel_Crit[, 15] = rep(NA, nrow(Weird_Sel_Crit))
colnames(Weird_Sel_Crit) = c(colnames(Weird_Sel_Crit)[-15], "RDP")

Weird_Sel_Crit[which(abs(Weird_Sel_Crit[, 1]) > 1 & Weird_Sel_Crit[, 10] > 0.2 & Weird_Sel_Crit[, 12] > 0.2 & Weird_Sel_Crit[, 13] < 0.75), 15] = "yes"
Weird_Sel_Crit[which(!(abs(Weird_Sel_Crit[, 1]) > 1 & (Weird_Sel_Crit[, 10] > 0.2 | Weird_Sel_Crit[, 12] > 0.2) & Weird_Sel_Crit[, 13] < 0.75)), 15] = "no"
Weird_Sel_Crit[which(abs(Weird_Sel_Crit[, 1]) > 1 & (Weird_Sel_Crit[, 10] > 0.2 | Weird_Sel_Crit[, 12] > 0.2) & Weird_Sel_Crit[, 13] < 0.75 & !(Weird_Sel_Crit[, 10] > 0.2 & Weird_Sel_Crit[, 12] > 0.2)), 15] = "partial"

# ---> 8.3 Hinzufügen des RBP2GO-Scores
Weird_Sel_Crit[, 16] = rep(NA, nrow(Weird_Sel_Crit))
colnames(Weird_Sel_Crit) = c(colnames(Weird_Sel_Crit)[-16], "RBP2GO_Score")

Weird_Sel_Crit[which(rownames(Weird_Sel_Crit) %in% rownames(Table_HS_RBP)), 16] = Table_HS_RBP[which(rownames(Table_HS_RBP) %in% rownames(Weird_Sel_Crit)), 3]

Weird_Sel_Crit[which(rownames(Weird_Sel_Crit) %in% rownames(Table_HS_Non_RBP)), 16] = Table_HS_Non_RBP[which(rownames(Table_HS_Non_RBP) %in% rownames(Weird_Sel_Crit)), 3]
```


##### 6.2 Shifting Behavior

```{r}
# ---> Plotten der peak positions und Einfärben nach "left", "right", "precipitated" und "no" shifting
col = rep(NA, nrow(Ctrl_RDeep))
col[which(Weird_Sel_Crit[, 14] == "left")] = "blue"
col[which(Weird_Sel_Crit[, 14] == "right")] = "red"
col[which(Weird_Sel_Crit[, 14] == "precipitated")] = "orange"
col[which(Weird_Sel_Crit[, 14] == "no")] = "grey"

plot(Weird_Summary[, 5], Weird_Summary[, 6], pch = 16, col = col, main = "Shifting Behavior (Weird)", xlab = "Ctrl Gbl Peak Position", ylab = "RNase Gbl Peak Position")
legend("topleft", legend = c("left", "right", "precipitated", "no"), pch = 16, col = c("blue", "red", "orange", "grey"))

rm(col)
```


##### 6.3 PCA

```{r}
pca = prcomp(Weird_Sel_Crit[, c(2, 4, 6, 8, 10, 12, 13)])

# ---> Plot, der die Datenpunkte je nach Kategorisierung in "left", "right" und "no" shift einfärbt 
col = rep(NA, nrow(Weird_Sel_Crit))
col[which(Weird_Sel_Crit[, 14] == "left")] = "blue"
col[which(Weird_Sel_Crit[, 14] == "right")] = "red"
col[which(Weird_Sel_Crit[, 14] == "precipitated")] = "orange"
col[which(Weird_Sel_Crit[, 14] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Shifting Behavior (Weird)", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c("left", "right", "precipitated", "no"), pch = 16, col = c("blue", "red", "orange", "grey"))


# ---> Plot, der die Dichte der Punkteverteilung im Plot durch Farben anzeigt ("rot" = sehr dicht beieinander; "blau" = nicht dicht beieinander)
plot(pca$x[, 1], pca$x[, 2], pch = 16, col = densCols(pca$x[, 1], pca$x[, 2], colramp = colorRampPalette(c("blue", "cyan", "green", "yellow", "orange", "red"))), main = "Point Density (Weird)", xlab = "PC1", ylab = "PC2")
abline(h = 0, lty =3, col = "grey")
abline(v = 0, lty = 3, col = "grey")


# --> Erstellen eines "Biplots" der die ersten zwei PCs mit den loadings der Variablen zeigt
library(ggplot2)
library(factoextra)

fviz_pca_biplot(pca, axes = c(1,2) , label = "var", col.var = "black", repel = T, col.ind = Weird_Sel_Crit[,14])

# ---> RDPs and non RDPs
col = rep(NA, nrow(Weird_Sel_Crit))
col[which(Weird_Sel_Crit[, 15] == "yes")] = "blue"
col[which(Weird_Sel_Crit[, 15] == "partial")] = "orange"
col[which(Weird_Sel_Crit[, 15] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RDPs and non RDPs (Weird)", xlab = "PC1", ylab = "PC2")
legend("topright", legend = c("RDP", "partial RDP", "non RDP"), pch = 16, col = c("blue","orange", "grey"))


# ---> Gleiche Berechnungen für Selektionskriterien
pca = prcomp(Weird_Sel_Crit[, c(2, 10, 12, 13)])


col = rep(NA, nrow(Weird_Sel_Crit))
col[which(Weird_Sel_Crit[, 14] == "left")] = "blue"
col[which(Weird_Sel_Crit[, 14] == "right")] = "red"
col[which(Weird_Sel_Crit[, 14] == "precipitated")] = "orange"
col[which(Weird_Sel_Crit[, 14] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "Shifting Behavior (Weird)", xlab = "PC1", ylab = "PC2")
legend("topleft", legend = c("left", "right", "precipitated", "no"), pch = 16, col = c("blue", "red", "orange", "grey"))


plot(pca$x[, 1], pca$x[, 2], pch = 16, col = densCols(pca$x[, 1], pca$x[, 2], colramp = colorRampPalette(c("blue", "cyan", "green", "yellow", "orange", "red"))), main = "Point Density (Weird)", xlab = "PC1", ylab = "PC2")
abline(h = 0, lty =3, col = "grey")
abline(v = 0, lty = 3, col = "grey")


fviz_pca_biplot(pca, axes = c(1,2) , label = "var", col.var = "black", repel = T, col.ind = Weird_Sel_Crit[,14])


col = rep(NA, nrow(Weird_Sel_Crit))
col[which(Weird_Sel_Crit[, 15] == "yes")] = "blue"
col[which(Weird_Sel_Crit[, 15] == "partial")] = "orange"
col[which(Weird_Sel_Crit[, 15] == "no")] = "grey"

plot(pca$x[, 1], pca$x[, 2], pch = 16, col = col, main = "RDPs and non RDPs (Weird)", xlab = "PC1", ylab = "PC2")
legend("topleft", legend = c("RDP", "partial RDP", "non RDP"), pch = 16, col = c("blue","orange", "grey"))

rm(col, pca)
```


#### Extra: Automatic Graph Plotter

Our function `Gene_Plotter` generates plots of protein distributions of specified genes. The default function is:

Gene_Plotter(gene.name, col = c("green", "red", "dodgerblue", "darkorange"), Ctrl = TRUE, RNase = TRUE, Gbl.Max = TRUE, Loc.Max = TRUE, Gauss = TRUE, conf = TRUE, grid = TRUE, Type = "Smooth and Norm")

In its most basic form you can just type in the gene name of your gene of interest (e.g. *Gene_Plotter("CTCF_HUMAN")*) and get the normalized and smoothed protein distributions for the Control and RNase samples with global and local peaks and gaussian fitting for each global peak as an output.

But you can also specify the arguments to your liking:

  * **gene.name**: either just the name of a gene or a vector with multiple gene names (e.g. c("CTCF_HUMAN", "NAT10_HUMAN", "RL32_HUMAN")) (note: different genes are plotted separately)
  * **col**: vector specifying the colors used in the plot (col = c(**Control, RNase, Gauss Control, Gauss RNase**))
  * **Ctrl**: logical argument (TRUE or FALSE) that specifies whether or not information regarding the **Control sample** is shown
  * **RNase**: logical argument (TRUE or FALSE) that specifies whether or not information regarding the **RNase sample** is shown
  * **Gbl.Max**: logical argument (TRUE or FALSE) that specifies whether or not **global peaks** are shown
  * **Loc.Max**: logical argument (TRUE or FALSE) that specifies whether or not **local peaks** are shown
  * **Gauss**: logical argument (TRUE or FALSE) that specifies whether or not the **fitted gaussian curves** are shown (only available in Type "Smooth and Norm")
  * **conf**: logical argument (TRUE of FALSE) that specifies whether or not the 95 % confidence interval is shown (only available in Type "Smooth and Norm")
  * **grid**: logical argument (TRUE or FALSE) that specifies whether or not an **underlying grid** is shown
  * **Type**: specifies the type of data that is plotted; either as a single data type or a vector with multiple data types (available data types: **"Smooth and Norm", "Norm", "Smooth", "Raw", "Compare"**) (note: different data types are plotted separately)
  
```{r gene plotter, include=FALSE}
## To-Do
  # ggplot Unterstützung

Gene_Plotter <- function(gene.name, col = c("green", "red", "dodgerblue", "darkorange"), Ctrl = T, RNase = T, Gbl.Max = T, Loc.Max = T, Gauss = T, conf = T, grid = T, Type = "Smooth and Norm" #, "Norm", "Smooth", "Raw", "Compare"
                          ) {
library(scales)
  
genes = sapply(seq(1, length(gene.name), 1), function(j) { 

plots = sapply(seq(1, length(Type), 1), function (k) {
  
###################### Smoothed and Normalized ######################
if(Type[k] == "Smooth and Norm" & (Ctrl == T | RNase == T)) {
par(mar=c(5, 4, 4, 7), xpd=F)
  
plot(1:25, rep(NA, 25),xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(gene.name[j], "(Smoothed and Normalized)"), ylim=c(0, 1.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}
  )))

if(grid == T) {grid()}

if(conf == T & Ctrl == T) {
polygon(c(seq(1,25,1), seq(25,1,-1)), c(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),] - 1.96 * Ctrl_Norm100_sd[which(rownames(Ctrl_Mean)==gene.name[j]),], rev(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),] + 1.96 * Ctrl_Norm100_sd[which(rownames(Ctrl_Mean)==gene.name[j]),])), border = NA, col = alpha("grey", 0.5))}

if(conf == T & RNase == T) {
polygon(c(seq(1,25,1), seq(25,1,-1)), c(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]),] - 1.96 * RNase_Norm100_sd[which(rownames(RNase_Mean)==gene.name[j]),], rev(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]),] + 1.96 * RNase_Norm100_sd[which(rownames(RNase_Mean)==gene.name[j]),])), border = NA, col = alpha("grey", 0.5))}

if(Gbl.Max == T & Ctrl == T) {
segments(unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         -1, 
         unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], 
         lwd=3,col=col[1],lty=2)}
  
if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
segments(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         -1, 
         unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         unlist(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[1],lty=2)}

if(Ctrl == T) {    
lines(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = col[1])}
  
if(Gbl.Max == T & RNase == T) {
  segments(unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         -1, 
         unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], 
         lwd=3,col=col[2],lty=3)}
  
if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
segments(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         -1, 
         unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         unlist(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[2],lty=3)}

if(RNase == T) {
lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = col[2])}

if(Gbl.Max == T & Ctrl == T) {
points(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]), ], Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[1], cex=1.5)}

if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
points(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[1], cex=1.2)}

if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
points(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[2], cex=1.2)}

if(Gbl.Max == T & RNase == T) {
points(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]), ], RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]),unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[2], cex=1.5)}

if(Gauss == T & Ctrl == T) {
curve(Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 3]*(1/(Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 1])/Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 2])^2), add = T, lwd = 3, col = alpha(col[3], 0.5))
  
curve(Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),4]*(1/(Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),3]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),2])/Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),3])^2), add = T, lwd = 3, col = alpha(col[3], 0.5))  
  }

if(Gauss == T & RNase == T) {
curve(RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 3]*(1/(RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 1])/RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 2])^2), add = T, lwd = 3, col = alpha(col[4], 0.5))
  
  curve(Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),9]*(1/(Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),8]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),7])/Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),8])^2), add = T, lwd = 3, col = alpha(col[4], 0.5))  
  }

par(xpd=T)

legend("topright",inset = c(-0.23,0), 
       legend = c(if(Ctrl == T) {"Control"}, if(RNase == T) {"RNase"}, if(Gauss == T & Ctrl == T) {c("Gauss", "Control")}, if(Gauss == T & RNase == T) {c("Gauss", "RNase")}, if(Gbl.Max == T) {"Global"}, if(Loc.Max == T) {"Local"}), 
       pch = c(if(Ctrl == T) {NA}, if(RNase == T) {NA}, if(Gauss == T & Ctrl == T) {c(NA, NA)}, if(Gauss == T & RNase == T) {c(NA, NA)}, if(Gbl.Max == T) {21}, if(Loc.Max == T) {24}), 
       lty = c(if(Ctrl == T) {1}, if(RNase == T) {1}, if(Gauss == T & Ctrl == T) {c(1, NA)}, if(Gauss == T & RNase == T) {c(1, NA)}, if(Gbl.Max == T) {NA}, if(Loc.Max == T) {NA}), 
       col = c(if(Ctrl == T) {col[1]}, if(RNase == T) {col[2]}, if(Gauss == T & Ctrl == T) {c(alpha(col[3], 0.5), NA)}, if(Gauss == T & RNase == T) {c(alpha(col[4], 0.5), NA)}, if(Gbl.Max == T) { "black"}, if(Loc.Max == T) {"black"}), 
       lwd = c(if(Ctrl == T) {3}, if(RNase == T) {3}, if(Gauss == T & Ctrl == T) {c(3, NA)}, if(Gauss == T & RNase == T) {c(3, NA)},  if(Gbl.Max == T) {1.5}, if(Loc.Max == T) {1.5}))
}
#####################################################################

###################### Normalized ######################
if(Type[k] == "Norm" & (Ctrl == T | RNase == T)) {
  
par(mar=c(5, 4, 4, 7), xpd=F)

plot(1:25, rep(NA, 25),xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(gene.name[j], "(Normalized)"), ylim=c(0, 1.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])})))

if(grid == T) {grid()}

if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
segments(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), -4.3, unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 110, col = col[1], lty = 3, lwd = 3)}

if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
segments(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), -3.4, unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 110, col = col[2], lty = 3, lwd = 3)}

if(Gbl.Max == T & Ctrl == T) {
segments(unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), -4, unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 110, col = col[1], lty = 2, lwd = 3)}

if(Ctrl == T) {
lines(1:25, Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = col[1])}

if(Gbl.Max == T & RNase == T) {
segments(unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), -3, unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 110, col = col[2], lty = 2, lwd = 3)}

if(RNase == T) {
lines(1:25, RNase_Mean_Norm100[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = col[2])}

par(xpd=T)

legend("topright",inset = c(-0.25,0), 
       legend = c(if(Ctrl == T) {"Control"}, if(RNase == T) {"RNase"}, if(Gbl.Max == T) {"Global"}, if(Loc.Max == T) {"Local"}), 
       lty = c(if(Ctrl == T) {1}, if(RNase == T) {1}, if(Gbl.Max == T) {2}, if(Loc.Max == T) {3}), 
       col = c(if(Ctrl == T) {col[1]}, if(RNase == T) {col[2]}, if(Gbl.Max == T) {"grey"}, if(Loc.Max == T) {"grey"}), 
       lwd = c(if(Ctrl == T) {3}, if(RNase == T) {3}, if(Gbl.Max == T) {3}, if(Loc.Max == T) {3}))
}
########################################################

###################### Smoothed ######################
if(Type[k] == "Smooth" & (Ctrl == T | RNase == T)) {
  
par(mar=c(5, 4, 4, 7), xpd=F)
  
plot(1:25, rep(NA, 25),xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(gene.name[j], "(Smoothed)"), ylim=c(0, 1.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])})))

if(grid == T) {grid()}

if(Gbl.Max == T & Ctrl == T) {
segments(unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         -0.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}), 
         unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]), unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], 
         lwd=3,col=col[1],lty=2)}
  
if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
segments(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         -0.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}), 
         unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         unlist(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[1],lty=2)}

if(Ctrl == T) {  
lines(1:25, Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = col[1])}

if(Gbl.Max == T & RNase == T) {
  segments(unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         -0.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}), 
         unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         RNase_Mean_Smooth[which(rownames(RNase_Mean)==gene.name[j]), unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], 
         lwd=3,col=col[2],lty=3)}
  
if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
segments(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         -0.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),])}), 
         unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         unlist(RNase_Mean_Smooth[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[2],lty=3)}

if(RNase == T) {
lines(1:25, RNase_Mean_Smooth[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = col[2])}

if(Gbl.Max == T & Ctrl == T) {
points(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]), ], Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]),unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[1], cex=1.5)}

if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
points(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], Ctrl_Mean_Smooth[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[1], cex=1.2)}

if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
points(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], RNase_Mean_Smooth[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[2], cex=1.2)}

if(Gbl.Max == T & RNase == T) {
points(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]), ], RNase_Mean_Smooth[which(rownames(RNase_Mean)==gene.name[j]),unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[2], cex=1.5)}

par(xpd=T)

legend("topright",inset = c(-0.23,0), 
       legend = c(if(Ctrl == T) {"Control"}, if(RNase == T) {"RNase"}, if(Gbl.Max == T) {"Global"}, if(Loc.Max == T) {"Local"}), 
       pch = c(if(Ctrl == T) {NA}, if(RNase == T) {NA}, if(Gbl.Max == T) {21}, if(Loc.Max == T) {24}), 
       lty = c(if(Ctrl == T) {1}, if(RNase == T) {1}, if(Gbl.Max == T) {NA}, if(Loc.Max == T) {NA}), 
       col = c(if(Ctrl == T) {col[1]}, if(RNase == T) {col[2]}, if(Gbl.Max == T) { "black"}, if(Loc.Max == T) {"black"}), 
       lwd = c(if(Ctrl == T) {3}, if(RNase == T) {3}, if(Gbl.Max == T) {1.5}, if(Loc.Max == T) {1.5}))
}
######################################################

###################### Raw ######################
if(Type[k] == "Raw" & (Ctrl == T | RNase == T)) {
  
par(mar=c(5, 4, 4, 7), xpd=F)
  
plot(1:25, rep(NA, 25),xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(gene.name[j], "(Raw Data)"), ylim=c(0, 1.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])})))

if(grid == T) {grid()}

if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
segments(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), - 0.07 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 1.2 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), col = col[1], lty = 3, lwd = 3)}

if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
segments(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), -0.8 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 1.2 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), col = col[2], lty = 3, lwd = 3)}

if(Gbl.Max == T & Ctrl == T) {
segments(unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), - 0.93 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 1.2 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), col = col[1], lty = 2, lwd = 3)}

if(Ctrl == T) {  
lines(1:25, Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = col[1])}

if(Gbl.Max == T & RNase == T) {
segments(unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), - 0.7 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 1.2 * max(
  if(Ctrl == T) {max(Ctrl_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean[which(rownames(Ctrl_Mean)==gene.name[j]),])}), col = col[2], lty = 2, lwd = 3)}

if(RNase == T) {
lines(1:25, RNase_Mean[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = col[2])}

par(xpd=T)

legend("topright",inset = c(-0.25,0), 
       legend = c(if(Ctrl == T) {"Control"}, if(RNase == T) {"RNase"}, if(Gbl.Max == T) {"Global"}, if(Loc.Max == T) {"Local"}), 
       lty = c(if(Ctrl == T) {1}, if(RNase == T) {1}, if(Gbl.Max == T) {2}, if(Loc.Max == T) {3}), 
       col = c(if(Ctrl == T) {col[1]}, if(RNase == T) {col[2]}, if(Gbl.Max == T) {"grey"}, if(Loc.Max == T) {"grey"}), 
       lwd = c(if(Ctrl == T) {3}, if(RNase == T) {3}, if(Gbl.Max == T) {3}, if(Loc.Max == T) {3}))
}
#################################################
  
###################### Compare ######################
if(Type[k] == "Compare" & (Ctrl == T | RNase == T)) {
  
par(mar=c(5, 4, 4, 10), xpd=F)
  
plot(1:25, rep(NA, 25),xlab="Protein Fractions",ylab="Relative Protein Amount",main=paste(gene.name[j], "(Norm/Smooth v. Norm)"), ylim=c(0, 1.1 * max(
  if(Ctrl == T) {max(Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(Ctrl == T) {max(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}, 
  if(RNase == T) {max(RNase_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),])}
  )))

if(grid == T) {grid()}

if(Gbl.Max == T & Ctrl == T) {
segments(unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         -1, 
         unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]), 
         Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], 
         lwd=3,col=col[1],lty=2)}
  
if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
segments(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         -1, 
         unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         unlist(Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[1],lty=2)}

if(Ctrl == T) {
lines(1:25, Ctrl_Mean_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = alpha(col[1], 0.35))

lines(1:25, Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),], type="l", lwd=3, col = col[1])}
  
if(Gbl.Max == T & RNase == T) {
  segments(unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         -1, 
         unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),]), 
         RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], 
         lwd=3,col=col[2],lty=3)}
  
if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
segments(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         -1, 
         unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         unlist(RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]), 
         lwd=3,col=col[2],lty=3)}

if(RNase == T) {
lines(1:25, RNase_Mean_Norm100[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = alpha(col[2], 0.35))

lines(1:25, RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]),], type="l", lwd=3, col = col[2])}

if(Gbl.Max == T & Ctrl == T) {
points(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]), ], Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]),unlist(Ctrl_Mean_Gbl_Max[which(rownames(Ctrl_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[1], cex=1.5)}

if(Loc.Max == T & Ctrl == T & !is.null(unlist(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))]))) {
points(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], Ctrl_Mean_Smooth_Norm100[which(rownames(Ctrl_Mean)==gene.name[j]), which(!is.na(Ctrl_Mean_Loc_Max[which(rownames(Ctrl_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[1], cex=1.2)}

if(Loc.Max == T & RNase == T & !is.null(unlist(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))]))) {
points(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]), which(!is.na(RNase_Mean_Loc_Max[which(rownames(RNase_Mean)==gene.name[j]),]))], pch=24, col="black", bg=col[2], cex=1.2)}

if(Gbl.Max == T & RNase == T) {
points(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]), ], RNase_Mean_Smooth_Norm100[which(rownames(RNase_Mean)==gene.name[j]),unlist(RNase_Mean_Gbl_Max[which(rownames(RNase_Mean)==gene.name[j]),])], pch=21, col="black", bg=col[2], cex=1.5)}

if(Gauss == T & Ctrl == T) {
curve(Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 3]*(1/(Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 1])/Ctrl_Gauss_Fit[which(rownames(Ctrl_Mean)==gene.name[j]), 2])^2), add = T, lwd = 3, col = alpha(col[3], 0.5))}

if(Gauss == T & RNase == T) {
curve(RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 3]*(1/(RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 2]*(sqrt(2*pi))))*exp(1)^(-(1/2)*((x-RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 1])/RNase_Gauss_Fit[which(rownames(RNase_Mean)==gene.name[j]), 2])^2), add = T, lwd = 3, col = alpha(col[4], 0.5))}

par(xpd=T)

legend("topright",inset = c(-0.39,0), 
       legend = c(if(Ctrl == T) {c("Control", "(Norm/Smooth)")}, if(RNase == T) {c("RNase", "(Norm/Smooth)")}, if(Ctrl == T) {"Control (Norm)"}, if(RNase == T) {"RNase (Norm)"}, if(Gauss == T & Ctrl == T) {"Gauss Ctrl"}, if(Gauss == T & RNase == T) {"Gauss RNase"}, if(Gbl.Max == T) {"Global"}, if(Loc.Max == T) {"Local"}), 
       pch = c(if(Ctrl == T) {c(NA, NA)}, if(RNase == T) {c(NA, NA)}, if(Ctrl == T) {NA}, if(RNase == T) {NA}, if(Gauss == T & Ctrl == T) {NA}, if(Gauss == T & RNase == T) {NA}, if(Gbl.Max == T) {21}, if(Loc.Max == T) {24}),
       lty = c(if(Ctrl == T) {c(1, NA)}, if(RNase == T) {c(1, NA)}, if(Ctrl == T) {1}, if(RNase == T) {1}, if(Gauss == T & Ctrl == T) {1}, if(Gauss == T & RNase == T) {1}, if(Gbl.Max == T) {NA}, if(Loc.Max == T) {NA}), 
       col = c(if(Ctrl == T) {c(col[1], NA)}, if(RNase == T) {c(col[2], NA)}, if(Ctrl == T) {alpha(col[1], 0.3)}, if(RNase == T) {alpha(col[2], 0.3)}, if(Gauss == T & Ctrl == T) {alpha(col[3], 0.5)}, if(Gauss == T & RNase == T) {alpha(col[4], 0.5)}, if(Gbl.Max == T) { "black"}, if(Loc.Max == T) {"black"}), 
       lwd = c(if(Ctrl == T) {c(3,NA)}, if(RNase == T) {c(3,NA)}, if(Ctrl == T) {3}, if(RNase == T) {3}, if(Gauss == T & Ctrl == T) {3}, if(Gauss == T & RNase == T) {3}, if(Gbl.Max == T) {1.5}, if(Loc.Max == T) {1.5}))
}
#####################################################

})
})
}
```

Let us see if it works!
```{r gene plotter}
Gene_Plotter("RTCA_HUMAN")
```
